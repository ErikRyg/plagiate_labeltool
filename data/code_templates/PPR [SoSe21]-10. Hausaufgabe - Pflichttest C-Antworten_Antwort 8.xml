<?xml version="1.0" encoding="UTF-8"?>
<quiz>
<!-- question: 2698432  -->
  <question type="coderunner">
    <name>
      <text>Struktur ArrayList (Neu; FERTIG)</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[Eure Aufgabe ist es, die Implementierung einer <strong>dynamischen Datenstruktur</strong>&nbsp; zu vervollständigen. Es handelt sich dabei um eine Arrayliste, welches im<br>Kern ein Array ist, das mit der Anzahl der Einträge <strong>wächst </strong>und <strong>schrumpft</strong>. Die Einträge selbst sollen beliebig lange Strings sein.<br>Ihnen ist bereits eine <em>main()</em> vorgegeben, die dem Benutzer ein Menü vorgibt, sowie zusätzliche Hilfsfunktionen, die bereits benutzt werden.<br><br>Hier sehen Sie schematisch, wie sich die Datenstruktur am Beispiel einer Einkaufsliste verhält:<br><p>Einkaufsliste<br>-----------------<br>(h) - Hinzufuegen<br>(l) - Loeschen<br>(a) - Ausgeben<br>(q) - Verlassen<br><br>Auswahl: h<br>Hinzufuegen: Gurke<br><br>Auswahl: h<br>Hinzufuegen: Käse<br><br>Auswahl: h<br>Hinzufuegen: Wurst<br><br>Auswahl: a<br>Ausgabe: <br># Ware<br>0 Gurke<br>1 Käse<br>2 Wurst<br><br>Auswahl: q<br>Verlassen<br><br></p><ol><li>Orientiert euch am vorgegeben Code und implementiert die Datenstruktur <strong>Arrlist</strong></li><ul><li>verwendet die beiden Begriffe <strong>elems </strong>und <strong>size </strong>für eure Variablen, damit die Tests auf eure Datenstruktur zugreifen können!</li></ul><li>Implementiert die Funktion <strong>arrlist_add(Arrlist* al, char* str)</strong>. Diese Funktion</li><ul><li>fügt am <strong>Ende </strong>der Arrayliste einen String hinzu</li><li>dazu muss der übergebene String <strong>kopiert</strong></li><li><strong></strong>das interne Array / die Liste <strong>vergrößert</strong></li><li>die Adresse des neuen Strings in das interne Array am Ende <strong>hinzugefügt </strong>werden</li></ul><li>Implementiert die Funktion <strong>arrlist_del_item(Arrlist* al, int index)</strong>. Diese Funktion soll</li><ul><li>den dynamisch erstellten String (aus der Funktion arrlist_add()) am Index <em>index</em> freigeben</li><li>alle Elemente die nachdem <em>index </em>stehen um 1 Index in der Liste nach vorne verschieben</li><li>das interne Array um 1 verkleinern, da ein Element entfernt wurde</li></ul><li>Abschließend soll eine Funktion <strong>arrlist_free(Arrlist *al)</strong> implementiert werden, diese</li><ul><li>soll <strong>alle </strong>beinhaltenden <strong>Strings </strong><strong>und </strong>anschließend die <strong>Datenstruktur </strong>an sich freigeben</li><li>eine Ausgabe mit "Verlassen" stehen<br></li></ul></ol><p><br></p><ul><li>Überprüft bei allen selbstgeschriebenen Funktionen, ob</li><ul><li>der <strong>Zeiger </strong>der 
Datenstruktur den ihr übergeben bekommt <strong>und </strong>die Liste (außer bei arrlist_add) <strong></strong>innerhalb der 
Datenstruktur <strong>existieren</strong>, bevor ihr auf ihnen zugreift</li><li>falls sie nicht existieren schreibt an der Stelle in der Funktion ein return, um den Funktionsaufruf zu beenden<br></li><li>dynamisch alloziierte Speicheranforderungen erfolgreich waren. Das wird getestet!</li></ul><li>Sie dürfen <strong>strlen(char* str)</strong> und <strong>strcpy(char* dest, char* src)</strong> aus der Standardbibliothek verwenden.</li><li>Achtet darauf, Speicherplatz, der <strong>nicht mehr</strong> benötigt wird, immer freizugeben<br></li></ul><p><br></p><p><span class="" style="color: rgb(197, 14, 31);">Hinweise:</span></p><ul><li>achtet bei den Funktionen auch darauf die Variable <em>size </em>anzupassen</li><li>um die Liste zu vergößern oder zu verkleinen empfiehlt sich die Funktion <strong>realloc()</strong><br></li></ul><br>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>7</defaultgrade>
    <penalty>0</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
    <coderunnertype>c_advanced</coderunnertype>
    <prototypetype>0</prototypetype>
    <allornothing>0</allornothing>
    <penaltyregime>0, 0, 5, 10, 20, ...</penaltyregime>
    <precheck>0</precheck>
    <hidecheck>0</hidecheck>
    <showsource>0</showsource>
    <answerboxlines>40</answerboxlines>
    <answerboxcolumns>100</answerboxcolumns>
    <answerpreload><![CDATA[#include <stdlib.h> // malloc-Familie
#include <stdio.h>  // printf()
#include <string.h> // strlen() strcpy()

#define BUF_SIZE 100

/* TODO: Arrlist */

void arrlist_init(Arrlist* al)
{
  al->size = 0;
  al->elems  = NULL;
}

void arrlist_print(Arrlist* al)
{
    if(!al)
        return;
    if(!al->elems)
        return;
    printf("# Ware\n");
    for(int i = 0; i < al->size; i++)
        printf("%d %s\n",i, al->elems[i]);
}

/* TODO: arrlist_add, arrlist_del_item und arrlist_free */

int main(){
    Arrlist einkaufsliste;
    char choice = 'q';
    char buf[BUF_SIZE];

    arrlist_init(&einkaufsliste);
    printf("Einkaufsliste\n"
            "-----------------\n"
            "(h) - Hinzufuegen\n"
            "(l) - Loeschen\n"
            "(a) - Ausgeben\n"
            "(q) - Verlassen\n");

    do{
        printf("\nAuswahl: ");
        choice = getchar();
        getchar();
        if(choice == 'q')
            break;
        switch(choice){
            case 'h':
                {
                    printf("Hinzufuegen: ");
                    fgets(buf, BUF_SIZE, stdin);
                    buf[BUF_SIZE-1] = '\0';
                    arrlist_add(&einkaufsliste, buf);
                }
                break;
            case 'l':
                {
                    printf("Löschen - Nummer: ");
                    int i = 0;
                    scanf("%d", &i);
                    getchar();
                    arrlist_del_item(&einkaufsliste, i);
                }
                break;
            case 'a':
                printf("Ausgabe: \n");
                arrlist_print(&einkaufsliste);
                break;
            default:
                printf("Unbekannte Option!");
                break;
        }
    }while(1);

    return(0);
}
]]></answerpreload>
    <globalextra></globalextra>
    <useace></useace>
    <resultcolumns></resultcolumns>
    <template></template>
    <iscombinatortemplate></iscombinatortemplate>
    <allowmultiplestdins></allowmultiplestdins>
    <answer><![CDATA[#include <stdlib.h> // malloc-Familie
#include <stdio.h>  // printf()
#include <string.h> // strlen() strcpy()

#define BUF_SIZE 100

typedef struct arrlist {
  char** elems;
  int size;
} Arrlist;

void arrlist_init(Arrlist* al)
{
  al->size = 0;
  al->elems  = NULL;
}

void arrlist_add(Arrlist* al, char* str)
{
  //Ueberpruefen ob al gueltig ist; wenn nicht, beenden
  if(!al)
    return;
  //Listengroesse inkrementieren
  al->size++;
  //Speicher fuer eine Kopie des uebergebenen Strings anfordern
  //bei fehlerhafter Allokation beenden
  char* tmp = malloc(sizeof(char)*strlen(str));
  if(!tmp)
    return;
  //uebergebenen String in neuen kopieren
  strcpy(tmp, str);
  //Listenarray um einen Eintrag vergroessern (re-allozieren)
  //bei fehlerhafter Allokation beenden
  al->elems = realloc(al->elems, sizeof(char*) * al->size);
  if(!al->elems){
    return;
  }
  //Kopierten String an das Listenarray anhaengen
  al->elems[al->size-1] = tmp;
}

void arrlist_del_item(Arrlist* al, int index)
{
    /* Pointer ueberpruefen */
    if(!al)
        return;
    if(!al->elems)
        return;
    if(index >= al->size)
        return;

    /* Gesuchtes Element freigeben */
    free(al->elems[index]);
    /* Elemente vorruecken */
    for(int i = index; i<(al->size-1); i++){
        al->elems[i] = al->elems[i+1];
    }
    /* Frei gewordenen Element nullen */
    al->elems[al->size-1] = NULL;
    /* Groeße vermindern */
    if(al->size>0)
        al->size--;
    /* Array verkleinern */
    al->elems = realloc(al->elems, sizeof(char*) * al->size);
    if(!al->elems){
        perror("Failed to allocate memory");
        return;
    }

}

void arrlist_free(Arrlist *al)
{
    if(!al)
        return;
    if(!al->elems)
        return;
    printf("Verlassen\n");
    for(int i = 0; i < al->size; i++)
        free(al->elems[i]);
    free(al->elems);
}



void arrlist_print(Arrlist* al)
{
    if(!al)
        return;
    if(!al->elems)
        return;
    printf("# Ware\n");
    for(int i = 0; i < al->size; i++)
        printf("%d %s\n",i, al->elems[i]);
}

int main(){
    Arrlist einkaufsliste;
    char choice = 'q';
    char buf[BUF_SIZE];

    arrlist_init(&einkaufsliste);
    printf("Einkaufsliste\n"
            "-----------------\n"
            "(h) - Hinzufuegen\n"
            "(l) - Loeschen\n"
            "(a) - Ausgeben\n"
            "(q) - Verlassen\n");

    do{
        printf("\nAuswahl: ");
        choice = getchar();
        getchar();
        if(choice == 'q')
            break;
        switch(choice){
            case 'h':
                {
                    printf("Hinzufuegen: ");
                    fgets(buf, BUF_SIZE, stdin);
                    buf[BUF_SIZE-1] = '\0';
                    arrlist_add(&einkaufsliste, buf);
                }
                break;
            case 'l':
                {
                    printf("Löschen - Nummer: ");
                    int i = 0;
                    scanf("%d", &i);
                    getchar();
                    arrlist_del_item(&einkaufsliste, i);
                }
                break;
            case 'a':
                printf("Ausgabe: \n");
                arrlist_print(&einkaufsliste);
                break;
            default:
                printf("Unbekannte Option!");
                break;
        }
    }while(1);
    arrlist_free(&einkaufsliste);
    return(0);
}
]]></answer>
    <validateonsave>1</validateonsave>
    <testsplitterre></testsplitterre>
    <language></language>
    <acelang></acelang>
    <sandbox></sandbox>
    <grader></grader>
    <cputimelimitsecs></cputimelimitsecs>
    <memlimitmb></memlimitmb>
    <sandboxparams></sandboxparams>
    <templateparams></templateparams>
    <hoisttemplateparams>1</hoisttemplateparams>
    <templateparamslang>twig</templateparamslang>
    <templateparamsevalpertry>0</templateparamsevalpertry>
    <templateparamsevald>{}</templateparamsevald>
    <twigall>0</twigall>
    <uiplugin></uiplugin>
    <uiparameters></uiparameters>
    <attachments>0</attachments>
    <attachmentsrequired>0</attachmentsrequired>
    <maxfilesize>10240</maxfilesize>
    <filenamesregex></filenamesregex>
    <filenamesexplain></filenamesexplain>
    <displayfeedback>1</displayfeedback>
    <giveupallowed>0</giveupallowed>
    <prototypeextra></prototypeextra>
    <testcases>
      <testcase testtype="0" useasexample="1" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text><![CDATA[Arrlist al;
arrlist_init(&al);

char* produkt = malloc(9*sizeof(char));
strcpy(produkt , "Schinken");
al.size++;
al.elems = realloc(al.elems, sizeof(char*) * al.size);
al.elems[al.size-1] = produkt;

printf("Produkt = %s; Größe = %i", al.elems[0], al.size);

]]></text>
      </testcode>
      <stdin>
                <text></text>
      </stdin>
      <expected>
                <text>Produkt = Schinken; Größe = 1
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>SHOW</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="1" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text>main();</text>
      </testcode>
      <stdin>
                <text>h
Gurke
X
H
h
Kaese
h
Wurst
a
l
1
a
q</text>
      </stdin>
      <expected>
                <text>Einkaufsliste
-----------------
(h) - Hinzufuegen
(l) - Loeschen
(a) - Ausgeben
(q) - Verlassen

Auswahl: Hinzufuegen:
Auswahl: Unbekannte Option!
Auswahl: Unbekannte Option!
Auswahl: Hinzufuegen:
Auswahl: Hinzufuegen:
Auswahl: Ausgabe:
# Ware
0 Gurke
1 Kaese
2 Wurst

Auswahl: Löschen - Nummer:
Auswahl: Ausgabe:
# Ware
0 Gurke
1 Wurst

Auswahl: Verlassen
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>SHOW</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text>main();</text>
      </testcode>
      <stdin>
                <text>h
Orangen
A
h
Wodka
h
Orangenpresse
h
Energydrink
a
l
2
a
q
</text>
      </stdin>
      <expected>
                <text>Einkaufsliste
-----------------
(h) - Hinzufuegen
(l) - Loeschen
(a) - Ausgeben
(q) - Verlassen

Auswahl: Hinzufuegen:
Auswahl: Unbekannte Option!
Auswahl: Hinzufuegen:
Auswahl: Hinzufuegen:
Auswahl: Hinzufuegen:
Auswahl: Ausgabe:
# Ware
0 Orangen
1 Wodka
2 Orangenpresse
3 Energydrink

Auswahl: Löschen - Nummer:
Auswahl: Ausgabe:
# Ware
0 Orangen
1 Wodka
2 Energydrink

Auswahl: Verlassen
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>HIDE_IF_SUCCEED</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text><![CDATA[Arrlist al;
arrlist_init(&al);

arrlist_add(&al, "Kartoffeln");
arrlist_add(&al, "Champignons");
arrlist_add(&al, "Tomaten");

arrlist_print(&al);]]></text>
      </testcode>
      <stdin>
                <text></text>
      </stdin>
      <expected>
                <text># Ware
0 Kartoffeln
1 Champignons
2 Tomaten
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>HIDE_IF_SUCCEED</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text><![CDATA[Arrlist al;
arrlist_init(&al);

char* produkt1 = malloc(6*sizeof(char));
strcpy(produkt1 , "Wurst");
al.size++;
al.elems = realloc(al.elems, sizeof(char*) * al.size);
al.elems[al.size-1] = produkt1;

char* produkt2 = malloc(5*sizeof(char));
strcpy(produkt2, "Brot");
al.size++;
al.elems = realloc(al.elems, sizeof(char*) * al.size);
al.elems[al.size-1] = produkt2;

printf("Produkt1 = %s; Größe = %i\n", al.elems[0], al.size);
printf("Produkt2 = %s; Größe = %i\n", al.elems[1], al.size);
arrlist_del_item(&al, 0);
printf("Produkt1 = %s; Größe = %i\n", al.elems[0], al.size);
]]></text>
      </testcode>
      <stdin>
                <text></text>
      </stdin>
      <expected>
                <text>Produkt1 = Wurst; Größe = 2
Produkt2 = Brot; Größe = 2
Produkt1 = Brot; Größe = 1
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>HIDE_IF_SUCCEED</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="1" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text><![CDATA[Arrlist al;
arrlist_init(&al);

arrlist_add(&al, "Salat");
arrlist_add(&al, "Zwiebeln");
arrlist_add(&al, "Brokkoli");

arrlist_print(&al);
arrlist_del_item(&al, 1);
arrlist_print(&al);
]]></text>
      </testcode>
      <stdin>
                <text></text>
      </stdin>
      <expected>
                <text># Ware
0 Salat
1 Zwiebeln
2 Brokkoli
# Ware
0 Salat
1 Brokkoli
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>SHOW</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text><![CDATA[Arrlist* al;
arrlist_init(al);

char* produkt = malloc(9*sizeof(char));
strcpy(produkt , "Schinken");
al->size++;
al->elems = realloc(al->elems, sizeof(char*) * al->size);
al->elems[al->size-1] = produkt;

arrlist_free(al);

]]></text>
      </testcode>
      <stdin>
                <text></text>
      </stdin>
      <expected>
                <text></text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>HIDE_IF_SUCCEED</text>
      </display>
    </testcase>
    </testcases>
  </question>

</quiz>