<?xml version="1.0" encoding="UTF-8"?>
<quiz>
<!-- question: 2180173  -->
  <question type="coderunner">
    <name>
      <text>Das beste Passwort der Welt (Kommandozeilenargumente)</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p>Schreibt ein Programm</p><ul><li>Dass am Programmstart einige Wörter als Kommandozeilenargumente übergeben bekommt (diese stehen dann während des Programmablaufs als Zeichenketten zur Verfügung)</li><li>Diese Zeichenketten sollen aneinander gehängt und die Buchstaben 'x', 'y', 'q', bzw. auch 'X', 'Y' und 'Q' aussortiert werden. Gebt das Ergebnis aus</li><li>Erweitert das Programm dann so, dass von der verbliebenen Zeichenkette jedes 3te Zeichen in einen neuen String kopiert wird, der dann am Ende ausgegeben wird. Beginnend vom ersten Buchstaben an (siehe erwartete Ausgabe des ersten Tests)<br></li><li>Ihr dürft string.h nicht verwenden</li></ul><p><span class="" style="color: rgb(255, 207, 53);">Hinweise:</span><br></p><ul><li>Kommandozeilenargumente wurden in der Vorlesung zu Strings besprochen.</li><li> Denkt an das Terminationszeichen...</li></ul><p><br></p>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>5</defaultgrade>
    <penalty>0</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
    <coderunnertype>c_program</coderunnertype>
    <prototypetype>0</prototypetype>
    <allornothing>1</allornothing>
    <penaltyregime>0, 10, 20, ...</penaltyregime>
    <precheck>0</precheck>
    <hidecheck>0</hidecheck>
    <showsource>0</showsource>
    <answerboxlines>35</answerboxlines>
    <answerboxcolumns>100</answerboxcolumns>
    <answerpreload></answerpreload>
    <globalextra></globalextra>
    <useace></useace>
    <resultcolumns></resultcolumns>
    <template><![CDATA[{# name of the function you want to parse (flexibel) #}
{% set function_name = "main" %}
{# parse STUDENT_ANSWER #}
{% set text_after_function_name = STUDENT_ANSWER | split(function_name)[1] %}
{# constants (DO NOT CHANGE) #}
{% set occurence_of_open = 0 %}
{% set occurence_of_close = 0 %}
{% set function_string = "" %}
{% set parsing_done = false %}
{# outer loop { #}
{% for text_till_next_opened_brace in text_after_function_name | split("{")  %}
    {# Count how many { HAVE ALREADY occured.#}
    {% if not loop.first %}
        {% set occurence_of_open = occurence_of_open + 1 %}
    {% endif %}
    {# add { to string. First not because it has occured before first { second not, as we only want the content inside the {} #}
    {% if not parsing_done and loop.index0 >=2%}
        {% set function_string = function_string ~ "{" %}
    {% endif %}
    {# we need the information later #}
    {% set outer_loop_first = loop.first %}
    {# inner loop } #}
    {% for text_till_next_closed_brace in text_till_next_opened_brace | split("}")  %}
        {# Count how many } HAVE ALREADY occured.#}
        {% if not loop.first %}
            {% set occurence_of_close = occurence_of_close + 1 %}
        {% endif %}
        {# if this criterium holds, function is over } #}
        {% if occurence_of_open <= occurence_of_close and occurence_of_open > 0 %}
            {% set parsing_done = true %}
        {% endif %}
        {# content before and after fucntion is ignored } #}
        {% if not parsing_done and not outer_loop_first%}
            {# add } to string  #}
            {% if not loop.first %}
                {% set function_string = function_string ~ "}" %}
            {% endif %}
            {# add CONTENT to the string #}
            {% set function_string = function_string ~ text_till_next_closed_brace %}
        {% endif %}
    {% endfor %}
{% endfor %}

{% if "return" in function_string %}
    {% set function_has_return = true %}
{% else %}
    {% set function_has_return = false %}
{% endif %}

{% if function_has_return %}
{{ STUDENT_ANSWER | replace({'int main': 'int student_main'}) }} 
{% else %}
{{ STUDENT_ANSWER | replace({'int main': 'void student_main', 'void main': 'void student_main'}) }} 
{% endif %}

{% set arguments = '{"Filename_whatever"' %}
{% set input_array = TEST.stdin | split('\n') %}
{% for input in input_array %}
    {% set arguments = arguments ~ ', "' %}
    {% set arguments = arguments ~ input %}
    {% set arguments = arguments ~ '"' %}
{% endfor %}
{% set arguments = arguments ~ '}' %}
{% set arguments_length = input_array |length + 1 %}

int main() {
    int argc = {{arguments_length}};
    char* argv[{{argument_length}}] = {{ arguments }};
    student_main(argc, argv);
}]]></template>
    <iscombinatortemplate></iscombinatortemplate>
    <allowmultiplestdins></allowmultiplestdins>
    <answer><![CDATA[#include <stdio.h>

int main(int argc, char* argv[])
{
  int sammelzaehler = 0;
  char kollektion[100] = "";
  for(int j = 1; j < argc; j++)
  {
    for(char* p = argv[j]; (*p) != '\0'; p++)
    {
      if((*p != 'x')&&(*p != 'y')&&(*p != 'q')&&(*p != 'X')&&(*p != 'Y')&&(*p != 'Q'))
      {
        kollektion[sammelzaehler] = *p;
        sammelzaehler++;
      }
    }
  }
  kollektion[sammelzaehler] = '\0';
  printf("x,y,q und X,Y,Q aussortiert: %s\n", kollektion);
  char neuerString[100] = "";
  int i=0;
  for(; i < sammelzaehler; i += 3)
  {
      neuerString[i/3] = kollektion[i];
  }
  neuerString[i/3] = '\0';
  printf("Der neue String lautet: %s \n", neuerString );
}
 ]]></answer>
    <validateonsave>1</validateonsave>
    <testsplitterre></testsplitterre>
    <language></language>
    <acelang></acelang>
    <sandbox></sandbox>
    <grader>NearEqualityGrader</grader>
    <cputimelimitsecs></cputimelimitsecs>
    <memlimitmb></memlimitmb>
    <sandboxparams></sandboxparams>
    <templateparams></templateparams>
    <hoisttemplateparams>1</hoisttemplateparams>
    <templateparamslang>twig</templateparamslang>
    <templateparamsevalpertry>0</templateparamsevalpertry>
    <templateparamsevald></templateparamsevald>
    <twigall>0</twigall>
    <uiplugin></uiplugin>
    <uiparameters></uiparameters>
    <attachments>0</attachments>
    <attachmentsrequired>0</attachmentsrequired>
    <maxfilesize>10240</maxfilesize>
    <filenamesregex></filenamesregex>
    <filenamesexplain></filenamesexplain>
    <displayfeedback>1</displayfeedback>
    <giveupallowed>0</giveupallowed>
    <prototypeextra></prototypeextra>
    <testcases>
      <testcase testtype="0" useasexample="1" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text>1. Test (./[programm] lasse roland max ivo)</text>
      </testcode>
      <stdin>
                <text>lasse
roland
max
ivo</text>
      </stdin>
      <expected>
                <text>x,y,q und X,Y,Q aussortiert: lasserolandmaivo
Der neue String lautet: lsonao
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>SHOW</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text>2. Test (./[programm] PPR macht Spass!)</text>
      </testcode>
      <stdin>
                <text>PPR
macht
Spass!</text>
      </stdin>
      <expected>
                <text>x,y,q und X,Y,Q aussortiert: PPRmachtSpass!
Der neue String lautet: Pmhps
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>SHOW</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text>3. test (./[programm] Dieser-Test-ist-geheim?!)</text>
      </testcode>
      <stdin>
                <text>Dieser-Test-ist-geheim?!</text>
      </stdin>
      <expected>
                <text>x,y,q und X,Y,Q aussortiert: Dieser-Test-ist-geheim?!
Der neue String lautet: Ds-si-hm
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>HIDE</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text>4. Test (./[programm] Mein Name ist Quentin.)</text>
      </testcode>
      <stdin>
                <text>Mein
Name
ist
Quentin.</text>
      </stdin>
      <expected>
                <text>x,y,q und X,Y,Q aussortiert: MeinNameistuentin.
Der neue String lautet: Mnmsei
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>HIDE_IF_SUCCEED</text>
      </display>
    </testcase>
      <testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.0000000" >
      <testcode>
                <text>5. Test (./[programm] xYzq XyZQ)</text>
      </testcode>
      <stdin>
                <text>xYzq
XyZQ</text>
      </stdin>
      <expected>
                <text>x,y,q und X,Y,Q aussortiert: zZ
Der neue String lautet: z
</text>
      </expected>
      <extra>
                <text></text>
      </extra>
      <display>
                <text>SHOW</text>
      </display>
    </testcase>
    </testcases>
  </question>

</quiz>