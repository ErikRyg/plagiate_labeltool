Nachname,Vorname,E-Mail-Adresse,Status,"Begonnen am",Beendet,"Verbrauchte Zeit","Bewertung/20,00","Antwort 1","Antwort 2","Antwort 3","Antwort 4","Antwort 5","Antwort 6","Antwort 7","Antwort 8","Antwort 9"
Chaudhary,Pradeep,p.chaudhary@campus.tu-berlin.de,Beendet,"11. Juni 2021  08:39","20. Juni 2021  23:59","9 Tage 15 Stunden","10,50","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Getter und Setter","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","static
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 50; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 51; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 52; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: 0; Teil 30: 0; Teil 31: 1; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if(denominator < 0) {
			this.denominator = - denominator;
			this.numerator = - numerator;
		} 
		else if( denominator == 0){
			this.denominator = 1;
		}
		else this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;   
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (numerator+""/""+denominator);   
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int temp = GCD(numerator,denominator);
		numerator = numerator / temp;
		denominator = denominator / temp;
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        f.numerator = numerator * f.denominator + f.numerator * denominator;
    	f.denominator = denominator * f.denominator;
    	Fraction newFraction = new Fraction(f.numerator,f.denominator);
    	newFraction.shorten();
		return newFraction;   
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        f.numerator = numerator * f.numerator;
		f.denominator = denominator * f.denominator;
		Fraction newFraction = new Fraction(f.numerator,f.denominator);
		newFraction.shorten();
		return newFraction;    
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(numerator == 0){	
			numerator = numerator;				
			denominator = denominator;
			Fraction newFraction31 = new Fraction(numerator,denominator);
			return newFraction31;
		}
    	int temp = numerator;					
		numerator = denominator;
		denominator = temp;             		
		Fraction newFraction32 = new Fraction(numerator,denominator);
		return newFraction32;     
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        int temp = f.numerator;
		f.numerator = numerator * f.denominator;	    
		f.denominator = denominator * temp;
		Fraction newFraction = new Fraction(f.numerator,f.denominator);
		newFraction.shorten();
		return newFraction;   
    }
    
}",-
Schmidt,Lucca,lucca.schmidt@campus.tu-berlin.de,Beendet,"11. Juni 2021  11:44","18. Juni 2021  11:29","6 Tage 23 Stunden","18,47","void
; private
; static","Setter-Methoden haben in der Regel den Rückgabetyp void","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","public class RechteckTest
{
    public static void main(String[] args)  {   
        
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
    }
}

 class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: -; Teil 127: -; Teil 128: -; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
        if(this.denominator == 0) this.denominator = 1;
        if(this.denominator < 0){
            this.denominator = - this.denominator;
            this.numerator = - this.numerator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;  
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double x = (double)(this.numerator)/(double)(this.denominator);
        return x;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return Integer.toString(this.numerator)+""/""+Integer.toString(this.denominator); 
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
        if(gcd != 0) {
            this.numerator = this.numerator/gcd;
            this.denominator = this.denominator/gcd;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(this.denominator, f.denominator);
        //System.out.println(""KgV: ""+lcm);
        int mult1 = lcm / this.denominator;
        int mult2 = lcm / f.denominator;
        //System.out.println(""mult1: "" + mult1 + ""\n"" + ""mult2:"" + mult2); 
        Fraction aF = new Fraction(this.numerator*mult1 + f.numerator*mult2, lcm);
        /*System.out.println(""Zaehler ungekuerzt: "" + this.numerator*mult1 + f.numerator*mult2+ ""\n"" +
                            ""Nenner ungekuerzt: "" + lcm); */
        aF.shorten();
        return aF;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction mF = new Fraction(this.numerator*f.numerator, this.denominator*f.denominator);
        mF.shorten();
        return mF;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(this.numerator != 0){
           Fraction rF = new Fraction(this.denominator, this.numerator); 
           return rF;
        } 
        else{
            Fraction nrF = new Fraction(this.numerator, this.denominator);
            return nrF;
        } 
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction nnrF = f.reciprocal(); //geht das so einfach zu speichern?
        Fraction dF = new Fraction(this.numerator*nnrF.numerator, this.denominator*nnrF.denominator);
        dF.shorten();
        return dF;
    }
    
}","public class SubwayTest{
	public static void main(String[] args) {
	Subway u1 = new Subway(3);
	Wagen w1 = new Wagen(20,30);
	u1.addWagen(w1);
	Wagen w2 = new Wagen(15,25);
	u1.addWagen(w2);
	int x = u1.getCapacity();
	int y = u1.getSeats();
	int z = u1.getStandingRoom();
	System.out.println(""Anzahl Sitzplaetze in der U1: ""+y+""\n""+
						""Anzahl Stehplaetze in der U1: ""+z+""\n""+
						""Anzahl Plaetze insgesamt in der U1: ""+x);
	u1.removeWagen();
	u1.removeWagen();
	u1.removeWagen();
	u1.removeWagen();
	u1.removeWagen(); 
	}
}"
Dukart,Kevin,dukart@campus.tu-berlin.de,Beendet,"11. Juni 2021  11:45","20. Juni 2021  11:34","8 Tage 23 Stunden","15,90","Setter-Methoden haben in der Regel den Rückgabetyp void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Getter und Setter","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","class
; private","Teil 1: %; Teil 2: %; Teil 3: %; Teil 4: %; Teil 5: %; Teil 6: %; Teil 7: %; Teil 8: %; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: %; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: %; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

	private int numerator, denominator;

	/**
	 * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common
	 * Divider) zurück.
	 */
	public static int GCD(int x, int y) {
		if (y == 0)
			return x;
		return GCD(y, x % y);
	}

	/**
	 * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common
	 * Multiple) zurück.
	 */
	public static int LCM(int x, int y) {
		return (x * y) / GCD(x, y);
	}

	// Beginn der Aufgabe
	/**
	 * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner uebergeben
	 * bekommt und die entsprechenden Attribute setzt. Negative Vorzeichen (Zahlen
	 * kleiner als Null) duerfen nur im Zaehler auftreten (nicht im
	 * ""denominator""-Attribut). Die Uebergabe eines negativen Nenners
	 * (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig. Der
	 * Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so
	 * behandeln, dass der resultierende Bruch (die Attribute) die genannte
	 * Restriktion erfüllt und der Wert des Bruchs (die Argumente) unverändert
	 * bleibt (ein negatives Vorzeichen im Nenner muss also methematisch korrekt
	 * beseitigt werden). Wird eine Null als Nenner uebergeben, so wird das
	 * entsprechende Attribut auf Eins gesetzt. Jeder erzeugte Bruch wird gekuerzt
	 * (dazu soll die entsprechende Mehode s.u. verwendet werden).
	 */
	public Fraction(int numerator, int denominator) {

		if (denominator < 0) {
			this.denominator = denominator * (-1);
			this.numerator = numerator * (-1);
		} else if (denominator == 0) {
			this.denominator = 1;
			this.numerator = numerator;
		} else {
			this.denominator = denominator;
			this.numerator = numerator;
		}
		shorten();
	}

	/**
	 * Gibt den Nenner zurueck.
	 */
	public int getDenominator() {
		return denominator;

	}

	/**
	 * Gibt den Zaehler zurueck.
	 */
	public int getNumerator() {
		return numerator;

	}

	/**
	 * Gibt den Bruch als Gleitkommazahl zurueck.
	 */
	public double toDouble() {
		return (double) numerator / (double) denominator;

	}

	/**
	 * Gibt einen String im Format ""Zaehler/Nenner"" zurueck.
	 */
	public String toString() {
		return numerator + ""/"" + denominator;

	}

	/**
	 * Kuerzt (vereinfacht) den Bruch.
	 */
	public void shorten() {
		int gcd = GCD(numerator, denominator);
		numerator = numerator / gcd;
		denominator = denominator / gcd;

	}

	/**
	 * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
	 */
	public Fraction add(Fraction f) {
		Fraction fneu = new Fraction(0, 0);
		fneu.denominator = denominator * LCM(denominator, f.denominator) / denominator ;
		fneu.numerator = numerator * (fneu.denominator / denominator) + f.numerator *(fneu.denominator /f.denominator); 
		return fneu;
	}

	/**
	 * Multipliziert mit dem uebergebenen Bruch.
	 */
	public Fraction multiply(Fraction f) {
		Fraction fneu = new Fraction(0, 0);
		fneu.numerator = f.numerator * numerator;
		fneu.denominator = f.denominator * denominator;

		return fneu;
	}

	/**
	 * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist. Sonst wird der Bruch
	 * unveraendert zurueckgegeben.
	 */
	public Fraction reciprocal() {
		Fraction fneu = new Fraction(0, 0);
		if (numerator != 0) {
			int numeratorN = numerator;
			fneu.numerator = denominator;
			fneu.denominator = numeratorN;

		}
		else {
			fneu.numerator = numerator;
			fneu.denominator = denominator;
		}
		return fneu;

	}

	/**
	 * Dividiert durch den uebergebenen Bruch (unter Verwendung von Kehrwert und
	 * Multiplikation).
	 */
	public Fraction divide(Fraction f) {
		Fraction fneu = new Fraction(0, 0);
		Fraction frep = f.reciprocal();
		
		fneu = multiply(frep);
		
		return fneu;

	}

}","public class SubwayTest {

	public static void main(String[] args) {

		Subway sub1 = new Subway(3);

		sub1.addWagen(new Wagen(20, 50));
		sub1.addWagen(new Wagen(30, 60));

		System.out.println(""Sitzplätze: "" + sub1.getSeats() + ""\nStehplätze: "" + sub1.getStandingRoom()
				+ ""\nalle Plätze: "" + sub1.getCapacity());

		sub1.addWagen(new Wagen(15, 50));
		sub1.addWagen(new Wagen(10, 100));
		
		sub1.removeWagen();
		sub1.removeWagen();
		sub1.removeWagen();
		sub1.removeWagen();
		sub1.removeWagen();
	}

}"
Hadhri,"Mehdi Abdelfattah",m.hadhri@campus.tu-berlin.de,Beendet,"11. Juni 2021  12:29","19. Juni 2021  12:12","7 Tage 23 Stunden","8,58","void
; private
; static","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Verhindern, dass Attributswerte gesetzt werden

; Setzen falscher Attributwerte verhindern

; Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","public class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }

	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0){
            this.numerator=-numerator;
            this.denominator=-denominator;
        }
        else if(denominator==0) {
            this.numerator=numerator;
            this.denominator = 1;
        }
        else {
            this.numerator=numerator;
            this.denominator=denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double b = numerator/(double)denominator;
        return b;

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        int a = this.numerator;
        int b = this.denominator;
        String s = a+""/""+b;
        return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int g = GCD(numerator, denominator);
        numerator/=g;
        denominator/=g;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int k=LCM(denominator, f.denominator);
        int t=k/denominator;
        int z=k/f.denominator;
        numerator=t*numerator;
        f.numerator=z*f.numerator;
        int n=f.numerator+numerator;
        int d=f.denominator+denominator;
        return new Fraction(n,k);

    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(f.numerator*numerator, f.denominator*denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(numerator==0){
            return new Fraction(numerator,denominator);
        }
        else {
            return new Fraction(denominator,numerator);
        }


    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f = multiply(f.reciprocal());
        return f;
    }
}",-
Schubert,Tom,tom.schubert@campus.tu-berlin.de,Beendet,"11. Juni 2021  17:04","18. Juni 2021  11:14","6 Tage 18 Stunden","11,89","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","void
; private
; static","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: undef; Teil 10: undef; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: 0; Teil 79: %; Teil 80: 0; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest {
	public static void main(String []args) {
		Subway u7 = new Subway(3);
		Wagen w1 = new Wagen(12,13);
		u7.addWagen(w1);
		Wagen w2 = new Wagen(69,69);
		u7.addWagen(w2);
		System.out.println(u7.getSeats());
		System.out.println(u7.getStandingRoom());
		System.out.println(u7.getCapacity());
		Wagen w3 = new Wagen(0,0);
		u7.addWagen(w3);
		Wagen w4 = new Wagen(0,0);
		u7.addWagen(w4);
		for(int i=0; i<5;i++) {
		u7.removeWagen();
		}	
	}	
}"
Hecht,Leon,leon.hecht@campus.tu-berlin.de,Beendet,"11. Juni 2021  20:32","13. Juni 2021  23:33","2 Tage 3 Stunden","18,92","static
; void
; private","class Rechteck {
    private int breite;

    public void setBreite(int breite) {
        this.breite = breite;
    }

    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
    public static void main(String[] args)  {

        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
    }
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: l; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: m; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: l; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0){
            denominator = 1;
        }
        if (denominator < 0){
            this.numerator = (-1) * numerator;
            this.denominator = (-1) * denominator;
        } else {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str1 = + this.numerator + ""/"" + this.denominator;
        return str1;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/gcd;
        this.denominator = this.denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(f.denominator, this.denominator);
        Fraction fraction = new Fraction(0,1);
        fraction.numerator = this.numerator * (lcm/this.denominator) + f.numerator * (lcm/f.denominator);
        fraction.denominator = lcm;
        fraction.shorten();
        return fraction;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction fraction = new Fraction(0,1);
        fraction.numerator = f.numerator * this.numerator;
        fraction.denominator = f.denominator * this.denominator;
        fraction.shorten();
        return fraction;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction fraction = new Fraction(this.numerator,this.denominator);
        if (this.numerator != 0) {
            fraction.numerator = this.denominator;
            fraction.denominator = this.numerator;
        }
        return fraction;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction fraction = new Fraction(this.numerator,this.denominator);
        Fraction fraction1;
        fraction1 = f.reciprocal();
        Fraction f3 = fraction.multiply(fraction1);
        f3.shorten();
        return f3;
    }

}","public class SubwayTest {

    public static void main(String[] args) {
        Subway subway = new Subway(3);
        Wagen wagen1 = new Wagen(4,8);
        Wagen wagen2 = new Wagen(10,15);
        subway.addWagen(wagen1);
        subway.addWagen(wagen2);
        System.out.println(subway.getSeats());
        System.out.println(subway.getStandingRoom());
        System.out.println(subway.getCapacity());
        Wagen wagen3 = new Wagen(2,4);
        Wagen wagen4 = new Wagen(12,2);
        subway.addWagen(wagen3);
        subway.addWagen(wagen4);
        subway.removeWagen();
        subway.removeWagen();
        subway.removeWagen();
        subway.removeWagen();
        subway.removeWagen();
    }
}"
"Al Hamwi",Nassim,nassim.alhamwi@campus.tu-berlin.de,Beendet,"12. Juni 2021  13:34","19. Juni 2021  12:06","6 Tage 22 Stunden","19,47","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","static
; void
; private","public class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }



	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: 50; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if(denominator>0){
			this.denominator=denominator;
			this.numerator=numerator;
		}
		else if(denominator==0){
			this.numerator=numerator;
			this.denominator=1;
		}
		else{
			this.denominator=-denominator;
			this.numerator=-numerator;
			
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double u=numerator/(double)denominator;
        return u;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String Bruch=numerator+""/""+denominator;
		return Bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int x=GCD(numerator, denominator);
		numerator=numerator/x;
		denominator=denominator/x;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int y=LCM(denominator, f.denominator);
	   int r=y/denominator;
	   int e=y/f.denominator;
	   numerator=r*numerator;
	   f.numerator=e*f.numerator;
	   int t=f.numerator+numerator;
	   int z=f.denominator+denominator;
	   return new Fraction(t,y);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(f.numerator*numerator, f.denominator*denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		int q=denominator;
	    int w=numerator;
		if(w==0){
			q=denominator;
			w=numerator;
			return new Fraction(w, q);
		}
        else{
		   return new Fraction(q, w);
	   }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f=f.reciprocal();
	   int x =f.numerator*numerator;
	   int y = denominator*f.denominator;
	   return new Fraction(x,y);
    }
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest{
	public static void main(String[] args){
			Subway u5=new Subway(3);
			Wagen eins=new Wagen(5,4);
			Wagen zwei=new Wagen(67,2);
			u5.addWagen(eins);
			u5.addWagen(zwei);
			System.out.println(u5.getSeats());
			System.out.println(u5.getStandingRoom());
			System.out.println(u5.getCapacity());
			Wagen drei=new Wagen(15,14);
			u5.addWagen(drei);
			Wagen vier=new Wagen(7,2);
			u5.addWagen(vier);
			u5.removeWagen();
			u5.removeWagen();
			u5.removeWagen();
			u5.removeWagen();
			u5.removeWagen();
	}
}"
Huang,Chenghao,chenghao.huang@campus.tu-berlin.de,Beendet,"12. Juni 2021  23:19","20. Juni 2021  10:47","7 Tage 11 Stunden","10,47","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; void
; static","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3（15）; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4（15）; Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5（15）; Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6（15）; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 0; Teil 62: %; Teil 63: 7（15）; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3（17）; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4（17）; Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5（17）; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6（17）; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7（17）; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
         if(numerator!=0&&denominator!=0)
        {
            int gcd = GCD(numerator, denominator);
            denominator=denominator/gcd;
            numerator=numerator/gcd;
        }
        if(denominator==0)
        {
            denominator=1;
        }
        if(denominator<0)
        {
            denominator=-denominator;
            numerator=-numerator;
        }
        this.denominator=denominator;
        this.numerator=numerator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
          return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         return (double) numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int x=0;
        int y=0;
        if(numerator<denominator)
        {
            x=numerator;
            y=denominator;
        }
        else {
            x=denominator;
            y=numerator;
        }
        int num=1;
        for (int i = 1; i <=x; i++) {
            if (x%i==0 && y%i==0)
            {
                num=i;
            }
        }
        numerator=numerator/num;
        denominator=denominator/num;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
   Fraction fraction= new Fraction(numerator*f.getDenominator() + denominator*f.getNumerator(),denominator*f.getDenominator());
     fraction.shorten();
     return fraction;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
         Fraction fraction= new Fraction(numerator * f.getNumerator(),denominator*f.getDenominator());
        fraction.shorten();
        return fraction;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction fraction=new Fraction(numerator,denominator);
       if(numerator!=0)
       {
           int temp=numerator;
           numerator=denominator;
           denominator=temp;
           fraction=new Fraction(numerator,denominator);
       }
       return  fraction;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction fraction= new Fraction(numerator*f.getDenominator(),denominator*f.getNumerator());
        fraction.shorten();
        return fraction;
    }
    
}",-
Mansfeld,Maurice,maurice.mansfeld@campus.tu-berlin.de,Beendet,"13. Juni 2021  19:18","20. Juni 2021  11:18","6 Tage 15 Stunden","18,98","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Getter und Setter","void
; private","class Rechteck {
    private int breite;

    public void setBreite(int breite) {
        this.breite = breite;
    }

    public int getBreite() {
        return this.breite;
    }
}


public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator;  //zähler
    private int denominator;  //nenner

    /*
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */

    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }       

    /*
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }       

    /** Beginn der Aufgabe

     Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     uebergeben bekommt und die entsprechenden Attribute setzt.

     Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     auftreten (nicht im ""denominator""-Attribut).

     Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     und der Wert des Bruchs (die Argumente) unverändert bleibt
     (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).         */  // heißt ich muss dann die Vorzeichen tauschen 

    /**
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * <p>
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */

    //konstruktor:
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;

        if (this.denominator == 0) {                      // null fall abgefangen
            this.denominator = 1;
        }

        if (this.denominator < 0) {                       //negatives Vorzeichen geändert  
            this.denominator = -this.denominator;
            this.numerator = -this.numerator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */

    public int getDenominator() {     
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */

    public int getNumerator() {      
        return this.numerator;
    }


    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */


    public double toDouble() {      
        return (double) this.numerator / (double) this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */

    public String toString() {      
        return this.numerator + ""/"" + this.denominator;
    }


    /**
     * Kuerzt (vereinfacht) den Bruch.
     */

    public void shorten() {
        int faktor = GCD(this.numerator, this.denominator);         //was muss ich hier übergeben? evtl. ""this.""??
        this.numerator = this.numerator / faktor;
        this.denominator = this.denominator / faktor;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */

    public Fraction add(Fraction f) {                   //fertig

        if (f.denominator < 0) {                       //negatives Vorzeichen geändert
            f.denominator = -f.getDenominator();
            f.numerator = -f.getNumerator();
        }

        numerator = this.numerator * f.getDenominator() + this.denominator * f.getNumerator();
        denominator = this.denominator * f.getDenominator();
        shorten();
        return new Fraction(numerator, denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */

    public Fraction multiply(Fraction f) {      //fertig
        numerator = this.numerator * f.getNumerator();
        denominator = this.denominator * f.getDenominator();
        shorten();
        return new Fraction(numerator, denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */

    public Fraction reciprocal() { //fertig
        if (this.numerator != 0) {
            int n1 = 0, d1 = 0;
            n1 = this.numerator;
            d1 = this.denominator;
            numerator = d1;
            denominator = n1;
        }
        shorten();
        return new Fraction(numerator, denominator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */

    public Fraction divide(Fraction f) {
        Fraction b = new Fraction(this.numerator, this.denominator);
        if (f.getNumerator() != 0) {
            b = multiply((f.reciprocal())); 
        }
        shorten();
        return b;
    }

}","public class SubwayTest {

    public static void main(String[] args) {

        // Erzeugen Sie eine U-Bahn mit maximal 3 Wagen.

        Subway zug3 = new Subway(3);

        // erstellen von vier Wagen

        Wagen w1 = new Wagen(13, 17);
        Wagen w2 = new Wagen(5, 7);
        Wagen w3 = new Wagen(2, 2);
        Wagen w4 = new Wagen(6, 8);

        // Hängen Sie 2 Wagen mit unterschiedlicher Anzahl an Sitz- und Stehplätzen an die U-Bahn.

        zug3.addWagen(w1);
        zug3.addWagen(w2);

        //Geben Sie die Gesamtzahl der Sitzplätze, Stehplätze und aller Plätze aus.

        // Sitzplätze
        zug3.getSeats();
        //Stehplätze
        zug3.getStandingRoom();
        //gesamtanzahlPlätze
        zug3.getCapacity();

        //Hängen Sie 2 weitere Wagen an die U-Bahn.

        zug3.addWagen(w3);
        zug3.addWagen(w4);              //sollte eine Fehlermeldung ausgeben


        //Entfernen Sie 5 Wagen aus der U-Bahn.

        zug3.removeWagen();        //sollte zwei Fehlermeldungen ausgeben
        zug3.removeWagen();
        zug3.removeWagen();
        zug3.removeWagen();
        zug3.removeWagen();
        
    }
}"
Wontorra,Lara,lara.wontorra@campus.tu-berlin.de,Beendet,"13. Juni 2021  19:59","18. Juni 2021  11:51","4 Tage 15 Stunden","10,34","class Rechteck {
	private int breite;

	public void setBreite(int breite) {
	}
	
	public int getBreite() {
		return this.breite;
	}
}

public class RechteckTest
{
	public static void main(String[] args) {
		
		Rechteck r = new Rechteck();
		r.setBreite(5);
		System.out.println(""""+ r.getBreite());
	}
}",class,"Setter-Methoden haben in der Regel den Rückgabetyp void","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten","Zugriff auf private Attribute ermöglichen","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class Fraction{

    private int numerator, denominator;


     public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }


    public static int LCM(int x, int y) {       
        return (x * y) / GCD(x, y);
    }
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator*((denominator==0)?1:Integer.signum(denominator));
        this.denominator = (denominator==0)?1:Math.abs(denominator);
        shorten();
    }
    public int getDenominator() {
        return denominator;
    }
        public int getNumerator() {
    return numerator;
    }
    public double toDouble() {
        return ((double) numerator) / ((double) denominator);
    }
    public String toString() {
        return numerator + ""/"" + denominator;   
    }
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= Math.abs(gcd);
        denominator /= Math.abs(gcd);
    }
    public Fraction add(Fraction f) {
        int newDenominator = LCM(denominator, f.getDenominator());
        int factor1 = (newDenominator / denominator);
        int factor2 = (newDenominator / f.getDenominator());
        return new Fraction(numerator*factor1 + f.getNumerator()*factor2, newDenominator);
    }
    public Fraction multiply(Fraction f) {
    return new Fraction(numerator*f.getNumerator(), denominator*f.getDenominator());
    }
    public Fraction reciprocal() {
        if(numerator == 0) return new Fraction(numerator, denominator);
        return new Fraction(denominator, numerator);
    }
    public Fraction divide(Fraction f) {
        return multiply(f.reciprocal());
    }
}",-
Voßbeck,"Marike Antonia Karoline",m.vossbeck@tu-berlin.de,Beendet,"13. Juni 2021  21:45","20. Juni 2021  14:38","6 Tage 16 Stunden","19,14","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","void
; private
; static","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class Fraction{
	
	
	    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
public Fraction(int numerator, int denominator) {
        this.numerator = numerator*((denominator==0)?1:Integer.signum(denominator));
        this.denominator = (denominator==0)?1:Math.abs(denominator);
        shorten();
    }
    public int getDenominator() {
        return denominator;
    }
    public int getNumerator() {
        return numerator;
    }
    public double toDouble() {
        return ((double) numerator) / ((double) denominator);
    }
    public String toString() {
        return numerator + ""/"" + denominator;
    }
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= Math.abs(gcd);
        denominator /= Math.abs(gcd);
    }
    public Fraction add(Fraction f) {
        int newDenominator = LCM(denominator, f.getDenominator());
        int factor1 = (newDenominator / denominator);
        int factor2 = (newDenominator / f.getDenominator());
        return new Fraction(numerator*factor1 + f.getNumerator()*factor2, newDenominator);
    }
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.getNumerator(), denominator*f.getDenominator());
    }
    public Fraction reciprocal() {
        if(numerator == 0) return new Fraction(numerator, denominator);
        return new Fraction(denominator, numerator);
    }
    public Fraction divide(Fraction f) {
        return multiply(f.reciprocal());
    }
}","public class SubwayTest{
 public static void main(String[] args){

  Subway u9 = new Subway(3);
 
  Wagen w1 = new Wagen(25,30);
  u9.addWagen(w1);
  Wagen w2 = new Wagen(55,45);
  u9.addWagen(w2);

  System.out.println(""Die U9 hat:""+u9.getSeats()+"" Sitzplaetze"");
  System.out.println(""Die U9 hat:""+u9.getStandingRoom()+"" Stehplaetze"");
  System.out.println(""Die U9 hat:""+u9.getCapacity()+"" Plaetze insgesamt"");
  
  Wagen w5 = new Wagen(20,35);
  u9.addWagen(w5);
  Wagen w6 = new Wagen(12, 33);
  u9.addWagen(w6);

  for(int i=0;i<5;i++){
   u9.removeWagen();
  }
 }
}"
Doan,Anh-Minh,a.doan@campus.tu-berlin.de,Beendet,"13. Juni 2021  22:46","20. Juni 2021  23:59","7 Tage 1 Stunde","15,02","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","class Rechteck { 
    private int breite;
    
    void setBreite(int breite) {
        this.breite = breite;
    }
    
    int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Zugriff auf private Attribute ermöglichen","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","void
; static","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe

    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
            denominator = 1;
        } else if (denominator < 0) {
            numerator = numerator * (-1);
        }
        this.denominator = Math.abs(denominator);
        this.numerator = numerator;
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) getNumerator() / (double) getDenominator();
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return getNumerator() + ""/"" + getDenominator();
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(denominator, numerator);
        numerator /= gcd;
        denominator /= gcd;
        if (denominator < 0) {
            numerator = numerator * (-1);
            denominator = Math.abs(denominator);
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int old = f.denominator;
        Fraction fr = new Fraction(f.numerator * (f.denominator / old), LCM(this.denominator, f.getDenominator()));
        fr.numerator += this.numerator * (f.denominator / this.denominator);
        return fr;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction fr = new Fraction(f.numerator * this.numerator, f.denominator * this.denominator);
        return fr;
    }


    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction fr = new Fraction(this.numerator, this.denominator);
        if (fr.numerator != 0) {
            int zaehler = this.numerator;
            fr.numerator = this.denominator;
            fr.denominator = zaehler;
        }
        return fr;
    }


    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction kehrwert = new Fraction(f.numerator, f.denominator);
        kehrwert = kehrwert.reciprocal();
        Fraction fr = new Fraction(this.numerator, this.denominator);
        return fr.multiply(kehrwert);
    }
}","public class SubwayTest {
    public static void main(String[] args) {
        Subway ubahn = new Subway(3);
        ubahn.addWagen(new Wagen(2, 3));
        ubahn.addWagen(new Wagen(4, 7));
        System.out.println(ubahn.getSeats() + "" "" + ubahn.getStandingRoom() + "" "" + ubahn.getCapacity());
        ubahn.addWagen(new Wagen(20, 31));
        ubahn.addWagen(new Wagen(14, 6));
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
    }
}"
Mondry,Leonard,leonard.mondry@campus.tu-berlin.de,Beendet,"13. Juni 2021  23:11","14. Juni 2021  11:17","12 Stunden 6 Minuten","19,32","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","private
; void
; static","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: Adresse 50; Teil 40: Adresse 51; Teil 41: Adresse 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: Adresse 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: Adresse 50; Teil 89: Adresse 51; Teil 90: Adresse 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: Adresse 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		if(denominator == 0) {
			this.denominator = 1;
		} else if(denominator < 0) {
			this.numerator *= (-1);
			this.denominator = (-1) * denominator;
		} else {
			this.denominator = denominator;
		}
		this.shorten();
    }

    public int getDenominator() {
        return this.denominator;
    }

    public int getNumerator() {
        return this.numerator;
    }

    public double toDouble() {
        return (double)((double)this.numerator / (double)this.denominator);
    }

    public String toString() {
        return new String(numerator+""/""+denominator);
    }

    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		this.numerator /= Math.abs(gcd);
		this.denominator /= Math.abs(gcd);
    }

    public Fraction add(Fraction f) {
		int denominatorF = f.getDenominator();
		int lcm = LCM(this.denominator, denominatorF);
		int newNumerator = this.numerator * (lcm / this.denominator) + f.getNumerator() * (lcm / denominatorF);
		return new Fraction(newNumerator, lcm);
    }

    public Fraction multiply(Fraction f) {
        return new Fraction((this.numerator * f.getNumerator()), (this.denominator * f.getDenominator()));
    }

    public Fraction reciprocal() {
       if (this.numerator == 0) {
		   return new Fraction(this.numerator, this.denominator);
	   } else {
		   return new Fraction(this.denominator, this.numerator);
	   }
    }
    
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }
}","public class SubwayTest {
	
	public static void main(String[] args) {
		Subway u7 = new Subway(3);
		
		Wagen wagen1 = new Wagen(4, 4);
		Wagen wagen2 = new Wagen(1, 6);
		
		u7.addWagen(wagen1);
		u7.addWagen(wagen2);
		
		System.out.println(u7.getSeats());
		System.out.println(u7.getStandingRoom());
		System.out.println(u7.getCapacity());
		
		Wagen wagen3 = new Wagen(3, 3);
		Wagen wagen4 = new Wagen(0, 10000);
		
		u7.addWagen(wagen3);
		u7.addWagen(wagen4);
		
		u7.removeWagen();
		u7.removeWagen();
		u7.removeWagen();
		u7.removeWagen();
		u7.removeWagen();
	}
}"
Ochmann,"Luis Eddie",luis.ochmann@campus.tu-berlin.de,Beendet,"14. Juni 2021  09:46","20. Juni 2021  16:10","6 Tage 6 Stunden","11,82","Getter und Setter","private
; void
; static","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator<0){ //hier für Eingaben kleiner als Eins
            denominator=-denominator;
            numerator=-numerator;
        } else if (denominator==0) { //hier für Eingaben gleich Null
            denominator= 1;
        }
        this.numerator=numerator;
        this.denominator=denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        shorten();
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        shorten();
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
       double numerator= getNumerator();
       double denominator = getDenominator();
       double gleitkommazahl=numerator/denominator;
       return gleitkommazahl;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String zn= numerator +""/""+ denominator;
        return zn;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int GCD = GCD(numerator, denominator);//als ganzzahlige Variable festlegen
        numerator=numerator/GCD;
        denominator=denominator/GCD;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int LCM=LCM(denominator, f.getDenominator());
        int zm=f.getDenominator();
        int zb=f.getNumerator();
        int zc=numerator;
        int zx=denominator;
        int solution=LCM*numerator/denominator+LCM*f.getNumerator()/f.getDenominator();
        Fraction fraction = new Fraction(solution,LCM);
        fraction.shorten();
        return fraction;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int zm=f.getDenominator();
        int zb=f.getNumerator();
        int zc=numerator;
        int zx=denominator;
        int za=zm*zx;
        int zs=zb*zc;
        Fraction fraction = new Fraction(zs, za);
        fraction.shorten();
        return fraction;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        int zc = numerator;
        int zx = denominator;
        if (numerator != 0) { //!= bedeutet ungleich
            zc = denominator;
            zx = numerator;
        }
        Fraction fraction = new Fraction(zc, zx);
        return fraction;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f=f.reciprocal();
        Fraction fraction=multiply(f);
        fraction.shorten();
        return fraction;
    }
}",-
Dewitz,"Klemens Julian",k.dewitz@campus.tu-berlin.de,Beendet,"14. Juni 2021  10:16","18. Juni 2021  12:04","4 Tage 1 Stunde","11,75","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","static
; private
; void","Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendiger parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator<0) {
			denominator=-denominator;
			numerator=-numerator;
		}
		else if (denominator==0) {
			denominator++;
		}
		this.numerator=numerator;
		this.denominator=denominator;
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		shorten();
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		shorten();
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double denom=denominator;
		double numer=numerator;
		double gleitk=numer/denom;
		return gleitk;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch=numerator+""/""+denominator;
		return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a=GCD(numerator, denominator);
		denominator=denominator/a;
		numerator=numerator/a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int d=denominator;
		int n=numerator;
		int hauptnenner=LCM(f.getDenominator(), denominator);
		n=(n*hauptnenner/d)+(f.getNumerator()*hauptnenner/f.getDenominator());
		d=hauptnenner;
		Fraction bruch=new Fraction(n,d);
		bruch.shorten();
		return bruch;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int n=numerator;
		int d=denominator;
        n=n*f.getNumerator();
		d=d*f.getDenominator();
		Fraction bruch=new Fraction(n,d);
		bruch.shorten();
		return bruch;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		int d=denominator;
		int n=numerator;
	   if(numerator!=0) {
		 d=numerator;
		 n=denominator;
	   }
	    Fraction bruch=new Fraction(n,d);
		return bruch;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f=f.reciprocal();
	   Fraction bruch=multiply(f);
	   bruch.shorten();
	   return bruch;
    }
    
}",-
Aymergen,Berke,berke.aymergen@campus.tu-berlin.de,Beendet,"14. Juni 2021  14:00","14. Juni 2021  16:43","2 Stunden 43 Minuten","14,35","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Getter und Setter",void,"Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = Fraction.GCD(this.numerator,this.denominator);
        this.numerator /= gcd;
        this.denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = Fraction.LCM(f.getDenominator(),this.denominator);
       int num1 = this.numerator * (lcm / this.denominator);
       int num2 = f.getNumerator() * (lcm / f.getDenominator());
       int num = num1 + num2;
       Fraction fra = new Fraction(num,lcm);
       return fra;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int num = f.getNumerator() * this.numerator;
        int den = f.getDenominator() * this.denominator;
        Fraction fra = new Fraction(num,den);
        return fra;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator != 0){
           int num = this.denominator;
           int den = this.numerator;
           Fraction fra = new Fraction(num,den);
           return fra;
       }
       else {
           Fraction fra = new Fraction(this.numerator,this.denominator);
           return fra;
       }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction fkehr = f.reciprocal();
       Fraction fra = this.multiply(fkehr);
       return fra;
    }
}","public class SubwayTest {
    public static void main(String[] args){
        Subway s = new Subway(3);
        Wagen w1 = new Wagen(5,10);
        Wagen w2 = new Wagen(8,15);
        s.addWagen(w1);
        s.addWagen(w2);
        System.out.println(""Sitzplaetze: "" + s.getSeats());
        System.out.println(""Stehplaetze: "" + s.getStandingRoom());
        System.out.println(""Gesamteplaetze: "" + s.getCapacity());
        Wagen w3 = new Wagen(2,5);
        Wagen w4 = new Wagen(20,26);
        s.addWagen(w3);
        s.addWagen(w4);
        for(int i = 0; i < 5; i++){
            s.removeWagen();
        }
    }
}"
Kinschus,Oskar,o.kinschus@campus.tu-berlin.de,Beendet,"14. Juni 2021  16:45","20. Juni 2021  22:55","6 Tage 6 Stunden","10,87","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","Setter-Methoden haben in der Regel den Rückgabetyp void","private
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }


 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
      if(denominator==0){
        denominator=1;
      }
      if(denominator<0){
        numerator=numerator*-1;
        denominator=denominator*-1;
      }

this.numerator=numerator;
this.denominator=denominator;
shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
    return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
    return numerator;
    }

   
    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(){
      double numerator = this.numerator;
         double denominator = this.denominator;
    double result = numerator/denominator;

    return result;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
    String n= String.valueOf(numerator);
    String d= String.valueOf(denominator);
    return(n+""/""+d);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    int ggt = GCD(this.numerator, this.denominator);
    this.numerator=this.numerator/ggt;
    this.denominator=this.denominator/ggt;



    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    int kgv = LCM(denominator,f.denominator);
    int multi1 = kgv/denominator;
    numerator = multi1*numerator;
    int multi2 = kgv/f.denominator;
    f.numerator = multi2*f.numerator;
    int neunumerator = numerator+f.numerator;
    Fraction addierd = new Fraction(neunumerator, kgv);
    return addierd;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    int mulnumerator = this.numerator*f.numerator;
     int muldenominator = this.denominator*f.denominator;
    Fraction multipliziert = new Fraction(mulnumerator, muldenominator);
    multipliziert.shorten();

    return multipliziert;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    if(numerator==0){
      Fraction same = new Fraction(numerator, denominator);
      return same;
    }else{
      Fraction kehrwert = new Fraction(denominator, numerator);
      return kehrwert;

    }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
     public Fraction divide(Fraction f) {
       Fraction kehrwert = new Fraction(0,0);
       Fraction dividet = new Fraction(0,0);
     kehrwert = f.reciprocal();
     dividet = multiply(kehrwert);
     return dividet;
    }
}","public class SubwayTest{
	
	public static void main(String[] args){
		 int a;
		 Subway g = new Subway(); 
		 g.addWagen(3,5);
		 g.addWagen(3,5);
		 int b = Subway.getSeats();
		 int c = Subways.getStandingRoom();
		 g.getCapacity(b,c);
		 g.addWagen(1,1);
		 g.addWagen(1,1);
		 g.removeWagen();	
	}	
}"
Hankewitz,David,david.hankewitz@campus.tu-berlin.de,Beendet,"14. Juni 2021  18:03","20. Juni 2021  23:22","6 Tage 5 Stunden","18,52","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Getter und Setter","void
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","public class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 50; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: 0; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0){
            denominator *= -1;
            numerator *= -1;
        }
        if (denominator == 0){
            denominator = 1;
        }
        setNumerator(numerator);
        setDenominator(denominator);
        shorten();
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        for(int i = 2; i < getNumerator()+getDenominator(); i++){
            if(numerator%i == 0 && denominator%i == 0){
                setNumerator(getNumerator()/i);
                setDenominator(getDenominator()/i);
                i = 2;
            }
        }
    }

    public void setNumerator(int num) {
        this.numerator = num;
    }

    public void setDenominator(int den) {
        this.denominator = den;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double)getNumerator()/(double)getDenominator());
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String format = String.valueOf(getNumerator()) + ""/"" + String.valueOf(getDenominator());
        return format;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int kgv = LCM(getDenominator(), f.denominator);
        int nom = getNumerator()*(kgv/getDenominator())+f.numerator*(kgv/f.denominator);
        Fraction addFrac = new Fraction(nom, kgv);
        return addFrac;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int den = getDenominator()*f.denominator;
        int nom = getNumerator()*f.numerator;
        Fraction mul = new Fraction(nom, den);
        return mul;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction rec = new Fraction(getNumerator(), getDenominator());
        if (getNumerator() != 0){
            int num = getNumerator();
            int den = getDenominator();
            rec.numerator = den;
            rec.denominator = num;
            return rec;
        }
        return rec;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction recp = f.reciprocal();
        Fraction mult = multiply(recp);
        Fraction f1 = new Fraction(mult.numerator, mult.denominator);
        return f1;
    }
    
}","public class SubwayTest {
    public static void main(String[] args) {
        //Erzeugen einer U-Bahn mit maximal 3 Wagen
        Subway sub = new Subway(3);

        //Anhaengen von 2 Wagen mit unterschiedlicher Anzahl von Steh- und Sitzplätzen
        Wagen wagen1 = new Wagen(50,100);
        Wagen wagen2 = new Wagen(100, 150);
        sub.addWagen(wagen1);
        sub.addWagen(wagen2);

        //Gesamtzahl aller Sitz- und Stehplätze
        System.out.println(wagen1.getCapacity() + wagen2.getCapacity());

        //Anhängen von 2 weiteren Waegen an die U-Bahn
        Wagen wagen3 = new Wagen(50,100);
        Wagen wagen4 = new Wagen(100, 150);
        sub.addWagen(wagen3);
        sub.addWagen(wagen4);

        //Entfernen von 5 Wagen aus der U-Bahn
        sub.removeWagen();
        sub.removeWagen();
        sub.removeWagen();
        sub.removeWagen();
        sub.removeWagen();
    }
    
}"
Ataev,Batyr,ataev@campus.tu-berlin.de,Beendet,"14. Juni 2021  20:12","16. Juni 2021  12:34","1 Tag 16 Stunden","18,87","Getter und Setter","void
; private","class Rechteck { 
    private int breite;
    
    void setBreite(int breite) {
        this.breite = breite;
    }
    
    int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 0; Teil 89: 0; Teil 90: 1; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 1; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: 0; Teil 100: 0; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: 0; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    	if(denominator < 0) {
    		denominator *= -1;
    		numerator *= -1;
    	}
    	
    	else if(denominator == 0) {
    		denominator = 1;
    	}
    	
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
    	return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / (double) this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
       int gcd = GCD(this.numerator, this.denominator);
       this.numerator /= gcd;
       this.denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    	Fraction fNew = new Fraction(this.numerator, this.denominator);
    	fNew.numerator = fNew.numerator * f.denominator + f.numerator * fNew.denominator;
    	fNew.denominator = fNew.denominator * f.denominator;
       fNew.shorten();
       return fNew;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    	Fraction fNew = new Fraction(this.numerator, this.denominator);
        fNew.numerator = f.numerator * fNew.numerator;
        fNew.denominator = f.denominator * fNew.denominator;
        fNew.shorten();
        return fNew;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	Fraction f = new Fraction(this.numerator, this.denominator);
       if(f.numerator != 0) {
    	   int newN = f.denominator;
    	   int newD = f.numerator;
    	   f.numerator = newN;
    	   f.denominator = newD;
    	   f.shorten();
       }
       return f;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction f1 = new Fraction(this.numerator, this.denominator);
       f1 = f1.multiply(f.reciprocal());
       f1.shorten();
       return f1;
    }
    
}","public class SubwayTest {

	public static void main(String[] args) {
		Subway u7 = new Subway(3);
		
		Wagen w1 = new Wagen(20,40);
		Wagen w2 = new Wagen(15,50);
		
		u7.addWagen(w1);
		u7.addWagen(w2);
		
		System.out.println(""Sitzplätze: "" + u7.getSeats() 
		+ "", Stehplätze: "" + u7.getStandingRoom() + "", Gesamtplätze: "" + u7.getCapacity());
		
		Wagen w3 = new Wagen(31,12);
		Wagen w4 = new Wagen(10,30);
		
		for(int i=0; i<5; i++) {
			u7.removeWagen();
		}
	}
}"
Tanka,Kostantin,kostandin.tanka@campus.tu-berlin.de,Beendet,"16. Juni 2021  00:01","20. Juni 2021  23:59","4 Tage 23 Stunden","13,86","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}",static,"Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden modellieren das Verhalten von Objekten","abstrakte Methoden","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: ; Teil 8: -; Teil 9: -; Teil 10: -; Teil 11: -; Teil 12: -; Teil 13: -; Teil 14: ; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: ; Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: ; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: ; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: ; Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: ; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: ; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: ; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: ; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: ; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: ; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: ; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: ; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: ; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: ; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: ; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: ; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {


	if(denominator < 0){
		        
	this.numerator = -numerator;
	this.denominator = -denominator;
	}else if(denominator == 0){
	    this.denominator = 1;
	    this.numerator = numerator;
	}else{
	        
	this.numerator = numerator;
	this.denominator = denominator;
	}

	this.shorten();


    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
	double num = numerator;	
	double den = denominator;
     	return num/den;  
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator,denominator);

	numerator = numerator/gcd;
	denominator = denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(denominator,f.getDenominator());
	numerator = numerator * (lcm/denominator);
	denominator = lcm;
	numerator += f.getNumerator() * (lcm/f.getDenominator());
	return this;
	
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        numerator *= f.getNumerator();
	denominator *= f.getDenominator();
	return this;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(numerator != 0){
		return new Fraction(denominator,numerator);
	}
	return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());  
    }
    
}","public class SubwayTest{
	
	public static void main(String[] args){
		
		Subway eins = new Subway(3);
		
		eins.addWagen(new Wagen(25, 27));
		eins.addWagen(new Wagen(21, 29));
		
		System.out.println(""Alle Sitzplätze: ""+eins.getSeats());
		System.out.println(""Alle Stehplätze: ""+eins.getStandingRoom());
		System.out.println(""Alle Plätze: ""+eins.getCapacity());
		
		eins.addWagen(new Wagen(3, 16));
		eins.addWagen(new Wagen(78, 10));
		
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
	}
}"
Asad,Hamza,hamza.asad@campus.tu-berlin.de,Beendet,"16. Juni 2021  00:01","20. Juni 2021  23:59","4 Tage 23 Stunden","11,33",static,"Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Getter und Setter","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest {
    public static void main (String[] args) {
        Subway ubahn = new Subway(3);
        Wagen ubahn1 = new Wagen(2, 3);
        Wagen ubahn2 = new Wagen(5, 6);
        ubahn.addWagen(ubahn1);
        ubahn.addWagen(ubahn2);
        System.out.println(ubahn.getSeats());
        System.out.println(ubahn.getStandingRoom());
        System.out.println(ubahn.getCapacity());
        Wagen ubahn3 = new Wagen(3, 6);
        Wagen ubahn4 = new Wagen(7, 9);
        ubahn.addWagen(ubahn3);
        ubahn.addWagen(ubahn4);
        
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
        
    }
}"
Weimer,David,d.weimer@campus.tu-berlin.de,Beendet,"16. Juni 2021  00:04","20. Juni 2021  23:59","4 Tage 23 Stunden","6,15","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","class
; void
; private
; static","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Setter-Methoden haben in der Regel den Rückgabetyp void","Teil 1: undef; Teil 2: undef; Teil 3: undef; Teil 4: undef; Teil 5: undef; Teil 6: undef; Teil 7: 3(11); Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: -; Teil 12: -; Teil 13: -; Teil 14: 4(11); Teil 15: %; Teil 16: %; Teil 17: 0; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 5(11); Teil 22: %; Teil 23: 0; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 6(11); Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(12); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 4(12); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(12); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(12); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 3(13); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 4(13); Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 5(13); Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 6(13); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 13; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 14; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 15; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 16; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }
	
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
    }

    public int getDenominator() {
		if(denominator == 0){
			denominator = 1;
		}
        return this.denominator;
    }

    public int getNumerator() {
        return this.numerator;
    }

    public double toDouble() {
        double x = (double) numerator / denominator;
		return x;
    }

    public String toString() {
      String hy = (numerator + ""/"" + denominator);
	  return hy;
		
    }

    public void shorten() {
       
	    int n = numerator;
		int	d = denominator; 
		int largest;
      if (numerator < 0) {
         n = -numerator;
      }
      if (n > d) {
         largest = n;
      } else {
         largest = d;
      }
     int gcd = 0;
      for (int i = largest; i >= 2; i--) {
         if (numerator % i == 0 && denominator % i == 0) {
            gcd = i;
            break;
         }
      }
      if (gcd != 0) {
         int m = numerator / gcd;
         int h = denominator / gcd;
		 numerator = m;
		 denominator = h;
		}
	}
    public Fraction add(Fraction f) {
		int den1 = denominator;
		int den2 = f.getDenominator();
		int num2 = f.getNumerator();
		int num1 = numerator;
		int xe;
		int numm;
		int den;
		if(den1 == den2)
		{
			numm = num1 + num2 ;
			den = den1 ;
		}
		else{
			numm = (num1*den2) + (num2*den1);
			den = den1 * den2;
		}
		if(numm > den)
			xe = numm;
		else
			xe = den;
		for(int i = 1 ; i <= xe ; i++)
		{
			if(numm%i == 0 && den%i == 0)
			{
				numm = numm/i;
				den = den/i;
			}
		}

		int n = 1;
		int p = numm;
		int q = den;
		if( numm != den)
		{
			while(n != 0)
			{

				n = numm % den;			
				if(n != 0)
				{
					numm = den;
					den = n;
				}
			}			
		}
		Fraction ad = new Fraction(numm, den);
		return ad;
    }

    public Fraction multiply(Fraction f) {
        int nume = f.getNumerator();
		int deno = f.getDenominator();
		int tr = numerator * nume;
		int hi = denominator * deno;
		Fraction mu = new Fraction(tr, hi);
		mu.shorten();
		return mu;
    }
	
    public Fraction reciprocal() {
       if (numerator != 0) {
		   int de1 = denominator;
		   int num = numerator;
		   Fraction rec = new Fraction(num, de1);
		   return rec;
	   }
	   else {
		Fraction nix = new Fraction(numerator, denominator);
			return nix;
	   }
    }
    
    public Fraction divide(Fraction f) {
		f.reciprocal();
       int numer = f.getNumerator();
	   int denom = f.getDenominator();
	   int jay = numerator * numer;
	   int htr = denominator * denom;
	   Fraction ker = new Fraction(jay, htr);
	   return ker;
    }
    
}",-
Hecker,Henry,h.hecker@campus.tu-berlin.de,Beendet,"16. Juni 2021  09:42","20. Juni 2021  14:47","4 Tage 5 Stunden","18,64","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","rekursive Methoden","void
; static
; private","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class Fraction{
    
    
        private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
public Fraction(int numerator, int denominator) {
        this.numerator = numerator*((denominator==0)?1:Integer.signum(denominator));
        this.denominator = (denominator==0)?1:Math.abs(denominator);
        shorten();
    }
    public int getDenominator() {
        return denominator;
    }
    public int getNumerator() {
        return numerator;
    }
    public double toDouble() {
        return ((double) numerator) / ((double) denominator);
    }
    public String toString() {
        return numerator + ""/"" + denominator;
    }
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= Math.abs(gcd);
        denominator /= Math.abs(gcd);
    }
    public Fraction add(Fraction f) {
        int newDenominator = LCM(denominator, f.getDenominator());
        int factor1 = (newDenominator / denominator);
        int factor2 = (newDenominator / f.getDenominator());
        return new Fraction(numerator*factor1 + f.getNumerator()*factor2, newDenominator);
    }
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.getNumerator(), denominator*f.getDenominator());
    }
    public Fraction reciprocal() {
        if(numerator == 0) return new Fraction(numerator, denominator);
        return new Fraction(denominator, numerator);
    }
    public Fraction divide(Fraction f) {
        return multiply(f.reciprocal());
    }
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest{
 public static void main(String[] args){
  // erzeugen einer Ubahn
  Subway u7 = new Subway(3);
  
  // erzeugen und hinzufuegen von 3 Wagen an die Ubahn
  Wagen wagen1 = new Wagen(25,30);
  u7.addWagen(wagen1);
  

  Wagen wagen2 = new Wagen(55,45);
  u7.addWagen(wagen2);

  System.out.println(""Die U7 hat:""+u7.getSeats()+"" Sitzplaetze"");
  System.out.println(""Die U7 hat:""+u7.getStandingRoom()+"" Stehplaetze"");
  System.out.println(""Die U7 hat:""+u7.getCapacity()+"" Plaetze insgesamt"");
  Wagen wagen3 = new Wagen(20,35);
  u7.addWagen(wagen3);
  Wagen wagen4 = new Wagen(12, 33);
  u7.addWagen(wagen4);
  // entfernen aller Wagen und loeschen eines weiteren um zu ueberpruefen
  // ob nicht mehr entfernt werden koennen als vorhanden sind.
  for(int i=0;i<5;i++){
   u7.removeWagen();
  }
 }
}"
Großgoerge,Corvin,corvin.grossgoerge@campus.tu-berlin.de,Beendet,"16. Juni 2021  11:10","20. Juni 2021  23:59","4 Tage 12 Stunden","17,61","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel den Rückgabetyp void","Getter und Setter",-,"class
; static
; void","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden
; Verhindern, dass Attributswerte gesetzt werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
            this.denominator = 1;
            this.numerator = numerator;
        } else if (denominator < 0) {
            this.denominator = denominator * -1;
            this.numerator = numerator * -1;
        } else {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) this.numerator) / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
		if (denominator < 0){
			int a = -1;
			numerator /= gcd*a;
			denominator /= gcd*a;
		}
		else {
		numerator /= gcd;
		denominator /= gcd;
		}
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       this.numerator = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
		this.denominator = denominator * f.getDenominator();
		return new Fraction(this.numerator, this.denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = numerator * f.numerator;
		int newDenominator = denominator * f.denominator;
		Fraction result = new Fraction(newNumerator, newDenominator);
		return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (getNumerator () != 0) {
		   return new Fraction (denominator,numerator);
		}
		return new Fraction (numerator,denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f = f.reciprocal();
		return this.multiply(f);
    }
    
}","public class SubwayTest {
	public static void main(String[] args){
		Subway u9 = new Subway(3);
		
		u9.addWagen(new Wagen(33,46));
		u9.addWagen(new Wagen(25,39));
		
		System.out.println(u9.getSeats()+"" Sitzplätze\n""+u9.getStandingRoom()+"" Stehplätze\n""+u9.getCapacity()+"" Plätze insgesamt"");
		
		u9.addWagen(new Wagen(10,69));
		u9.addWagen(new Wagen(20, 34));
		
		for(int i=0;i<5;i++) u9.removeWagen();
		
		
	}
}"
Gorny,Leonid,l.gorny@campus.tu-berlin.de,Beendet,"16. Juni 2021  11:27","20. Juni 2021  23:59","4 Tage 12 Stunden","9,53","class
; static
; void
; private","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: -; Teil 10: -; Teil 11: -; Teil 12: -; Teil 13: -; Teil 14: 12; Teil 15: -; Teil 16: 0; Teil 17: -; Teil 18: -; Teil 19: -; Teil 20: -; Teil 21: 13; Teil 22: ; Teil 23: ; Teil 24: 1; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: 14; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }


 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
      if(denominator==0){
        denominator=1;
      }
      if(denominator<0){
        numerator=numerator*-1;
        denominator=denominator*-1;
      }

this.numerator=numerator;
this.denominator=denominator;
shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
   return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
    return numerator;
    }

    public void setDenominator(){
    this.denominator=denominator;
    }

    public void setNumerator(){
      this.numerator=numerator;
    }
    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(){
      double numerator = this.numerator;
      double denominator = this.denominator;
    double result = numerator/denominator;

    return result;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
    String n= String.valueOf(numerator);
    String d= String.valueOf(denominator);
    return(n+""/""+d);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    int ggt = GCD(this.numerator, this.denominator);
    this.numerator=this.numerator/ggt;
    this.denominator=this.denominator/ggt;



    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    int kgv=LCM(denominator,f.denominator);
    int multi1=kgv/denominator;
    numerator=multi1*numerator;
    int multi2=kgv/f.denominator;
    f.numerator=multi2*f.numerator;
    int neunumerator=numerator+f.numerator;
    Fraction addiert = new Fraction(neunumerator, kgv);
    return addiert;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    int mulnumerator=this.numerator*f.numerator;
    int muldenominator=this.denominator*f.denominator;
    Fraction multipliziert = new Fraction(mulnumerator, muldenominator);
    multipliziert.shorten();

    return multipliziert;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    if(numerator==0){
      Fraction same = new Fraction(numerator, denominator);
      return same;
    }else{
      Fraction kehrwert = new Fraction(denominator, numerator);
      return kehrwert;

    }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
     public Fraction divide(Fraction f) {
       Fraction kehrwert = new Fraction(0,0);
       Fraction divided = new Fraction(0,0);
     kehrwert = f.reciprocal();
     divided = multiply(kehrwert);
     return divided;
}
}",-
Türk,Selin,selin.tuerk@campus.tu-berlin.de,Beendet,"16. Juni 2021  12:42","20. Juni 2021  23:59","4 Tage 11 Stunden","12,83","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator,denominator;

    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe


    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if (denominator < 0){
            this.numerator = numerator * -1;
            this.denominator = denominator * -1;
        } else {
            if (denominator == 0) {
                this.denominator = 1;
            } else {
                this.denominator = denominator;
            }
        }
        shorten();
    }

    public int getDenominator() {
        return this.denominator;
    }


    public int getNumerator() {
        return this.numerator;
    }


    public double toDouble() {
        double x = (double) this.numerator / (double) this.denominator;
        return x;
    }


    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }


   public void shorten() {
        int b = GCD(numerator, denominator);
        numerator = numerator / b;
        denominator = denominator / b;

    }

    public Fraction add(Fraction f) {
        numerator = this.numerator * f.getDenominator() + f.getNumerator() * this.denominator;
        denominator = this.denominator * f.getDenominator();
        shorten();
        return new Fraction(numerator, denominator);
    }

    public Fraction multiply(Fraction f) {
        numerator = f.getNumerator() * this.numerator;
        denominator = f.getDenominator() * this.denominator;
        shorten();
        return new Fraction(numerator, denominator);
    }

   public Fraction reciprocal() {
        if (numerator != 0) {
            int n1 = numerator;
            int d1 = denominator;
            numerator = d1;
            denominator = n1;
        }
        shorten();
        return new Fraction(numerator, denominator);
    }

    public Fraction divide(Fraction f) {
        Fraction d = new Fraction(this.numerator, this.denominator);
        if (f.getNumerator() != 0) {
            d = multiply(f.reciprocal());
        }
        shorten();
        return d;
    }
}",-
Ranneberg,Thea,t.ranneberg@campus.tu-berlin.de,Beendet,"16. Juni 2021  13:31","20. Juni 2021  23:59","4 Tage 10 Stunden","19,83","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","void
; private","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator,denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe

    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */

    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if (denominator < 0) {
            this.numerator = numerator * -1;
            this.denominator = denominator * -1;
        } else {
            if (denominator == 0) {
                this.denominator = 1;
            } else {
                this.denominator = denominator;
            }
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     *
     * @return
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double bruch = (double) this.numerator / (double) this.denominator;
        return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */

    public void shorten() {
        int gcd = GCD(numerator, denominator);          //evtl. this statements
        numerator = numerator / gcd;
        denominator = denominator / gcd;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {

        numerator = this.numerator * f.getDenominator() + f.getNumerator() * this.denominator;
        denominator = this.denominator * f.getDenominator();
        shorten();
        return new Fraction(numerator, denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */

    public Fraction multiply(Fraction f) {
        numerator = f.getNumerator() * this.numerator;
        denominator = f.getDenominator() * this.denominator;

        shorten();
        return new Fraction(numerator, denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() { //übergabe soll unverändert bleiben
        if (numerator != 0) {
            int numerator1 = numerator;
            int denominator1 = denominator;
            numerator = denominator1;        //funktioniert so nicht du überschreibst
            denominator = numerator1;       // außerdem this. statements
        }

        shorten();
        return new Fraction(numerator, denominator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction zwischenspeicher = new Fraction(this.numerator, this.denominator);
        if (f.getNumerator() != 0) {
            zwischenspeicher = multiply(f.reciprocal());
        }
        shorten();
        return zwischenspeicher;
    }

}","public class SubwayTest {
    public static void main(String[] args) {
        Subway s3 = new Subway(3);//UBahn mit max 3 Wagen

        Wagen w1 = new Wagen (10,20);
        Wagen w2 = new Wagen (20,25);
        Wagen w3 = new Wagen (40,45);
        Wagen w4 = new Wagen (30,35);

        s3.addWagen(w1);
        s3.addWagen(w2);

        s3.getSeats();
        s3.getStandingRoom();
        s3.getCapacity();

        //System.out.println(""Sitzplätze: ""+s3.getSeats()+"" Stehplätze: ""+s3.getStandingRoom()+ "" Alle Plätze: ""+s3.getCapacity());

        s3.addWagen(w3);
        s3.addWagen(w4);

        s3.removeWagen();
        s3.removeWagen();
        s3.removeWagen();
        s3.removeWagen();
        s3.removeWagen();
    }
}"
Reinartz,"Karl Levin",reinartz@campus.tu-berlin.de,Beendet,"16. Juni 2021  14:01","20. Juni 2021  23:59","4 Tage 9 Stunden","12,13","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","private
; static
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest {
    
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: 0; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if(denominator < 0){
			this.denominator = denominator;
			this.numerator = numerator;
		}if(denominator == 0){
			this.denominator = 1;
			this.numerator = 1;
		}else(denominator > 0){
			this.denominator = denominator * -1;
			this.numerator = numerator * -1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double B = this.numerator / this.denominator;
		return B;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String Bruch = (this.numerator""/""this.denominator);
		return Bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        KGM = LCM(this.numerator ,this.denominator);
		this.numerator =  this.numerator / KGM;
		this.denominator = this.denominator / KGM;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		f.numerator *= this.denominator;
		this.numerator *= f.denominator;
		this.numerator += f.numerator;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator *= f.numerator;
		this.denominator *= f.denominator;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if(this.numerator != 0){
			int helfer = this.numerator;
			this.numerator = this.denominator;
			this.denominator = helfer;
		}
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f.reciprocal;
	    this.numerator *= f.numerator;
		this.denominator *= f.denominator;
    }
    
}","public class SubwayTest{
	
	public static void main(String[] args){
		
		Subway eins = new Subway(3);
		
		eins.addWagen(new Wagen(25, 27));
		eins.addWagen(new Wagen(21, 29));
		
		System.out.println(""Alle Sitzplätze: ""+eins.getSeats());
		System.out.println(""Alle Stehplätze: ""+eins.getStandingRoom());
		System.out.println(""Alle Plätze: ""+eins.getCapacity());
		
		eins.addWagen(new Wagen(3, 16));
		eins.addWagen(new Wagen(78, 10));
		
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
	}
}"
Bormann,Lisa,lisa.bormann@campus.tu-berlin.de,Beendet,"16. Juni 2021  14:04","20. Juni 2021  23:59","4 Tage 9 Stunden","17,88","private
; static
; void","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: 0; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {


	if(denominator < 0){
		        
	this.numerator = -numerator;
	this.denominator = -denominator;
	}else if(denominator == 0){
	    this.denominator = 1;
	    this.numerator = numerator;
	}else{
	        
	this.numerator = numerator;
	this.denominator = denominator;
	}

	this.shorten();


    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
	double num = numerator;	
	double den = denominator;
     	return num/den;  
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator,denominator);

	numerator = numerator/gcd;
	denominator = denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(denominator,f.getDenominator());
	numerator = numerator * (lcm/denominator);
	denominator = lcm;
	numerator += f.getNumerator() * (lcm/f.getDenominator());
	return this;
	
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        numerator *= f.getNumerator();
	denominator *= f.getDenominator();
	return this;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(numerator != 0){
		return new Fraction(denominator,numerator);
	}
	return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());  
    }
    
}","public class SubwayTest{
	
	public static void main(String[] args){
		
		Subway eins = new Subway(3);
		
		eins.addWagen(new Wagen(25, 27));
		eins.addWagen(new Wagen(21, 29));
		
		System.out.println(""Alle Sitzplätze: ""+eins.getSeats());
		System.out.println(""Alle Stehplätze: ""+eins.getStandingRoom());
		System.out.println(""Alle Plätze: ""+eins.getCapacity());
		
		eins.addWagen(new Wagen(3, 16));
		eins.addWagen(new Wagen(78, 10));
		
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
		eins.removeWagen();
	}
}"
Schnabel,Josefina,josefina.schnabel@campus.tu-berlin.de,Beendet,"16. Juni 2021  14:11","20. Juni 2021  10:47","3 Tage 20 Stunden","19,09",void,"Getter und Setter","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: %; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: 0; Teil 30: 0; Teil 31: 1; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 0; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 0; Teil 89: 0; Teil 90: 1; Teil 91: 4(17); Teil 92: 1; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;         // Zähler, Nenner

    public static int GCD(int x, int y) {       //ggT, rekursiv
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {       //kgV
        return (x * y) / GCD(x, y);
    }

//Beginn der Aufgabe
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;

        if(this.denominator==0) {
            this.denominator = 1;
        }
        this.shorten();
        if(this.denominator<0) {                     // Nenner -   und   Zähler und Nenner -
            this.numerator = - this.numerator;
            this.denominator = - this.denominator;
        }
    }


    public int getDenominator() {
        return this.denominator;
    }

    public int getNumerator() {
        return this.numerator;
    }

    public double toDouble() {
        return (double)this.numerator/this.denominator;
    }

    public String toString() {
        return Integer.toString(this.numerator) + ""/"" + Integer.toString(this.denominator);
    }

    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
        this.numerator /= gcd;
        this.denominator /= gcd;
    }

    public Fraction add(Fraction f) {
        Fraction retValue = new Fraction(this.numerator, this.denominator);

        if(this.denominator != f.denominator) {
            int lcm = LCM(this.denominator, f.denominator);
            retValue.numerator *= lcm/this.denominator;
            retValue.denominator *= lcm/this.denominator;
            f.numerator *= lcm/f.denominator;
            f.denominator *= lcm/f.denominator;
        }
        retValue.numerator += f.numerator;
        retValue.shorten();
        return retValue;
    }

    public Fraction multiply(Fraction f) {
        Fraction retValue = new Fraction(this.numerator, this.denominator);
        retValue.numerator *= f.numerator;
        retValue.denominator *= f.denominator;
        return retValue;
    }

    public Fraction reciprocal() {              // Kehrwert
        Fraction retValue = new Fraction(this.numerator, this.denominator);
        if(this.numerator != 0) {
            if(this.numerator<0) {                     // Nenner -   und   Zähler und Nenner -
                this.numerator = - this.numerator;
                this.denominator = - this.denominator;
            }
            retValue.numerator = this.denominator;
            retValue.denominator = this.numerator;
        }
        return retValue;
    }

    public Fraction divide(Fraction f) {            // how to:   c/d / a/b = c/d * b/a
        Fraction retValue = new Fraction(this.numerator, this.denominator);
        retValue = this.multiply(f.reciprocal());
        retValue.shorten();
        if(retValue.denominator<0) {                     // Nenner -   und   Zähler und Nenner -
            retValue.numerator = - retValue.numerator;
            retValue.denominator = - retValue.denominator;
        }
        return retValue;
    }

}","public class SubwayTest {

    public static void main(String[] args) {

        Subway testSub = new Subway(3);                 // U-Bahn mit maximal 3 Wagen

        Wagen w1 = new Wagen(5, 7);                     // 2 Wagen mit unterschiedlicher Sitz- und Stehplätzen an U-Bahn hängen
        Wagen w2 = new Wagen(8, 2);
        testSub.addWagen(w1);
        testSub.addWagen(w2);

        System.out.println(testSub.getSeats());         // Gesamtzahl der Sitz-, Steh- und aller Plätze ausgeben
        System.out.println(testSub.getStandingRoom());
        System.out.println(testSub.getCapacity());

        Wagen w3 = new Wagen(0, 14);                    // 2 weitere Wagen an U-Bahn hängen
        Wagen w4 = new Wagen(9, 1);
        testSub.addWagen(w3);
        testSub.addWagen(w4);

        for(int i = 0; i < 5; i++) {                    // 5 Wagen aus U-Bahn entfernen
            testSub.removeWagen();
        }

    }
}"
Fenner,Lisa-Marie,l.fenner@campus.tu-berlin.de,Beendet,"16. Juni 2021  14:30","20. Juni 2021  19:26","4 Tage 4 Stunden","12,40","class Rechteck { 
    int breite;
    
    void setBreite(int breite) {
        this.breite = breite;
    }
    
    int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0) {
        	denominator = -denominator;
        	numerator = -numerator;
        }
        if(denominator == 0) {
        	denominator = 1;
        }
        int b = GCD(numerator,denominator);
        numerator = numerator/b;
        denominator = denominator/b;
        this.numerator = numerator;
        this.denominator = denominator;
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a = GCD(numerator,denominator);
        numerator = numerator/a;
        denominator = denominator/a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
   public Fraction add(Fraction f) {
    	numerator = numerator*f.getDenominator()+f.getNumerator()*denominator;
    	denominator = denominator*f.getDenominator();
    	int g = GCD(numerator,denominator);
    	return new Fraction(numerator/g,denominator/g);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(f.numerator*numerator,f.denominator*denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(numerator!= 0) 
    return new Fraction(denominator,numerator);
       else return new Fraction (numerator,denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	Fraction c = multiply(f.reciprocal());
    	return new Fraction(c.numerator, c.denominator);
    } 
}",-
Mirrafati,"Nima Lucius",n.mirrafati@campus.tu-berlin.de,Beendet,"16. Juni 2021  16:03","20. Juni 2021  23:59","4 Tage 7 Stunden","11,49","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; static
; void","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: l; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: m; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: l; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest {
  public static void main(String[] args){
  Subway ubahn = new Subway(3);
  Wagen eins = new Wagen(30, 40);
  Wagen zwei = new Wagen(28, 42);
  Wagen drei = new Wagen(26, 44);
  Wagen vier = new Wagen(24, 46);
  ubahn.addWagen(eins);
  ubahn.addWagen(zwei);
  System.out.println(ubahn.getSeats());
  System.out.println(ubahn.getStandingRoom());
  System.out.println(ubahn.getCapacity());
  ubahn.addWagen(drei);
  ubahn.addWagen(vier);
  ubahn.removeWagen();
  ubahn.removeWagen();
  ubahn.removeWagen();
  ubahn.removeWagen();
  ubahn.removeWagen();
  }
}"
Maas,"Lukas Maximilian",lukas.maas@campus.tu-berlin.de,Beendet,"16. Juni 2021  16:32","20. Juni 2021  23:59","4 Tage 7 Stunden","11,63","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void
; static
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: 0; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest {
	
	public static void main (String[] args){
		Subway U_Bahn = new Subway(3);
		Wagen a = new Wagen(20, 40); 
		Wagen b = new Wagen(21, 41);
		U_Bahn.addWagen(a);
		U_Bahn.addWagen(b);
		System.out.println(U_Bahn.getSeats());
		System.out.println(U_Bahn.getStandingRoom());
		System.out.println(U_Bahn.getCapacity());
		Wagen c = new Wagen(22, 42);
		U_Bahn.addWagen(c);
		U_Bahn.addWagen(new Wagen(23, 43));
		U_Bahn.removeWagen();
		U_Bahn.removeWagen();
		U_Bahn.removeWagen();
		U_Bahn.removeWagen();
		U_Bahn.removeWagen();
	}
}"
Scholz,"Jonas Malte",jonas.scholz.1@campus.tu-berlin.de,Beendet,"16. Juni 2021  18:29","20. Juni 2021  23:59","4 Tage 5 Stunden","11,75","Setzen falscher Attributwerte verhindern","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","static
; private
; void","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator,denominator;

    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe


    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if (denominator < 0){
            this.numerator = numerator * -1;
            this.denominator = denominator * -1;
        } else {
            if (denominator == 0) {
                this.denominator = 1;
            } else {
                this.denominator = denominator;
            }
        }
        shorten();
    }

    public int getDenominator() {
        return this.denominator;
    }


    public int getNumerator() {
        return this.numerator;
    }


    public double toDouble() {
        double x = (double) this.numerator / (double) this.denominator;
        return x;
    }


    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }


   public void shorten() {
        int a = GCD(numerator, denominator);
        numerator = numerator / a;
        denominator = denominator / a;

    }

    public Fraction add(Fraction f) {
        numerator = this.numerator * f.getDenominator() + f.getNumerator() * this.denominator;
        denominator = this.denominator * f.getDenominator();
        shorten();
        return new Fraction(numerator, denominator);
    }

    public Fraction multiply(Fraction f) {
        numerator = f.getNumerator() * this.numerator;
        denominator = f.getDenominator() * this.denominator;
        shorten();
        return new Fraction(numerator, denominator);
    }

   public Fraction reciprocal() {
        if (numerator != 0) {
            int n1 = numerator;
            int d1 = denominator;
            numerator = d1;
            denominator = n1;
        }
        shorten();
        return new Fraction(numerator, denominator);
    }

    public Fraction divide(Fraction f) {
        Fraction s = new Fraction(this.numerator, this.denominator);
        if (f.getNumerator() != 0) {
            s = multiply(f.reciprocal());
        }
        shorten();
        return s;
    }
}","public class SubwayTest {
	
    public static void main(String[] args) {
        Subway s = new Subway(3);
        Wagen w1 = new Wagen (45,35);
        Wagen w2 = new Wagen (35,40);
        s.addWagen(w1);
        s.addWagen(w2);
        s.getSeats();
        s.getStandingRoom();
        s.getCapacity();
		System.out.println(s.countWagen()+"" Wagen \n"" +s.getSeats()+"" Seats \n"" +s.getStandingRoom()+ "" Standing Room \n"" +s.getCapacity()+ "" Capacity"");
        Wagen w3 = new Wagen (40,45);
        Wagen w4 = new Wagen (36,37);
		s.addWagen(w3);
        s.addWagen(w4);
		s.removeWagen();
		s.removeWagen();
		s.removeWagen();
		s.removeWagen();
		s.removeWagen();
	}
}"
Lee,"Woo Jin",lee.16@campus.tu-berlin.de,Beendet,"17. Juni 2021  00:21","20. Juni 2021  23:59","3 Tage 23 Stunden","11,61","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","private
; static
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden modellieren das Verhalten von Objekten","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: %; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: 0; Teil 30: 0; Teil 31: 1; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: %; Teil 73: 0; Teil 74: %; Teil 75: l; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: l; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: l; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 0; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest {
    public static void main (String[] args) {
        Subway ubahn = new Subway(3);
        Wagen ubahn1 = new Wagen(2, 3);
        Wagen ubahn2 = new Wagen(5, 6);
        ubahn.addWagen(ubahn1);
        ubahn.addWagen(ubahn2);
        System.out.println(ubahn.getSeats());
        System.out.println(ubahn.getStandingRoom());
        System.out.println(ubahn.getCapacity());
        Wagen ubahn3 = new Wagen(3, 6);
        Wagen ubahn4 = new Wagen(7, 9);
        ubahn.addWagen(ubahn3);
        ubahn.addWagen(ubahn4);
        
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
        ubahn.removeWagen();
        
    }
}"
Bartsch,"Simon Tobias",s.bartsch@campus.tu-berlin.de,Beendet,"17. Juni 2021  09:32","20. Juni 2021  21:52","3 Tage 12 Stunden","10,53","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","public class Rechteck { 
    public int breite;
	public static void main(String[] args) {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
    
   public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }



}","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","private
; static
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 15; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 3(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 0; Teil 47: 0; Teil 48: 1; Teil 49: 4(15); Teil 50: 1; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 5(15); Teil 57: %; Teil 58: %; Teil 59: 0; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 6(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 0; Teil 69: %; Teil 70: 7(17); Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: -; Teil 75: -; Teil 76: -; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 17; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 3(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 1; Teil 96: 0; Teil 97: 0; Teil 98: 4(17); Teil 99: 0; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 5(17); Teil 105: %; Teil 106: %; Teil 107: 0; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 6(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: 1; Teil 117: %; Teil 118: 7(17); Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: -; Teil 123: -; Teil 124: -; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest{
	
	public static void main(String[] args){
	Wagen a = new Wagen (64, 32);
	Wagen b = new Wagen (256, 512);
	Wagen c = new Wagen (200, 300);
	Wagen d = new Wagen (35, 20);

	Subway xpress = new Subway(3);
	
	xpress.addWagen(a);
	xpress.addWagen(b);
	System.out.println(xpress.getSeats());
	System.out.println(xpress.getStandingRoom());
	System.out.println(xpress.getCapacity()); 
	xpress.addWagen(c);
	xpress.addWagen(d);
	xpress.removeWagen();
	xpress.removeWagen();
	xpress.removeWagen();
	xpress.removeWagen();
	xpress.removeWagen();
	}		
}"
Klingelhöfer,"Sabine Sophie",klingelhoefer@campus.tu-berlin.de,Beendet,"17. Juni 2021  09:47","20. Juni 2021  23:59","3 Tage 14 Stunden","12,56","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","void
; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: 1; Teil 109: 1; Teil 110: 0; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
   
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    if(denominator < 0) {
    numerator = -numerator;
    denominator = -denominator;
    }
    if(denominator == 0) {
    denominator = 1;
    }
    int a = GCD(numerator, denominator);
    numerator = numerator/a;
    denominator = denominator/a;
    this.numerator = numerator;
    this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
    return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    int a = GCD(numerator, denominator);
    numerator = numerator/a;
    denominator = denominator/a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    numerator = numerator*f.getDenominator() + f.getNumerator()*denominator;
    denominator = denominator* f.getDenominator();
    int a = GCD(numerator, denominator);
    numerator = numerator/a;
    denominator = denominator/a;
    return new Fraction(numerator, denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    denominator = denominator*f.getDenominator();
    numerator = numerator*f.getNumerator();
    return new Fraction(numerator, denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    if (numerator == 0)
    return new Fraction(numerator, denominator);
    else
    return new Fraction(denominator, numerator);
    }
   
    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    if (f.getNumerator() != 0) {
    denominator = denominator*f.getNumerator();
    numerator = numerator*f.getDenominator();
    return new Fraction(numerator, denominator);
    }
    else {
    denominator = denominator*f.getDenominator();
numerator = numerator*f.getNumerator();
return new Fraction(numerator, denominator);
    }
    }
   
}",-
Volkmann,Maximilian,m.volkmann@campus.tu-berlin.de,Beendet,"17. Juni 2021  10:10","20. Juni 2021  23:59","3 Tage 13 Stunden","16,07","private
; void
; static","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: %; Teil 2: %; Teil 3: %; Teil 4: %; Teil 5: %; Teil 6: %; Teil 7: %; Teil 8: %; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: %; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: %; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
      if(denominator <= 0){
        this.numerator = (-numerator);
        this.denominator = (-denominator);
        if(denominator == 0){
          this.numerator = numerator;
          this.denominator = 1;
        }
      }
      else{
        this.numerator = numerator;
        this.denominator = denominator;
      }
      shorten();
      }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double n =this.numerator;
        double d = this.denominator;
        double toDouble = (n/d);
        return toDouble;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String toString = this.numerator+ ""/"" +this.denominator;
        return toString;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a = Math.abs(GCD(this.numerator, this.denominator));
        int n = (this.numerator/ a);
        int d = (this.denominator/ a);
        this.numerator = (n);
        this.denominator = (d);
      }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
      int d = LCM(this.denominator, f.denominator);
      Fraction a = new Fraction((this.numerator * (d/this.denominator)+f.numerator * (d/f.denominator)),(d));
      return a;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
      int n = this.numerator * f.numerator;
      int d = this.denominator * f.denominator;
      Fraction b = new Fraction(n, d);
      return b;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
      int n = this.denominator;
      int d = this.numerator;
      if(d != 0){
        Fraction a = new Fraction(n, d);
        return a;
        }
        else{
          Fraction b = new Fraction(d, n);
          return b;
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
      Fraction a = f.reciprocal();
      int n = this.numerator * a.numerator;
      int d = this.denominator* a.denominator;
      Fraction b = new Fraction(n, d);
      return b;
    }

}","public class SubwayTest{
  public static void main(String [] args){
  Subway a = new Subway(3);
  Wagen ab = new Wagen(12, 15);
  Wagen cd = new Wagen(14, 19);
  Wagen ef = new Wagen(6, 9);
  Wagen gh = new Wagen(1,2);
  a.addWagen(ab);
  a.addWagen(cd);
  System.out.println(a.getSeats());
  System.out.println(a.getStandingRoom());
  System.out.println(a.getCapacity());
  a.addWagen(ef);
  a.addWagen(gh);
  a.removeWagen();
  a.removeWagen();
  a.removeWagen();
  a.removeWagen();
  a.removeWagen();


}
}//Hier soll die Klasse SubwayTest stehen!"
Khatiwada,Aayush,khatiwada@campus.tu-berlin.de,Beendet,"17. Juni 2021  11:45","20. Juni 2021  23:59","3 Tage 12 Stunden","9,25","Getter und Setter","static
; private
; void","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest {
    public static void main(String[] args) {
        Subway U_bahn = new Subway(3);
        Wagen w1 = new Wagen(5,10);
        Wagen w2 = new Wagen(7,14);
        Wagen w3 = new Wagen(1 ,14);
        Wagen w4 = new Wagen(4,14);

        U_bahn.addWagen(w1);
        U_bahn.addWagen(w2);

        System.out.println(U_bahn.getSeats());
        System.out.println(U_bahn.getStandingRoom());
        System.out.println(U_bahn.getCapacity());

        U_bahn.addWagen(w3);
        U_bahn.addWagen(w4);

        for (int i = 0; i < 5;i++) {
            U_bahn.removeWagen();
        }
    }
}"
Agung,"Naufal Radhana",n.agung@campus.tu-berlin.de,Beendet,"17. Juni 2021  14:05","20. Juni 2021  23:47","3 Tage 9 Stunden","9,70","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","static
; private
; void","Zugriff auf private Attribute ermöglichen
; Verhindern, dass Attributswerte gesetzt werden

; Setzen falscher Attributwerte verhindern","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 15; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 3(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 0; Teil 47: 0; Teil 48: 1; Teil 49: 4(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: 1; Teil 54: 0; Teil 55: 1; Teil 56: 5(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: 1; Teil 61: 0; Teil 62: 0; Teil 63: 6(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: 1; Teil 68: 0; Teil 69: 0; Teil 70: 7(15); Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: -; Teil 75: -; Teil 76: -; Teil 77: 16; Teil 78: 1; Teil 79: 0; Teil 80: 0; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 17; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 3(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 1; Teil 96: 0; Teil 97: 0; Teil 98: 4(17); Teil 99: %; Teil 100: %; Teil 101: 0; Teil 102: 0; Teil 103: 0; Teil 104: 5(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: 0; Teil 109: 0; Teil 110: 0; Teil 111: 6(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: 0; Teil 116: 1; Teil 117: 0; Teil 118: 7(17); Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: -; Teil 123: -; Teil 124: -; Teil 125: 18; Teil 126: 0; Teil 127: 1; Teil 128: 0; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class Fraction {


    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
      if (denominator<0){
        this.numerator = numerator * -1;
        this.denominator = denominator * -1;
          shorten();
        return;
      }
      else if (denominator == 0){
        this.numerator = numerator;
        this.denominator = 1;
          shorten();
        return;
      }
      else {
        this.numerator=numerator;
        this.denominator=denominator;
          shorten();
        return;
      }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
      double top = this.numerator;
      double bot = this.denominator;
        return top/bot;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
      if(this.numerator!= 0){
        int div=GCD(this.numerator,this.denominator);
        this.numerator /= div;
        this.denominator /= div;
      }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
      if (this.denominator==f.denominator){
        this.numerator = this.numerator + f.numerator;
        return this;
      }
      else{
        int newden = LCM(this.denominator, f.denominator);
        this.numerator *= (newden / this.denominator);
        f.numerator *= (newden / f.denominator);
        this.numerator = this.numerator + f.numerator;
        this.denominator = newden;
        return this;
      }
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
      this.numerator = this.numerator * f.numerator;
      this.denominator = this.denominator * f.denominator;
      shorten();
      return this;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator != 0){
          int temp = this.denominator;
          this.denominator=this.numerator;
          numerator=temp;

          return this;
        }
        else{
          return this;
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
      return multiply(f.reciprocal());
    }

}","public class SubwayTest{
  public static void main(String[] args){
    Subway subway = new Subway(3);
    subway.addWagen(14,83);
    subway.addWagen(20,65);
    subway.getSeats();
    subway.getStandingRoom();
    subway.getCapacity();
    subway.addWagen(23,77);
    subway.addWagen(27,70);
    subway.removeWagen();
    subway.removeWagen();
    subway.removeWagen();
    subway.removeWagen();
    subway.removeWagen();
  }
}"
Theo,Yovan,yovan.theo@campus.tu-berlin.de,Beendet,"17. Juni 2021  17:35","20. Juni 2021  23:59","3 Tage 6 Stunden","16,99","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden",void,"public class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: l; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: l; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if (denominator == 0) {
			this.denominator = 1;
			this.numerator = numerator;
		} else if (denominator > 0) {
			this.denominator = denominator;
			this.numerator = numerator;
		} else if (denominator < 0 && numerator < 0) {
			this.denominator = denominator*(-1);
			this.numerator = numerator;
		} else if (denominator < 0 && numerator > 0) {
			this.denominator = denominator*(-1);
			this.numerator = numerator*(-1);
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double gkz = (double) this.numerator/this.denominator;
		return gkz;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s = this.numerator+""/""+this.denominator;
		return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int n = (int) this.numerator/GCD(this.numerator,this.denominator);
		int d = (int) this.denominator/GCD(this.numerator,this.denominator);
		this.numerator = n;
		this.denominator = d;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int x = LCM(this.denominator, f.denominator);
	   int a = (int) x/this.denominator;
	   int b = (int) x/f.denominator;
	   int n = ((this.numerator*a)+(f.numerator*b));
	   Fraction result = new Fraction(n,x);
	   return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int n = this.numerator*f.numerator;
		int x = this.denominator*f.denominator;
		Fraction result = new Fraction(n,x);
		result.shorten();
		return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		int n = 0;
		int d = 0;
		if (this.numerator != 0) {
			n = this.denominator;
			d = this.numerator;
		} else {
			n = this.numerator;
			d = this.denominator;
		}
		Fraction result = new Fraction(n,d);
		return result;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		return this.multiply(f.reciprocal());
    }
    
}","public class SubwayTest {
	
	public static void main(String[] args){
		Subway pankow = new Subway(3);
		Wagen w1 = new Wagen(10,30);
		Wagen w2 = new Wagen (21,31);
		pankow.addWagen(w1);
		pankow.addWagen(w2);
		System.out.println(pankow.getSeats());
		System.out.println(pankow.getStandingRoom());
		System.out.println(pankow.getCapacity());
		Wagen w3 = new Wagen(45,60);
		Wagen w4 = new Wagen(37,58);
		pankow.addWagen(w3);
		pankow.addWagen(w4);
		pankow.removeWagen();
		pankow.removeWagen();
		pankow.removeWagen();
		pankow.removeWagen();
		pankow.removeWagen();
	}
}"
Schuchardt,"Silas Samuel",schuchardt@tu-berlin.de,Beendet,"18. Juni 2021  08:43","20. Juni 2021  23:59","2 Tage 15 Stunden","10,78","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Getter und Setter","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","void
; private
; static","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 15; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 3(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 0; Teil 47: 0; Teil 48: 1; Teil 49: 4(15); Teil 50: 1; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 5(15); Teil 57: %; Teil 58: %; Teil 59: 0; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 6(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 0; Teil 69: %; Teil 70: 7(17); Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: -; Teil 75: -; Teil 76: -; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 17; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 3(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 1; Teil 96: 0; Teil 97: 0; Teil 98: 4(17); Teil 99: 0; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 5(17); Teil 105: %; Teil 106: %; Teil 107: 0; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 6(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: 1; Teil 117: %; Teil 118: 7(17); Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: -; Teil 123: -; Teil 124: -; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest{
	
	public static void main(String[] args){
	Wagen r = new Wagen (50, 100);
	Wagen s = new Wagen (30, 80);
	Wagen t = new Wagen (40, 120);
	Wagen u = new Wagen (10, 200);

	
	Subway m = new Subway(3);
	
	

	m.addWagen(r);
	m.addWagen(s);

	m.getSeats();
	m.getStandingRoom();
	m.getCapacity();

	m.addWagen(t);
	m.addWagen(u);
	
	
	m.removeWagen();
	m.removeWagen();
	m.removeWagen();
	m.removeWagen();
	m.removeWagen();
	
	
	
}
	
	
}"
Wolf,"Matilda Sophie",matilda.s.wolf@campus.tu-berlin.de,Beendet,"18. Juni 2021  09:14","18. Juni 2021  10:45","1 Stunde 30 Minuten","15,51","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Getter und Setter","static
; private
; void","Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class Fraction {
   
   private int numerator;
   private int denominator;
   
   public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }
	
	 public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
   
   
	public Fraction(int numerator, int denominator) {
		this.denominator = denominator;
		this.numerator= numerator;
		if (denominator == 0){
			this.denominator = 1;
		}
		/*if (denominator < 0){
			int reverse = -1;
			this.denominator = this.denominator * reverse;
			this.numerator = this.numerator * reverse;
		}
		System.out.println(this.toString ());*/
		shorten();
	}

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         return ((double) this.numerator) / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;

		}

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
	 
	
    public void shorten() {
		int gcd = GCD(numerator, denominator);
		if (denominator < 0){
			int a = -1;
			numerator /= gcd*a;
			denominator /= gcd*a;
		}
		else {
		numerator /= gcd;
		denominator /= gcd;
		}
    }
	
/**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */	
	public Fraction add(Fraction f) {
		this.numerator = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
		this.denominator = denominator * f.getDenominator();
		return new Fraction(this.numerator, this.denominator);
	}
   	
	 /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int newNumerator = numerator * f.numerator;
		int newDenominator = denominator * f.denominator;
		Fraction result = new Fraction(newNumerator, newDenominator);
		return result; 
    }
 /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (getNumerator () != 0) {
		   return new Fraction (denominator,numerator);
		}
		return new Fraction (numerator,denominator);
	}
	  /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		/*int newNumerator = this.numerator * f.denominator;
		int newDenominator = this.denominator * f.numerator;
		Fraction result = new Fraction(newNumerator, newDenominator);
		return result; */
		f = f.reciprocal();
		return this.multiply(f);
	}
}","public class SubwayTest {
	public static void main(String[] args){
		Subway u8 = new Subway(3);
		
		u8.addWagen(new Wagen(20,30));
		u8.addWagen(new Wagen(35,55));
		
		//System.out.println(u8.countWagen()+"" Wagen\n""+u8.getSeats()+"" Seats\n""+u8.getStandingRoom()+"" Standing Room\n""+u8.getCapacity()+"" Capacity"");
		
		u8.addWagen(new Wagen(17,37));
		u8.addWagen(new Wagen(20,45));
		
		for(int i=0;i<5;i++) u8.removeWagen();
		
		//System.out.println(u8.countWagen()+"" Wagen\n""+u8.getSeats()+"" Seats\n""+u8.getStandingRoom()+"" Standing Room\n""+u8.getCapacity()+"" Capacity"");	
	}
}"
Heritz,Faris,f.heritz@campus.tu-berlin.de,Beendet,"18. Juni 2021  10:19","20. Juni 2021  23:59","2 Tage 13 Stunden","4,03","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","static
; void
; private","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 4(15); Teil 43: 0; Teil 44: %; Teil 45: %; Teil 46: rechts; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: mitte; Teil 56: 6(15); Teil 57: %; Teil 58: 1; Teil 59: %; Teil 60: %; Teil 61: links; Teil 62: 0; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 1; Teil 93: %; Teil 94: %; Teil 95: mitte; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: links; Teil 104: 6(17); Teil 105: %; Teil 106: 0; Teil 107: %; Teil 108: %; Teil 109: rechts; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
       
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double dbruch = getNumerator()/getDenominator();
		return dbruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String sbruch = getNumerator()+""/""+getDenominator();
		return sBruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
       this.numerator = numerator/GCD();
	   this.denominator = denominator/GCD();
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator != 0){
		    int knumerator = denominator;
		    int kdenominator = numerator;
			this.numerator = knumerator;
			this.denominator = kdenominator;
	        return Fraction;
			}
			
		else
		{
			return Fraction;
		}
			
			
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest{
	
	public static void main(String[] args){
		Ubahn Subway;
		Ubahn = new Subway(3);
		addWagen(20,30);
		addWagen(40,20);
		System.out.println(getCapacity());
		addWagen(10,10);
		addWagen(10,10);
		removeWagen();
		removeWagen();
		removeWagen();
		removeWagen();
		removeWagen();
		
	}
}
//Hier soll die Klasse SubwayTest stehen!"
"Saa Hinojosa","Paola Carolina",p.saahinojosa@campus.tu-berlin.de,Beendet,"18. Juni 2021  11:07","20. Juni 2021  23:59","2 Tage 12 Stunden","5,33","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","private
; void","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Main {

	public static void main(String[] args) {
		
		Fraction fraccion1 = new Fraction();
		fraccion1.setNumerador(7);
		fraccion1.setDenominador(5);
		
		Fraction fraccion2 = new Fraction();
		fraccion2.setNumerador(8);
		fraccion2.setDenominador(4);
		
		Fraction add = new Fraction();
		add = fraccion1.add(fraccion2);
		Fraction revert1 = add.reciprocal(add);
		
		Fraction multiply = new Fraction();
		multiply = fraccion1.multiply(fraccion2);
		Fraction revert2 = add.reciprocal(multiply);
		
		Fraction divide = new Fraction();
		divide = fraccion1.divide(fraccion2);
		Fraction revert3 = add.reciprocal(divide);
		
		
		System.out.println(fraccion1 + "" + "" + fraccion2 + "" = "" + add + "" ==> "" + revert1);
		System.out.println(fraccion1 + "" + "" + fraccion2 + "" = "" + multiply + "" ==> "" + revert2);
		System.out.println(fraccion1 + "" + "" + fraccion2 + "" = "" + divide + "" ==> "" + revert3);
		
	}
}
public class Fraction {

	private int numerador;
	private int denominador;

	public Fraction() {

	}

	public Fraction(int numerador, int denominador) {
		super();
		this.numerador = numerador;
		this.denominador = denominador;
	}

//	Mínimo común múltiplo
	public static int LCM(int x, int y) {
		return (x * y) / GCD(x, y);
	}

	public static int GCD(int x, int y) {
		if (y == 0)
			return x;
		return GCD(y, x % y);
	}

	private Fraction convert(int common) {
		Fraction result = new Fraction();
		int factor = common / denominador;
		result.numerador = numerador * factor;
		result.denominador = common;
		return result;
	}

	private Fraction shorten() {
		Fraction result = new Fraction();
		int common = 0;

		int num = Math.abs(numerador);
		int den = Math.abs(denominador);

		if (num > den)
			common = GCD(num, den);
		else if (num < den)
			common = GCD(den, num);
		else
			common = num;

		// set result based on common factor derived from gcd
		result.numerador = numerador / common;
		result.denominador = denominador / common;
		return result;
	}

	public Fraction add(Fraction f) {
		int common = LCM(denominador, f.denominador);
		Fraction a = new Fraction();
		Fraction b = new Fraction();
		a = convert(common);
		b = f.convert(common);
		Fraction suma = new Fraction();
		suma.numerador = a.numerador + b.numerador;
		suma.denominador = a.denominador * b.denominador;
		suma.denominador = common;
		return suma;
	}

	public Fraction multiply(Fraction f) {
		Fraction product = new Fraction();
		product.numerador = numerador * f.numerador;
		product.denominador = denominador * f.denominador;
		product = product.shorten();
		return product;
	}

	public Fraction divide(Fraction f) {
		Fraction result = new Fraction();
		result.numerador = numerador * f.denominador;
		result.denominador = denominador * f.numerador;
		result = result.shorten();
		return result;
	}

	public double toDouble() {
		double valorDecimal = numerador / denominador;
		return valorDecimal;
	}

	public Fraction reciprocal(Fraction f) {
		int value = 1;
		Fraction invert = new Fraction();
		invert.numerador = value * f.denominador;
		invert.denominador = value * f.numerador;
		return invert;
	}

	/*
	 * Getters and Setters
	 */
	public int getNumerador() {
		return numerador;
	}

	public void setNumerador(int numerador) {
		this.numerador = numerador;
	}

	public int getDenominador() {
		return denominador;
	}

	public void setDenominador(int denominador) {
		this.denominador = denominador;
	}

	public String toString() {
		String texto = numerador + "" / "" + denominador;
		return texto;
	}

}",-
Machleidt,"Felice Josima Lunes Noah",machleidt@campus.tu-berlin.de,Beendet,"18. Juni 2021  12:24","20. Juni 2021  22:30","2 Tage 10 Stunden","15,63","class Rechteck { 
    private int breite;

    public void setBreite(int breite) {
        this.breite = breite;
    }

    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
    public static void main(String[] args)  {

        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
    }
}",void,"Getter und Setter","In Objektmethoden können lokale Variablen deklariert werden","Setter-Methoden haben in der Regel den Rückgabetyp void","Setzen falscher Attributwerte verhindern

; Verhindern das Überladen von Methoden","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: 11; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: 12; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: 13; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: 14; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: 15; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: 3(15); Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","public class Fraction{
    private int numerator, denominator;
    public static int GCD(int x,int y){
        if (y==0) return x;
        return GCD(y,x % y);
    }
    public static int LCM(int x, int y){
        return (x*y)/GCD(x,y);
    }
    public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }

    public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }
}","public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagen w1=new Wagen(25,30);
        u9.addWagen(w1);
        Wagen w2=new Wagen(55,45);
        u9.addWagen(w2);
        System.out.print( u9.countWagen()+"" Wagen\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagen w3=new Wagen(25,35);
        u9.addWagen(w3);
        Wagen w4=new Wagen(12,33);
        u9.addWagen(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagen();
        }
        System.out.print( u9.countWagen()+"" Wagen\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }
}"
Krebs,"Florian Anselm",florian.krebs@campus.tu-berlin.de,Beendet,"18. Juni 2021  16:57","20. Juni 2021  23:59","2 Tage 7 Stunden","18,50","private
; void","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest {
	
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if (denominator>0){
			this.numerator = numerator;
			this.denominator = denominator; 
		} else if (denominator==0){
			this.numerator = numerator;
			this.denominator = 1; 
		} else  {
			this.numerator = (-numerator);
			this.denominator = (-denominator); 
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double dezimalZahl  = (this.numerator/(double)this.denominator);
		return dezimalZahl;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch = """";
		bruch = this.numerator+""/""+this.denominator;
		return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int ggT= GCD(this.numerator, this.denominator);
        this.numerator= (this.numerator/ggT);
		this.denominator = (this.denominator/ggT);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		f.numerator= (int) this.numerator*f.denominator+(f.numerator*this.denominator);
		f.denominator= (int) this.denominator*f.denominator;
		f.shorten();
		return f;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		f.numerator= (int) this.numerator*f.numerator;
		f.denominator= (int) this.denominator*f.denominator;
		f.shorten();
		return f;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
	  	if (this.numerator!=0){
			int zaehler =this.numerator;
	  		this.numerator = this.denominator;
			this.denominator = zaehler;
	  	} 
		Fraction reciprok = new Fraction(this.numerator, this.denominator);
		return reciprok;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		int zaehler =f.numerator;	
		int nenner =f.denominator;	
		f.reciprocal();
		multiply(f);	
		return f;
    }
    
}","public class SubwayTest {
	
	public static void main (String[]args){
		
		Subway u1 = new Subway(3);
		Wagen w1 = new Wagen(50,100);
		Wagen w2 = new Wagen(55,75);

		u1.addWagen(w1);
		u1.addWagen(w2);

		System.out.println(u1.getSeats());
		System.out.println(u1.getStandingRoom());
		System.out.println(u1.getCapacity());
		
		u1.addWagen(w2);
		u1.addWagen(w2);
		
		u1.removeWagen();
		u1.removeWagen();	
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();	
	}
}"
Heine,Frederik,f.heine@campus.tu-berlin.de,Beendet,"18. Juni 2021  17:56","20. Juni 2021  23:59","2 Tage 6 Stunden","4,92","public class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest {
	public static void main (String[] args) {
		Subway U5 = new Subway (3);
		Wagen One = new Wagen (12, 24);
		Wagen Two = new Wagen (10, 20);
		Wagen Three = new Wagen (65, 34);
		Wagen Four = new Wagen (14, 54);
		addWagen(One);
		addWagen(Two);
		getSeats;
		getStandingRoom;
		getCapacity;
		Wagen(Three);
		Wagen(Four);
		removeWagen();
		removeWagen();
		removeWagen();
		removeWagen();
		removeWagen();
	}
}"
Schneider,Felix,felix.schneider@campus.tu-berlin.de,Beendet,"19. Juni 2021  07:28","20. Juni 2021  23:59","1 Tag 16 Stunden","10,50","private
; void","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Verhindern das Überladen von Methoden","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		if (this.denominator < 0){
			this.numerator = numerator *(-1);
			this.denominator = denominator *(-1);
		}
		else if (this.denominator == 0)
			this.denominator = 1;
		int g = GCD(this.numerator,this.denominator);
		this.numerator = this.numerator/g;
		this.denominator = this.denominator/g;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        int d = this.denominator;
		return d;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        int n = this.numerator;
		return n;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double d = (double) this.numerator/this.denominator;
		return d;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s = (this.numerator+""/""+this.denominator);
		return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int g = GCD(this.numerator,this.denominator);
		this.numerator = this.numerator/g;
		this.denominator = this.denominator/g;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int l = LCM(this.denominator,f.denominator);
	   int d1 = l/this.denominator;
	   int df = l/f.denominator;
	   Fraction a = new Fraction(d1*this.numerator+df*f.numerator,l);
	   a.shorten();
	   return a;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction a = new Fraction(this.numerator*f.numerator,this.denominator*f.denominator);
		a.shorten();
	    return a;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if (this.numerator == 0){
			Fraction a = new Fraction(this.numerator,this.denominator);
			a.shorten();
			return a;
		}
		Fraction a = new Fraction(this.denominator,this.numerator);
		a.shorten();
	    return a;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction a = new Fraction(this.numerator,this.denominator);
	   a = a.multiply(f.reciprocal());
	   return a;
    }
    
}","public class SubwayTest{
	
	public static void main(String[] args){
		Subway U6 = new Subway(3);
		Wagen zweiUndDrei = new Wagen(2,3);
		Wagen fuenfUndVier = new Wagen(5,4);
		Wagen dreiUndDrei = new Wagen(3,3);
		Wagen neunUndAcht = new Wagen(9,8);
		U6.addWagen(zweiUndDrei);
		U6.addWagen(fuenfUndVier);
		System.out.println(""Kapazitaet: S:""+U6.getSeats()+"" W: ""+U6.getStandingRoom()+"" K: "");
		U6.addWagen(dreiUndDrei);
		U6.addWagen(neunUndAcht);
		for (int i = 0 ; i < 5 ; i++)
			U6.removeWagen();
		// +U6.getCapacity()
	}
}"
Kubale,"Felice Pia Sophie",f.kubale@campus.tu-berlin.de,Beendet,"19. Juni 2021  10:32","20. Juni 2021  23:59","1 Tag 13 Stunden","12,26","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","private
; static
; void","Teil 1: %; Teil 2: %; Teil 3: %; Teil 4: %; Teil 5: %; Teil 6: %; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest {
	public static void main(String[] args) {
		Subway subway = new Subway(3);
		subway.addWagen(new Wagen(17,46));
		subway.addWagen(new Wagen(23,28));
		System.out.print(""Sitzplätze: "" + subway.getSeats());
		System.out.print("" Stehplätze: "" + subway.getStandingRoom());
		System.out.println("" Alle Plätze: "" + subway.getCapacity());
		subway.addWagen(new Wagen(17,45));
		subway.addWagen(new Wagen(23,27));
		for(int i = 0; i<5; i++) {
			subway.removeWagen();
		}
	}
}"
Lohse,"Clemens Christian",clemens.lohse@campus.tu-berlin.de,Beendet,"19. Juni 2021  13:00","20. Juni 2021  23:59","1 Tag 10 Stunden","1,85","Zugriff auf private Attribute ermöglichen","static
; void
; private","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Getter und Setter","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: 11; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: 12; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: 13; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: 14; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: 3; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: 4; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: 5; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: 6; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: 7; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: 15; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: 16; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: 3; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: 4; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: 5; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: 6; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: 7; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: 17; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: 18; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
Eckhardt,Henry,henry.eckhardt@campus.tu-berlin.de,Beendet,"19. Juni 2021  14:22","20. Juni 2021  23:59","1 Tag 9 Stunden","10,61","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","static
; void
; private","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 15; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 3(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 0; Teil 47: 0; Teil 48: 1; Teil 49: 4(15); Teil 50: 1; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 5(15); Teil 57: %; Teil 58: %; Teil 59: 0; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 6(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 0; Teil 69: %; Teil 70: 7(15); Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: -; Teil 75: -; Teil 76: -; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 17; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 3(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 1; Teil 96: 0; Teil 97: 0; Teil 98: 4(17); Teil 99: 0; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 5(17); Teil 105: %; Teil 106: %; Teil 107: 0; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 6(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: 1; Teil 117: %; Teil 118: 7(17); Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: -; Teil 123: -; Teil 124: -; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest{
	
	public static void main(String[] args){
	Wagen r = new Wagen (50, 100);
	Wagen s = new Wagen (30, 80);
	Wagen t = new Wagen (40, 120);
	Wagen u = new Wagen (10, 200);

	Subway m = new Subway(3);

	m.addWagen(r);
	m.addWagen(s);
	m.getSeats();
	m.getStandingRoom();
	m.getCapacity();
	m.addWagen(t);
	m.addWagen(u);
	m.removeWagen();
	m.removeWagen();
	m.removeWagen();
	m.removeWagen();
	m.removeWagen();
}
}"
Baumann,"Felix Elmar Gerd",f.baumann@campus.tu-berlin.de,Beendet,"19. Juni 2021  15:07","20. Juni 2021  23:59","1 Tag 8 Stunden","16,86","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","public class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","private
; static
; void","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: ; Teil 8: %; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: ; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: ; Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: ; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: ; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: ; Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: ; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: ; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: ; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: ; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: ; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: ; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: ; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: ; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: ; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: ; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: ; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: ; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Methode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if (denominator == 0) {
            this.denominator = 1;
        }
        else if(denominator < 0){
            this.denominator = denominator * -1;
            this.numerator = numerator * -1;
        } else {
            this.denominator = denominator;        
        }
        this.shorten();

    }

    /**
     * Gibt den Nenner zurueck. 
     */ 
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator / (double) denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = Fraction.GCD(numerator, denominator);
        int newNum = numerator / gcd; 
        int newDen = denominator / gcd; 
        numerator = newNum;
        denominator = newDen;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = Fraction.LCM(f.getDenominator(), denominator);
        int num1 = numerator*(lcm/denominator);
        int num2 = f.getNumerator()*(lcm/f.getDenominator());
        Fraction result = new Fraction(num1 + num2, lcm);
        result.shorten();
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction result = new Fraction(numerator*f.getNumerator(), denominator*f.getDenominator());
        result.shorten();
        return result;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction result = new Fraction(numerator, denominator);
        if (numerator != 0) {
            result.numerator = denominator;
            result.denominator = numerator;
        }
        result.shorten();
        return result;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction kehr = f.reciprocal();
        Fraction result = this.multiply(kehr);
        result.shorten();
        return result;
    }
}","public class SubwayTest {
    public static void main(String[] args) {
        Subway sub = new Subway(3);
        Wagen wag1 = new Wagen(1,2);
        Wagen wag2 = new Wagen(3,4);

        String add = sub.addWagen(wag1);
        add = sub.addWagen(wag2);

        System.out.println(sub.getSeats());
        System.out.println(sub.getStandingRoom());
        System.out.println(sub.getCapacity());

        Wagen wag3 = new Wagen(1,2);
        Wagen wag4 = new Wagen(3,4);

        add = sub.addWagen(wag3);
        add = sub.addWagen(wag4);

        String remove = sub.removeWagen();
        remove = sub.removeWagen();
        remove = sub.removeWagen();
        remove = sub.removeWagen();
        remove = sub.removeWagen();
    }
}"
Xu,Lili,l.xu@campus.tu-berlin.de,Beendet,"19. Juni 2021  22:32","20. Juni 2021  23:39","1 Tag 1 Stunde","12,40","Getter und Setter","void
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 0; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;

    /**
     * returns the greatest common divider of both arguments
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * returns the lowest common multiple of both arguments
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //beginning of task
    /**
     * fully parameterised constructor, which gets numerator and denominator handed over
     * and sets the corresponding attributes
     * negative signs (numbers < 0) can only appear in the numerator
     * (not in the ""denominator"" attribute)
     * but you can hand over a negative denominator (""denominator"" argument) to the constructor
     * so the constructor has to check the denominator that was handed over and handle its sign in a way
     * that the resulting fraction (the attributes) fulfill the stated restriction
     * and the value of the fractions (the arguments) have to stay the same
     * a negative sign has to be dealt with mathematically correct
     * if a 0 is handed over as denominator, the corresponding attribute
     * will be set to 1
     * every generated fraction shall be shortened (use corresponding method for it)
     */
    public Fraction(int numerator, int denominator) {
        //Denominator can only be positive
        if(denominator >= 0) {
            this.numerator = numerator;
            if(denominator == 0){
                this.denominator = 1;
            }
            else {
                this.denominator = denominator;
            }
        }

        if(denominator < 0){
            //So denominator becomes positive
            this.denominator = denominator*-1;
            //And the numerator becomes the opposite
            this.numerator = numerator*-1;
        }

        this.shorten();
    }

    /**
     * returns the denominator
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * returns numerator
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * returns fraction as double
     */
    public double toDouble() {
        return (double) numerator/denominator;
    }

    /**
     * returns String with the format
     * ""numerator/denominator""
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * shortens the fraction
     */
    public void shorten() {
        int commdivider = Math.abs(GCD(numerator, denominator));
        numerator = numerator / commdivider;
        denominator = denominator / commdivider;
    }

    /**
     * converts fraction to a common denominator, afterwards adds the fraction that was handed over
     */
    public Fraction add(Fraction f) {
        int commdenom = LCM(this.denominator,f.denominator);
        Fraction addition = new Fraction(this.numerator*(commdenom/this.denominator) + f.numerator*(commdenom/f.denominator),commdenom);
        return addition;
    }

    /**
     * multiplies with the fraction that was handed over
     */
    public Fraction multiply(Fraction f) {
        Fraction multiplication = new Fraction(this.numerator*f.numerator, this.denominator*f.denominator);
        return multiplication;
    }

    /**
     * forms the reciprocal if the numerator != 0
     * otherwise the fractions gets returned unchanged
     */
    public Fraction reciprocal() {
        if(numerator != 0){
            Fraction reciprocal = new Fraction(this.denominator,this.numerator);
            return reciprocal;
        }
        return this;
    }

    /**
     * divides by the passed fraction
     * (using reciprocal and multiplication)
     */
    public Fraction divide(Fraction f) {
        Fraction reciprocalF = f.reciprocal();
        Fraction divide = new Fraction(this.numerator* reciprocalF.numerator, this.denominator* reciprocalF.denominator);
        return divide;
    }

}",-
Trümpler,Antonia,a.truempler@campus.tu-berlin.de,Beendet,"20. Juni 2021  09:40","20. Juni 2021  23:04","13 Stunden 24 Minuten","5,32","private
; void","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Verhindern, dass Attributswerte gesetzt werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: -; Teil 37: -; Teil 38: -; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: -; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: -; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: 0; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: -; Teil 86: -; Teil 87: -; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: -; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: -; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 0; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest {
	
	public static void main(String args[]){
		Subway s = new Subway (3);
		Wagen a = new Wagen ( 5 , 7 , 12 );
		a.getSeats ();
		a.getStandingRoom ();
		a.getCapacity ();
		
		s.wagenzahl [0] = a;
		Wagen b = new Wagen (3, 6, 9);
		s.wagenzahl [1] = b;
		System.out.println ( 21 );
		
		
		Wagen c = new Wagen (1,2, 3);
		s.wagenzahl [2] = c;
		Wagen d = new Wagen(8,9, 17);
		System.out.println ( ""Can not add wagen."");
		s.removeWagen ();
		s.removeWagen ();
		s.removeWagen ();
		s.removeWagen ();
		s.removeWagen ();
	
		}
		//for(int i = 0; i <= 3; i++){ wagenzahl[i] = new Wagen(i+1, i+3);
}"
"Van den Wyenbergh",Timo,vandenwyenbergh@campus.tu-berlin.de,Beendet,"20. Juni 2021  13:36","20. Juni 2021  17:27","3 Stunden 51 Minuten","17,30","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern das Überladen von Methoden
; Setzen falscher Attributwerte verhindern

; Verhindern, dass Attributswerte gesetzt werden","Setter-Methoden haben in der Regel den Rückgabetyp void","Getter und Setter","class Rechteck {
    private int breite;

    public void setBreite(int breite) {
        this.breite = breite;
    }

    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void
; private","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: 0; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {
    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe

    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
            denominator = 1;
        }
        if (denominator <= 0) {
            denominator = denominator * -1;
            numerator = numerator * -1;
        }
        this.numerator=numerator;
        this.denominator=denominator;
        this.shorten();



    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {

        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double x = (double)getNumerator() / getDenominator();
        return x;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String x = getNumerator()  + ""/"" + getDenominator();
        return x;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        if (getDenominator() != 1) {
            int a = GCD(getNumerator() , getDenominator());
            numerator = getNumerator()  / a;
            denominator = getDenominator() / a;

        }
    }


    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int x=f.getDenominator();
        f.numerator = f.getNumerator()  * getDenominator();
        f.denominator = f.getDenominator() * getDenominator();
        int z  = getNumerator()  * x;
        int y   = getDenominator() * x;

        f.numerator = f.getNumerator() + z;
        f.shorten();

//

        return f;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        f.numerator = f.getNumerator() * getNumerator();
        f.denominator = f.getDenominator() * getDenominator();
        f.shorten();

        return f;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction a = new Fraction(getNumerator(),getDenominator());


        if (a.getNumerator() != 0) {
            int x = a.getNumerator();
            a.numerator = a.getDenominator();
            a.denominator = x;

        }

        return a;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction x= new Fraction(getNumerator(),getDenominator());
        f=f.reciprocal();
        x=x.multiply(f);
        x.shorten();

        return x;
    }

}","//Hier soll die Klasse SubwayTest stehen!
class SubwayTest {
    public static void main(String[] args) {
        Subway s=new Subway(3);
        s.addWagen(new Wagen(55,22));
        s.addWagen(new Wagen(355,42));
        System.out.println(s.getSeats()+"" ""+s.getStandingRoom()+"" ""+s.getCapacity());
        s.addWagen(new Wagen(55,22));
        s.addWagen(new Wagen(3,42));
        s.removeWagen();
        s.removeWagen();
        s.removeWagen();
        s.removeWagen();
        s.removeWagen();
    }
}"
Escabache,"Pia Annick",escabache@campus.tu-berlin.de,Beendet,"20. Juni 2021  13:39","20. Juni 2021  23:16","9 Stunden 37 Minuten","11,47","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten",void,"Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: 0; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
   
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }

    public Fraction(int numerator, int denominator) {
				this.numerator = numerator;
				this.denominator = denominator;
			if (denominator==0){
					this.denominator =1;
			}

			if (denominator <0){
					this.numerator = -1*this.numerator;
					this.denominator = -1* this.denominator;
			}
				this.shorten();
    }


    public int getDenominator() {
		return this.denominator;
        
    }

    public int getNumerator() {
        return this.numerator;
    }
	
	public double toDouble() {
		double x = (double)numerator / (double)denominator;
		return x;
	 }
	
	public String toString() {
		return this.numerator +""/""+ this.denominator;
    }
	
	 public void shorten() {
		int gcd = Fraction.GCD (numerator,denominator);
		numerator = numerator/gcd;
		denominator = denominator/gcd;
    }




    public Fraction add(Fraction f) {
	
		return new Fraction(this.numerator*f.denominator+f.numerator*this.denominator, this.denominator*f.denominator);
    }

  
    public Fraction multiply(Fraction f) {
		return new Fraction (f.numerator*this.numerator, f.denominator* this.denominator);
        
    }


    public Fraction reciprocal() {
		if (this.numerator ==0){
			return new Fraction (this.numerator, this.denominator);
		}
		else {
		 return new Fraction (this.denominator, this.numerator);
			
		}
       
    }
    
    
    public Fraction divide(Fraction f) {
		return new Fraction (this.numerator*f.denominator, this.denominator*f.numerator );
       
    }
    
}",-
Mäding,"Toni Siegfried",t.maeding@campus.tu-berlin.de,Beendet,"20. Juni 2021  14:10","20. Juni 2021  22:24","8 Stunden 13 Minuten","11,30","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","Getter und Setter","void
; private","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: undef; Teil 40: undef; Teil 41: undef; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(16); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: undef; Teil 89: undef; Teil 90: undef; Teil 91: 4(16); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(16); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(16); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(16); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

   
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }

    public Fraction(int numerator, int denominator) {
        this.numerator = numerator*((denominator==0)?1:Integer.signum(denominator));
        this.denominator = (denominator==0)?1:Math.abs(denominator);
    }

    
    public int getDenominator() {
        return denominator;
        
    }


    public int getNumerator() {
        return numerator;
        
    }

   
    public double toDouble() {
        return ((double) numerator) / ((double) denominator);
    }

   
    public String toString() {
        return numerator + ""/"" + denominator;
    }

   
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= Math.abs(gcd);
        denominator /= Math.abs(gcd);
    }

   
    public Fraction add(Fraction f) {
      int newDenominator = LCM(denominator, f.getDenominator());
      int factor1 = (newDenominator / denominator);
      int factor2 = (newDenominator / f.getDenominator());
      return new Fraction(numerator*factor1+ f.getNumerator()*factor2, newDenominator);
    }

    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.getNumerator(), denominator*f.getDenominator());
    }

    public Fraction reciprocal() {
       if(numerator ==0) return new Fraction(numerator, denominator);
       return new Fraction(denominator, numerator);
    }
    
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    }
    
}",-
König,Timon,timon.koenig@campus.tu-berlin.de,Beendet,"20. Juni 2021  16:44","20. Juni 2021  23:59","7 Stunden 14 Minuten","12,50","private
; void","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern das Überladen von Methoden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
         if(denominator == 0){
            denominator = 1;
        }
        if(denominator<0){
            numerator *= -1;
            denominator *= -1;
        }
        this.numerator = numerator;
        this.denominator = denominator;
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        double gleitkomma = numerator % denominator;
        return gleitkomma;
    }

    public String toString() {
        String bruch = numerator + ""/"" + denominator;
        return bruch;
    }

    public void shorten() {
       Fraction ergebnis = new Fraction();
       int gemeinsam = 0;
       int num = Math.abs(numerator);
       int den = Math.abs(denominator);
       if(num > den){
        gemeinsam = GCD(num,den);
       }
       else if(num<den){
        gemeinsam = GCD(den,num);
       }
       else{
        gemeinsam = num;
       }
       ergebnis.numerator = numerator / gemeinsam;
       ergebnis.denominator = denominator / gemeinsam;
       return ergebnis;
    }

    public Fraction add(Fraction f) {
        int gemeinsam = LCM(denominator, f.denominator);
        Fraction gemeinsamA = new Fraction();
        Fraction gemeinsamB = new Fraction();
        Fraction summe = new Fraction();
        summe.numerator = gemeinsamA.numerator + gemeinsamB.numerator;
        summe.denominator = gemeinsam;
        summe = summme.shorten();
        return summe;
    }

    public Fraction multiply(Fraction f) {
        Fraction produkt = new Fraction();
        produkt.numerator = numerator * f.numerator;
        produkt.denominator = denominator * f.denominator;
        produkt = produkt.shorten();
        return produkt;
    }

    public Fraction reciprocal() {
       if(numerator != 0){
        return new Fraction(denominator, numerator);
       }
    }
    
    public Fraction divide(Fraction f) {
       Fraction division = new Fraction();
       division.numerator = numerator * f.denominator;
       division.denominator = denominator * f.numerator;
       division = division.shorten();
       return division;
    }
    
}","public class SubwayTest{
	public static void main(String[] args){
	Subway subway = new Subway (3);
	subway.addWagen(new Wagen(17,46));
	subway.addWagen(new Wagen(23,28));
	System.out.print(""Sitzplaetze: ""+subway.getSeats());
	System.out.print("" Stehplaetze: ""+subway.getStandingRoom());
	System.out.print("" Alle Plaetze: ""+subway.getCapacity());
	subway.addWagen(new Wagen(17,45));
	subway.addWagen(new Wagen(23,27));
	for (int i= 0; i<5;i++){
		subway.removeWagen();
		}
	}
}"
Ruffo,Max,ruffo@campus.tu-berlin.de,Beendet,"20. Juni 2021  18:48","20. Juni 2021  23:59","5 Stunden 10 Minuten","6,62","static
; void","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","class Rechteck { 
    private int breite;
    
  public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: undef; Teil 5: undef; Teil 6: undef; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 0; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 15; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: 1; Teil 61: 1; Teil 62: %; Teil 63: 16; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","public class Fraction {
    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */


    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */


    public Fraction(int numerator, int denominator) {
        this.numerator=numerator;
        if(0<denominator){
            this.denominator=denominator;
        }else if(0>denominator){
            denominator=denominator*(-1);
            this.denominator=denominator;
            numerator=numerator*(-1);
            this.numerator=numerator;
        }else{
            denominator=1;
            this.denominator=denominator;
        }    
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;  
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;  
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/this.denominator; 
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (getNumerator()+""/""+getDenominator());
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler=GCD(numerator,denominator);
        this.numerator=numerator/teiler;
        this.denominator=denominator/teiler;
    }    
    
    public Fraction add(Fraction f) {
        numerator=numerator+f.numerator;
        if(this.denominator<denominator){
            int a=GCD(this.denominator,denominator);
            this.denominator=a;
        }else if(this.denominator==denominator||this.denominator>denominator){
            int b =LCM(this.denominator,denominator);
            this.denominator=b;
        }
        return new Fraction(numerator,denominator);
            
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        numerator=numerator*f.numerator;
        denominator=denominator*f.denominator;
        return new Fraction(numerator,denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(this.numerator!=0){
            int a=denominator;
            int b=numerator;
            this.denominator=b;
            this.numerator=a;
            return new Fraction(numerator,denominator);
        }else{
            return new Fraction(numerator,denominator);
        }  
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
  
}",-
Venn,"Arthur Raymond",venn@campus.tu-berlin.de,Beendet,"20. Juni 2021  19:24","20. Juni 2021  23:59","4 Stunden 34 Minuten","5,78","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","void
; private","Getter und Setter","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
       return (double) this.doubleValue();
        double fraction = numerator / denominator;
        return fraction;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return String numerator/denominator;
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
         int factorC = GCD(numerator, denominator);
        numerator = numerator/factorC;
        denominator = denominator/factorC;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        numerator = numerator * f.denominator + f.numerator * denominator;
        denominator = denominator * f.denominator;
        cancel();
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
         public static int LCM(int x, int y) {
             numerator = numerator * f.numerator;
        denominator = denominator * f.denominator;
        cancel();
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        if(denominator<0){
            numerator = -numerator;
            denominator = -denominator;
        }
        if(denominator != 0){
            int newNumerator = numerator;
            int newDenominator = denominator;
            numerator = newDenominator;
            denominator = newNumerator;
            cancel();
        }
    }
        
    return system.print.outln;
    }
    
}",-
"Cabral de Jesus",Francisco,cabraldejesus@campus.tu-berlin.de,Beendet,"20. Juni 2021  19:43","20. Juni 2021  23:59","4 Stunden 15 Minuten","5,78","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Getter und Setter","void
; private","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
* Eine Klasse zur Repraesentierung von Bruchzahlen.
*/
public class Fraction {

    /* Je ein streng gekapseltes Attribut fuer den ganzzahligen Zaehler und Nenner. */

    private int numerator;
    private int denominator;

    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt.
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     */
    public Fraction(int pNumerator, int pDenominator) {
        if(pDenominator<0){
            numerator = -pNumerator;
            denominator = -pDenominator;
        }
        if(pDenominator == 0){
            denominator = 1;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    @Override
    public double toDouble(int numerator, int denominator) {
        double fraction = numerator / denominator;
        return fraction;
    }

    /**
     * Ueberschreibt die toString-Methode und gibt einen String im Format
     * ""Zaehler/Nenner = Kommazahl"" zurueck.
     */
    public String toString(double fraction) {
        String kommazahl = Double.toString(fraction);
        return numerator + ""/"" + denominator + "" = "" + kommazahl;
    }

    /**
     * Gibt den groessten gemeinsamen Teiler (Greatest Common Divider) zurueck.
     */
    public static int GCD(int x, int y) {
        if (y == 0) {
            return x;
        }
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache (Lowest Common Multiple) zurueck.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void cancel() {
        int factorC = GCD(numerator, denominator);
        numerator = numerator/factorC;
        denominator = denominator/factorC;
    }

    /**
     * Erweitert, macht gleichnamig, addiert den uebergebenen Bruch und kuerzt.
     */
    public void add(Fraction f) {
        numerator = numerator * f.denominator + f.numerator * denominator;
        denominator = denominator * f.denominator;
        cancel();
    }

    /**
     * Multipliziert den uebergebenen Bruch und kuerzt.
     */
    public void multiply(Fraction f) {
        numerator = numerator * f.numerator;
        denominator = denominator * f.denominator;
        cancel();
    }

    /**
     * Bildet den Kehrwert und kuerzt, wenn der Zaehler ungleich Null ist.
     * Stellt dabei sicher, dass negative Vorzeichen nur im Zaehler auftreten.
     */
    public void reciprocal() {
        if(denominator<0){
            numerator = -numerator;
            denominator = -denominator;
        }
        if(denominator != 0){
            int newNumerator = numerator;
            int newDenominator = denominator;
            numerator = newDenominator;
            denominator = newNumerator;
            cancel();
        }
    }
   
    /**
     * Dividiert den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public void divide(Fraction f) {
        numerator = numerator * f.denominator;
        denominator = denominator * f.numerator;
        cancel();
    }

    /**
     * Deklariert und initialisiert zwei Ganzzahlen:
     * ""numerator"" und ""denominator"" mit den Werten 1 und -7.
     * Deklariert und initialisiert zwei Gleitkommazahlen:
     * ""floatNumber"" und ""floatResult"" mit dem Quotienten aus
     * ""numerator"" und ""denominator"" (dem Ergebnis der Gleitkommarechnung).
     * Erzeugt zwei Objekte vom Typ ""Fraction"":
     * ""fractionNumber"" und ""fractionResult"" mit ""numerator"" als Zaehler und
     * ""denominator"" als Nenner.
     * Addiert ""Betrag von denominator -1"" Mal ""floatNumber"" zu ""floatResult""
     * und genauso oft ""fractionNumber"" zu ""fractionResult"".
     * Gibt mit verstaendlicher Beschreibung ""floatResult"" und ""fractionResult""
     * aus.
     * Bildet den Kehrwert von ""fractionNumber"" und fuehrt dann die Division
     * ""fractionResult/fractionNumber"" aus.
     * Gibt mit verstaendlicher Beschreibung ""fractionNumber""
     * und ""fractionResult"" aus.
     */
    public static void main(String[] args) {
        int numerator = 1;
        int denominator = -7;

        float floatNumber = numerator / denominator;
        float floatResult = numerator / denominator;

        Fraction fractionNumber = new Fraction(numerator, denominator);
        Fraction fractionResult = new Fraction(numerator, denominator);

        floatResult += floatNumber * (denominator-1);
        fractionResult.numerator = (denominator-1)*fractionNumber.numerator;
        fractionResult = new Fraction(fractionResult.numerator, denominator);

        System.out.println(""Der Bruch als Kommazahl ist: ""+floatResult);
        System.out.println(""Der Bruch ist: ""+fractionResult.toString());

        fractionNumber.reciprocal();
        fractionResult.divide(fractionNumber);

        System.out.println(""Der Bruch als Kommazahl ist: ""+fractionNumber.toString());
        System.out.println(""Der Bruch ist: ""+fractionResult.toString());


    /**
     * To be filled
     */  
   
    }
}
        if(pDenominator<0){
            numerator = -pNumerator;
            denominator = -pDenominator;
        }
        if(pDenominator == 0){
            denominator = 1;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    @Override
    public double toDouble(int numerator, int denominator) {
        double fraction = numerator / denominator;
        return fraction;
    }

    /**
     * Ueberschreibt die toString-Methode und gibt einen String im Format
     * ""Zaehler/Nenner = Kommazahl"" zurueck.
     */
    public String toString(double fraction) {
        String kommazahl = Double.toString(fraction);
        return numerator + ""/"" + denominator + "" = "" + kommazahl;
    }

    /**
     * Gibt den groessten gemeinsamen Teiler (Greatest Common Divider) zurueck.
     */
    public static int GCD(int x, int y) {
        if (y == 0) {
            return x;
        }
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache (Lowest Common Multiple) zurueck.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void cancel() {
        int factorC = GCD(numerator, denominator);
        numerator = numerator/factorC;
        denominator = denominator/factorC;
    }

    /**
     * Erweitert, macht gleichnamig, addiert den uebergebenen Bruch und kuerzt.
     */
    public void add(Fraction f) {
        numerator = numerator * f.denominator + f.numerator * denominator;
        denominator = denominator * f.denominator;
        cancel();
    }

    /**
     * Multipliziert den uebergebenen Bruch und kuerzt.
     */
    public void multiply(Fraction f) {
        numerator = numerator * f.numerator;
        denominator = denominator * f.denominator;
        cancel();
    }

    /**
     * Bildet den Kehrwert und kuerzt, wenn der Zaehler ungleich Null ist.
     * Stellt dabei sicher, dass negative Vorzeichen nur im Zaehler auftreten.
     */
    public void reciprocal() {
        if(denominator<0){
            numerator = -numerator;
            denominator = -denominator;
        }
        if(denominator != 0){
            int newNumerator = numerator;
            int newDenominator = denominator;
            numerator = newDenominator;
            denominator = newNumerator;
            cancel();
        }
    }
   
    /**
     * Dividiert den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public void divide(Fraction f) {
        numerator = numerator * f.denominator;
        denominator = denominator * f.numerator;
        cancel();
    }",-
Pürschel,"Kanta Fabian",k.puerschel@campus.tu-berlin.de,Beendet,"20. Juni 2021  20:48","20. Juni 2021  23:59","3 Stunden 10 Minuten","17,82","Setter-Methoden haben in der Regel den Rückgabetyp void","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","static
; private
; void","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: m; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
          this.denominator = 1;
          this.numerator = numerator;
        } else if (denominator < 0) {
          this.denominator = -1 * denominator;
          this.numerator = -1 * numerator;
        } else {
          this.denominator = denominator;
          this.numerator = numerator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double output = (double)this.numerator / this.denominator;
        return output;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String output = this.numerator + ""/"" + this.denominator;
        return output;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        while (gcd != 1) {
          this.numerator /= gcd;
          this.denominator /= gcd;
          gcd = GCD(numerator, denominator);
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(this.denominator, f.denominator);
        int difA = lcm / this.denominator;
        int difB = lcm / f.denominator;
        int newNumerator = (this.numerator * difA) + (f.numerator * difB);
        int newDenominator = lcm;
        Fraction sum = new Fraction(newNumerator, newDenominator);
        return sum;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = this.numerator * f.numerator;
        int newDenominator = this.denominator * f.denominator;
        Fraction product = new Fraction(newNumerator, newDenominator);
        return product;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
      int newNumerator, newDenominator;
      if (this.numerator == 0) {
        newNumerator = this.numerator;
        newDenominator = this.denominator;
      } else if (this.numerator < 0) {
        newNumerator = -1 * this.denominator;
        newDenominator = -1 * this.numerator;
      } else {
        newNumerator = this.denominator;
        newDenominator = this.numerator;
      }
      Fraction reciprocal = new Fraction(newNumerator, newDenominator);
      return reciprocal;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
      return this.multiply(f.reciprocal());
    }

}","public class SubwayTest {
  public static void main(String[] args) {
    Subway a = new Subway(3);
    Wagen a1 = new Wagen(20, 30);
    Wagen a2 = new Wagen(15, 25);
    a.addWagen(a1);
    a.addWagen(a2);
    System.out.println(a.getSeats());
    System.out.println(a.getStandingRoom());
    System.out.println(a.getCapacity());
    Wagen a3 = new Wagen(10, 20);
    Wagen a4 = new Wagen(5, 15);
    a.addWagen(a3);
    a.addWagen(a4);
    a.removeWagen();
    a.removeWagen();
    a.removeWagen();
    a.removeWagen();
    a.removeWagen();
  }
}"
Ismailoglu,Ece,e.ismailoglu@campus.tu-berlin.de,Beendet,"20. Juni 2021  21:04","20. Juni 2021  23:59","2 Stunden 54 Minuten","5,83","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","private
; void","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
Czekanski,"Julian Michael",j.czekanski@campus.tu-berlin.de,Beendet,"20. Juni 2021  21:10","20. Juni 2021  23:00","1 Stunde 49 Minuten","19,57","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: Adresse 50; Teil 40: Adresse 51; Teil 41: Adresse 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: Adresse 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: Adresse 50; Teil 89: Adresse 51; Teil 90: Adresse 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: Adresse 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    	this.numerator = numerator;
    	if (denominator < 0) {
    		this.numerator *= (-1);
    		this.denominator = denominator * (-1);
    	} else if (denominator == 0) {
    		this.denominator = 1;
    	} else {
    		this.denominator = denominator;
    	}
    	this.shorten();
    	
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / (double) this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt = Fraction.GCD(this.numerator, this.denominator);
        this.numerator /= ggt;
        this.denominator /= ggt;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int kgv = Fraction.LCM(this.denominator, f.getDenominator());
       return new Fraction(this.numerator*(kgv/this.denominator) + 
    		   f.getNumerator()*(kgv/f.getDenominator()), kgv);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.numerator*f.getNumerator(), this.denominator*f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0) {
    	   return new Fraction(this.numerator, this.denominator);
       } else {
    	   return new Fraction(this.denominator, this.numerator);
       }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }
}","public class SubwayTest{
	public static void main (String[] args){
		Subway U1 = new Subway(3);
		Wagen w1 = new Wagen(30, 60);
		Wagen w2 = new Wagen(40, 50);
		U1.addWagen(w1);
		U1.addWagen(w2);
		System.out.println(U1.getSeats());
		System.out.println(U1.getStandingRoom());
		System.out.println(U1.getCapacity());
		Wagen w3 = new Wagen(15, 30);
		Wagen w4 = new Wagen(40, 60);
		U1.addWagen(w3);
		U1.addWagen(w4);
		U1.removeWagen();
		U1.removeWagen();
		U1.removeWagen();
		U1.removeWagen();
		U1.removeWagen();
	}
}"
Nasralla,"Kerolus Nasser Nagi",k.nasralla@campus.tu-berlin.de,Beendet,"20. Juni 2021  21:50","20. Juni 2021  23:59","2 Stunden 8 Minuten","5,83","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","private
; void","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
       return (double) this.doubleValue();
        double fraction = numerator / denominator;
        return fraction;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return String numerator/denominator;
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
         int factorC = GCD(numerator, denominator);
        numerator = numerator/factorC;
        denominator = denominator/factorC;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        numerator = numerator * f.denominator + f.numerator * denominator;
        denominator = denominator * f.denominator;
        cancel();
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
         public static int LCM(int x, int y) {
             numerator = numerator * f.numerator;
        denominator = denominator * f.denominator;
        cancel();
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        
    return system.print.outln;
    }
    
}",-
Fulful,"Abd Alrahman",a.fulful@campus.tu-berlin.de,Beendet,"20. Juni 2021  23:12","20. Juni 2021  23:59","46 Minuten 53 Sekunden","1,14","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Verhindern, dass Attributswerte gesetzt werden","abstrakte Methoden",class,"In Objektmethoden können lokale Variablen deklariert werden","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: %; Teil 2: %; Teil 3: %; Teil 4: %; Teil 5: %; Teil 6: %; Teil 7: 11; Teil 8: %; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 15; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 16; Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 17; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 18; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 19; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 10; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 11; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 12; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 13; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 14; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 15; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 16; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
