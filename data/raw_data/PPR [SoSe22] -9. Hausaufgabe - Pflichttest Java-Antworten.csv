Nachname,Vorname,E-Mail-Adresse,Status,"Begonnen am",Beendet,"Verbrauchte Zeit","Bewertung/15,00","Antwort 1","Antwort 2","Antwort 3","Antwort 4","Antwort 5","Antwort 6","Antwort 7","Antwort 8","Antwort 9"
Reckermann,Hauke,hauke.reckermann@campus.tu-berlin.de,Beendet,"16. Juni 2022  16:02","21. Juni 2022  15:25","4 Tage 23 Stunden","14,75","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","private
; void
; static","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		if(denominator<0){
			this.denominator = denominator*-1;
			this.numerator *= -1;
		} else if(denominator==0){
			this.denominator = 1;
		} else {this.denominator = denominator;}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return((double)this.numerator/this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return(this.numerator+""/""+this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator/gcd;
		this.denominator = this.denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       //LCM und Erweiterungsfaktoren ermitteln
	   int lcm = LCM(this.denominator, f.getDenominator());
	   int factorA = lcm/this.denominator;
	   int factorB = lcm/f.getDenominator();
	   
	   //parallel erweitern und addieren
	   int newNumerator = (this.numerator*factorA) + (f.getNumerator()*factorB);
	   int newDenominator = this.denominator * factorA;
	   
	   Fraction result = new Fraction(newNumerator, newDenominator);
	   
	   return result;
	   
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
		Fraction result = new Fraction((this.numerator * f.getNumerator()),this.denominator * f.getDenominator());
		
		return result;
		
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
	   Fraction result;
	   
	   if(this.numerator!=0){
		   result = new Fraction(this.denominator, this.numerator);
		   return result;
	   } else{
		   result = new Fraction(this.numerator, this.denominator);
		   return result;
	   }
	   
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction f_rec = f.reciprocal();
	   Fraction result = f_rec.multiply(this);
	   return result;
    }
    
}"
Gottschalk,"Moritz Jaap-Vincent",m.gottschalk@campus.tu-berlin.de,Beendet,"17. Juni 2022  12:44","26. Juni 2022  17:01","9 Tage 4 Stunden","13,58","Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Objektmethoden modellieren das Verhalten von Objekten","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","void
; static
; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		
		if (this.denominator == 0) this.denominator = 1;
		if (this.denominator < 0){
			this.denominator = -this.denominator;
			this.numerator = -this.numerator;
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double d1 = numerator;
		double d2 = denominator;
		return d1/d2;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		return (numerator+""/""+denominator);
	}

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int faktor = GCD(numerator, denominator);
		denominator = denominator / faktor;
		numerator = numerator / faktor;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		Fraction a= new Fraction(numerator*f.denominator+denominator*f.numerator, denominator*f.denominator);
		return a;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction m = new Fraction(numerator * f.numerator, denominator * f.denominator);
		return m;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction r = new Fraction(numerator, denominator);
		if (r.numerator != 0){
			r.numerator = denominator;
			r.denominator = numerator;
			return r;
		}
		return r;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction d = new Fraction(numerator, denominator);
		d = d.multiply(f.reciprocal());
		return d;
    }
    
}"
Kötschau,"Johann Magnus",johann-magnus.koetschau@campus.tu-berlin.de,Beendet,"18. Juni 2022  09:00","26. Juni 2022  10:00","8 Tage","13,25","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","private
; void","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""(15)3"","""","""","""",""l"",""m"",""r""],[""(15)4"",""1"","""","""","""","""",""""],[""(15)5"","""","""",""0"","""","""",""""],[""(15)6"","""",""0"","""","""",""l"",""""],[""15"","""","""","""",""-"",""-"",""-""],[""16"","""","""","""","""","""",""""],[""(17)3"","""","""","""",""l"",""l"",""r""],[""(17)4"",""0"","""","""","""","""",""""],[""(17)5"","""","""","""","""","""",""""],[""(17)6"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction{

        private int numerator, denominator;

        /**
         * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
         */
        public static int GCD(int x, int y) {
            if (y == 0) return x;
            return GCD(y, x % y);
        }

        /**
         * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
         */
        public static int LCM(int x, int y) {
            return (x * y) / GCD(x, y);
        }
        //Beginn der Aufgabe
        /**
         * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
         * uebergeben bekommt und die entsprechenden Attribute setzt.
         * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
         * auftreten (nicht im ""denominator""-Attribut).
         * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
         * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
         * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
         * und der Wert des Bruchs (die Argumente) unverändert bleibt
         * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
         * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
         * auf Eins gesetzt.
         * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
         */
        public Fraction(int numerator, int denominator) {
            if (denominator<0){
                    this.numerator=-numerator;
                    this.denominator=-denominator;
                }
            else if (denominator==0){
                this.denominator=1;
                this.numerator=numerator;

                }
            else{
                this.numerator=numerator;
                this.denominator=denominator;
            }

            this.shorten();

        }

        /**
         * Gibt den Nenner zurueck.
         */
        public int getDenominator() {
            return this.denominator;
        }

        /**
         * Gibt den Zaehler zurueck.
         */
        public int getNumerator() {
            return this.numerator;
        }

        /**
         * Gibt den Bruch als Gleitkommazahl zurueck.
         */
        public double toDouble() {
            return (double)this.numerator/(double)this.denominator;
        }

        /**
         * Gibt einen String im Format
         * ""Zaehler/Nenner"" zurueck.
         */
        public String toString() {
            String Ausgabe=this.numerator+""/""+denominator;
            return Ausgabe;
        }

        /**
         * Kuerzt (vereinfacht) den Bruch.
         */
         public void shorten() {
            if (this.numerator<0){
                int GCD=GCD(-this.numerator,this.denominator);
                this.numerator=this.numerator/GCD;

                this.denominator=this.denominator/GCD;
            }
            else{
                int GCD=GCD(this.numerator,this.denominator);
                this.numerator=this.numerator/GCD;

                this.denominator=this.denominator/GCD;

            }
        }

        /**
         * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
         */
        public Fraction add(Fraction f) {
            int x=LCM(this.denominator,f.denominator);
            int Zähler=this.numerator*(x/this.denominator)+f.numerator*(x/f.denominator);
            int Nenner=x;
            Fraction Ausgabe=new Fraction(Zähler,Nenner);
            return Ausgabe;

        }

        /**
         * Multipliziert mit dem uebergebenen Bruch.
         */
        public Fraction multiply(Fraction f) {
            int Zähler=this.numerator*f.numerator;
            int Nenner=this.denominator*f.denominator;
            Fraction Ausgabe=new Fraction(Zähler,Nenner);
            return Ausgabe;

        }

        /**
         * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
         * Sonst wird der Bruch unveraendert zurueckgegeben.
         */
        public Fraction reciprocal() {
            int Zähler;
            int Nenner;
            if (this.numerator!=0){
                Zähler=this.denominator;
                 Nenner=this.numerator;
            }
            else{
                 Zähler=this.numerator;
                Nenner=this.denominator;
            }
        Fraction Ausgabe=new Fraction(Zähler,Nenner);
            return Ausgabe;
        }

        /**
         * Dividiert durch den uebergebenen Bruch
         * (unter Verwendung von Kehrwert und Multiplikation).
         */
        public Fraction divide(Fraction f) {
            return this.multiply(f.reciprocal());
        }

    }"
Özmen,"Fevzi Alperen",f.oezmen@campus.tu-berlin.de,Beendet,"19. Juni 2022  13:28","26. Juni 2022  23:59","7 Tage 10 Stunden","10,67","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Setzen falscher Attributwerte verhindern

; Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter und Setter","static
; void
; private","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""3"",""undef"","""",""undef"","""","""",""""],[""4"",""undef"","""","""","""","""",""""],[""5"","""",""undef"","""","""",""undef"",""""],[""6"","""","""","""","""","""",""""],["""","""","""","""","""","""",""undef""],[""11"","""","""","""","""","""",""undef""],[""12"","""","""","""",""undef"","""",""""],[""13"","""","""","""",""undef"","""",""""],[""14"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(denominator==0){
            denominator = 1;
        }

        if(denominator<0){

            this.numerator = numerator*-1;
            this.denominator = denominator*-1;

        }else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {

        this.shorten();
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {

        this.shorten();
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {

        return ((double) this.numerator)/(double)this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {

        return """"+this.numerator+""/""+this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {

        int gdc = GCD(this.numerator, this.denominator);

        if(gdc!=0){

            this.numerator = this.numerator/gdc;
            this.denominator = this.denominator/gdc;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {

        if(this.denominator!=f.getDenominator()){
            this.numerator = this.numerator*(LCM(this.denominator,f.denominator)/this.denominator);
            this.denominator = LCM(this.denominator,f.denominator);
            f.numerator = f.numerator*(LCM(this.denominator,f.denominator)/f.denominator);
            f.denominator = LCM(this.denominator,f.denominator);
        }

        Fraction addition = new Fraction(this.numerator + f.numerator, this.denominator);

        addition.shorten();

        return addition;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

        Fraction multiply = new Fraction(this.numerator*f.getNumerator(), this.denominator*f.getDenominator());

        multiply.shorten();

        return multiply;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {

        if(this.numerator==0){
            return new Fraction(this.numerator, this.denominator);
        }

        if(this.denominator==0){
            Fraction f = new Fraction(this.denominator, this.numerator);
            f.denominator = 0;
            return f;

        }

        return new Fraction(this.denominator, this.numerator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {

        Fraction divide = this.multiply(new Fraction(f.denominator, f.numerator));

        divide.shorten();

        return divide;
    }
}"
Baba,Yaser,yaser.baba@campus.tu-berlin.de,Beendet,"19. Juni 2022  21:50","26. Juni 2022  19:56","6 Tage 22 Stunden","9,96","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Getter und Setter","private
; static
; void","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""",""1"","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""1""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"","""",""-""]]","public class Fraction {

    public int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		
		this.numerator = numerator;
		this.denominator = denominator;
		
		if(denominator < 0) {
		   numerator = -numerator;
		   denominator = -denominator;
		}
	
		if(denominator == 0) {
		   denominator = 1;
		}
        
	    shorten();	

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		
		double fraction = (double)numerator / (double)denominator;
		
        return fraction;
    }

    
    

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
	
	   return numerator + ""/"" + denominator;    
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int x = GCD(numerator, denominator);
        numerator = numerator / x;
        denominator = denominator / x;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
	 


	 
    public Fraction add(Fraction f) {
	
		return new Fraction(f.denominator * numerator + f.numerator * denominator, f.denominator * denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */

	public Fraction multiply(Fraction f) {
		
		return new Fraction(f.numerator * numerator, f.denominator * denominator);  
    }


    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
	 

	public Fraction reciprocal() {
        
		if(numerator == 0) 
			
		return this;
		
        return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
	 

	public Fraction divide(Fraction f) {
		
        return new Fraction(f.denominator * numerator, f.numerator * denominator);
    }

}"
Kocak,Soner,soner.kocak@campus.tu-berlin.de,Beendet,"19. Juni 2022  21:55","26. Juni 2022  23:59","7 Tage 2 Stunden","0,00",-,"class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}",-,-,-,-,"Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8:",-,-
Yilmaz,Cem,cem.yilmaz.1@campus.tu-berlin.de,Beendet,"20. Juni 2022  00:03","26. Juni 2022  23:59","6 Tage 23 Stunden","13,08","Getter und Setter","Setter-Methoden haben in der Regel den Rückgabetyp void","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden können überladen werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}


public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","static
; void
; private","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""",""50"","""",""""],[""12"","""",""0"","""","""",""51"",""""],[""13"","""","""",""1"","""","""",""52""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""",""52"","""",""""],[""5(15)"","""","""",""0"","""","""",""51""],[""6(15)"","""",""0"","""","""",""51"",""""],[""7(15)"",""-"",""-"",""-"","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"",""1"",""0"",""0"","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""",""51"","""",""""],[""5(17)"","""","""",""0"","""","""",""51""],[""6(17)"","""",""1"","""","""",""52"",""""],[""7(17)"",""-"",""-"",""-"","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"",""0"",""1"",""0"","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
	private double bruch;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
 
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	 
    public Fraction(int numerator, int denominator) {
		
		if(denominator<0){
			denominator=0-denominator;
			numerator=0-numerator;
		}
		if(denominator==0){
			denominator=1;	
		}
		this.numerator=numerator;
		this.denominator=denominator;
		shorten();
        
		
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return this.numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double bruch=getNumerator()/(double)getDenominator();
		
        return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		String a=numerator+"""";
		String b=denominator+"""";
		//String toString=numerator+""/""+denominator;
     return  a+""/""+b;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
	   int i=GCD(numerator,denominator);
		numerator=numerator/i;
		denominator=denominator/i; 
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		
    int z1=this.numerator *f.denominator;
	int z2=this.denominator*f.numerator;
	
	int denominator1= this.denominator*f.denominator;
	return new Fraction(z1+z2,denominator1);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int a= this.numerator*f.numerator;
		int b= this.denominator*f.denominator;
     return new Fraction(a,b);   
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal(){
		int m =getNumerator();
		int n =getDenominator();
		
		if(numerator!=0){
			
		m =getNumerator();
		n =getDenominator();	
		return new Fraction(n,m);
		}
	return new Fraction(m,n);
	
	}
  
  
  
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		int h=this.numerator*f.denominator;
		int p=this.denominator*f.numerator;
		
      return new Fraction(h,p); 
    }
    
}"
Asad,Hamza,hamza.asad@campus.tu-berlin.de,Beendet,"20. Juni 2022  00:09","26. Juni 2022  23:43","6 Tage 23 Stunden","13,92","void
; private
; static","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Verhindern, dass Attributswerte gesetzt werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""1"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""",""0"","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe 
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
       
        if(denominator<0){
            this.numerator = -numerator;
            this.denominator = -denominator;
        }
        if(denominator == 0){
            this.denominator = 1;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double fraction = (double)numerator / denominator;
        return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String fraction = numerator + ""/"" + denominator;
        return fraction;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int factorC = GCD(numerator, denominator);
        numerator = numerator/factorC;
        denominator = denominator/factorC;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        return new Fraction(numerator * f.denominator + denominator * f.numerator, denominator * f.denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator * f.numerator, denominator * f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(numerator == 0) return this;

        return new Fraction(denominator,numerator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return multiply(f.reciprocal());
    }
}"
Shehata,Shady,shady.shehata@campus.tu-berlin.de,Beendet,"20. Juni 2022  00:45","27. Juni 2022  00:00","6 Tage 23 Stunden","10,77","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","static
; void
; private","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern, dass Attributswerte gesetzt werden","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden modellieren das Verhalten von Objekten","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Getter und Setter","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""",""0"","""",""""],[""12"","""",""0"","""","""",""0"",""""],[""13"","""","""",""1"","""","""",""1""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""",""1"","""",""""],[""5(15)"","""","""",""0"","""","""",""0""],[""6(15)"","""",""1"","""","""",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""",""0"","""",""""],[""5(17)"","""","""",""1"","""","""",""1""],[""6(17)"","""",""0"","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    public int n = numerator;
	public int d = denominator;
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
        if(denominator == 0){
            this.denominator = 1;
        }
        if(denominator<0){
            this.numerator = -numerator;
            this.denominator = -denominator;
        }
    this.shorten(); 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double fraction = (double) numerator / (double) denominator;
        return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String fraction = numerator + ""/"" + denominator;
        return fraction;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int g = GCD(numerator, denominator);
        denominator = denominator/g;
        numerator = numerator/g;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int n = numerator * f.denominator + f.numerator * denominator;
        int d = denominator * f.denominator;
        Fraction sum = new Fraction(n, d);
        sum.shorten();
        return sum;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int n = numerator * f.numerator;
		int d = denominator * f.denominator;
        return new Fraction(n, d);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(n == 0) {
            return new Fraction(n, d);
        } else {
            return new Fraction(d, n);
        }
    }

   
    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        int n = numerator * f.denominator;
        int d = denominator * f.numerator;
        Fraction quotient = new Fraction(n, d);
        quotient.shorten();
        return quotient;
    }
   
}"
Türk,Gökcenur,g.tuerk@campus.tu-berlin.de,Beendet,"20. Juni 2022  01:39","26. Juni 2022  22:19","6 Tage 20 Stunden","13,08","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","static
; void
; private","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Verhindern, dass Attributswerte gesetzt werden

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""",""0"",""1 "",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"",""0"",""1"",""0"","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""1""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"",""0"",""0"",""1"","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {
  private int numerator, denominator;

  public static int GCD(int x, int y) {
    if(y == 0) return x;
    return GCD(y, x % y);
  }

  public static int LCM(int x, int y) {
    return (x * y) / GCD(x, y);
  }

  public Fraction(int numerator, int denominator) {
    if(denominator == 0) {
      this.numerator = numerator;
      this.denominator = 1;
    }
    else if(denominator < 0) {
      this.numerator = -numerator;
      this.denominator = -denominator;
    }
    else {
      this.numerator = numerator;
      this.denominator = denominator;
    }
    shorten();
  }

  public int getNumerator() {
    return numerator;
  }

  public int getDenominator() {
    return denominator;
  }

  public double toDouble() {
    return ((double) getNumerator()) / ((double) getDenominator());
  }

  public String toString() {
    return String.format(""%d/%d"", getNumerator(), getDenominator());
  }

  public void shorten() {
    int divisor = GCD(getNumerator(), getDenominator());
    if(getNumerator() < 0) {
      divisor = GCD(-getNumerator(), getDenominator());
    }
    numerator /= divisor;
    denominator /= divisor;
  }

  public Fraction add(Fraction f) {
    int x1 = getNumerator(), x2 = f.getNumerator();
    int y1 = getDenominator(), y2 = f.getDenominator();
    return new Fraction(((x1*y2)+(y1*x2)), (y1*y2));
  }

  public Fraction multiply(Fraction f) {
    int x = getNumerator() * f.getNumerator();
    int y = getDenominator() * f.getDenominator();
    return new Fraction(x, y);
  }

  public Fraction reciprocal() {
    int x = getNumerator();
    int y = getDenominator();
    if(getNumerator() != 0) {
      x = getDenominator();
      y = getNumerator();
    }
    return new Fraction(x, y);
  }

  public Fraction divide(Fraction f) {
    return multiply(f.reciprocal());
  }
}"
Krüger,"Finn Johann",finn.johann.krueger@campus.tu-berlin.de,Beendet,"20. Juni 2022  08:39","26. Juni 2022  20:18","6 Tage 11 Stunden","13,75","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","static
; void
; private","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(numerator >= 0 && denominator > 0 || numerator < 0 && denominator > 0) {
          this.numerator = numerator;
          this.denominator = denominator;

        } else if(numerator >= 0 && denominator < 0 || numerator < 0 && denominator < 0) {
          this.numerator = (-1)*numerator;
          this.denominator = (-1)*denominator;
        } else if (denominator == 0) {
          this.numerator = numerator;
          this.denominator = 1;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {

      return this.denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {

      return this.numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {

      return (double)this.numerator/(double)this.denominator;

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {

      return this.numerator + ""/"" + this.denominator;

    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {

      int i = GCD(this.numerator, this.denominator);
      this.numerator /= i;
      this.denominator /= i;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {

      int i = LCM(this.denominator, f.getDenominator());
      Fraction added_frac = new Fraction(i/this.denominator*this.numerator+i/f.denominator*f.numerator, i);
      added_frac.shorten();
      return added_frac;

     }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

      Fraction multiplied_frac = new Fraction(this.numerator*f.numerator, this.denominator*f.denominator);
      multiplied_frac.shorten();
      return multiplied_frac;

    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
     public Fraction reciprocal() {

       int num = this.getNumerator();
       int denom = this.getDenominator();
       Fraction reci_frac;
       if (num != 0) {
         reci_frac = new Fraction(denom, num);
       } else {
         reci_frac = new Fraction(num, denom);
       }
       reci_frac.shorten();
       return reci_frac;

     }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {

      f = f.reciprocal();
      Fraction div_frac = this.multiply(f);
      div_frac.shorten();
      return div_frac;



    }

}"
"Saa Hinojosa","Paola Carolina",p.saahinojosa@campus.tu-berlin.de,Beendet,"20. Juni 2022  11:07","26. Juni 2022  23:59","6 Tage 12 Stunden","6,50","static
; private","Getter und Setter","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""51""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Neumann,Christopher,christopher.neumann@campus.tu-berlin.de,Beendet,"20. Juni 2022  12:41","24. Juni 2022  16:45","4 Tage 4 Stunden","8,58","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","static
; private
; void","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {
    private int numerator, denominator;
    
    public static int GCD(int x, int y) { // Gibt den größten gemeinsamen Teiler der beiden Argumente zurück.
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) { //Gibt das kleinste gemeinsame Vielfache der beiden Argumente zurück.
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if(numerator > 0 && denominator < 0){
				this.numerator = numerator * (-1);
		}else{
			this.numerator = numerator;
		}
		if(denominator < 0){
			this.denominator = denominator * (-1);
		}else if(denominator == 0){
			this.denominator = 1;
		}else{
			this.denominator = denominator;
		}
		shorten();
    }

    public int getDenominator() { // Gibt den Nenner zurueck
        return denominator;
    }

    public int getNumerator() { //Gibbt den Zaehler zurueck
        return numerator;
    }

    
    public double toDouble() { //gibt den Bruch als Gleitkommazahl zurueck
		double double1 = (double) numerator;
		double double2 = (double) denominator;
		double myDouble = double1/double2;
		return myDouble;
    }
	
    public String toString() { // Gibt einen String im Format ""Zaehler/Nenner"" zurueck.
        String x = (numerator + ""/"" + denominator);
		return x;
    }
   
	
    public void shorten() { // Kuerzt (verneinfacht) den Bruch.
		this.numerator = numerator/GCD(numerator, denominator);
		this.denominator = denominator/GCD(numerator,denominator);
    }

    /*
    public Fraction add(Fraction f) { // Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
       
    }

    public Fraction multiply(Fraction f) { // Multipliziert mit dem uebergebenen Bruch.
        
    }
	 
    public Fraction reciprocal() { // Bildet den Kehrwert, wenn der Zaehler ungleich Null ist. Sonst wird der Bruch unveraendert zurueckgegeben.
       int a = numerator;
	   numerator = denominator;
	   denominator = a;
	   toString();
	   return x;
	   
    }
    
    public Fraction divide(Fraction f) { // Dividiert durch den uebergebenen Bruch (unter Verwendung von Kehrwert und Multiplikation).
       
    }
	*/
    
}"
Matheson,Piers,piers.matheson@campus.tu-berlin.de,Beendet,"20. Juni 2022  16:53","26. Juni 2022  19:16","6 Tage 2 Stunden","3,92","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","void
; private
; static","Getter und Setter","Zugriff auf private Attribute ermöglichen","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private",-,"public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Duryn,"Jonas Manuel",jonas.duryn@campus.tu-berlin.de,Beendet,"20. Juni 2022  18:42","20. Juni 2022  20:03","1 Stunde 21 Minuten","14,58","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Getter und Setter","void
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		if(denominator == 0) {
			this.denominator = 1;
		} else if(denominator < 0) {
			this.numerator *= (-1);
			this.denominator = (-1) * denominator;
		} else {
			this.denominator = denominator;
		}
		this.shorten();
    }

    public int getDenominator() {
        return this.denominator;
    }

    public int getNumerator() {
        return this.numerator;
    }

    public double toDouble() {
        return (double)((double)this.numerator / (double)this.denominator);
    }

    public String toString() {
        return new String(numerator+""/""+denominator);
    }

    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		this.numerator /= Math.abs(gcd);
		this.denominator /= Math.abs(gcd);
    }

    public Fraction add(Fraction f) {
		int denominatorF = f.getDenominator();
		int lcm = LCM(this.denominator, denominatorF);
		int newNumerator = this.numerator * (lcm / this.denominator) + f.getNumerator() * (lcm / denominatorF);
		return new Fraction(newNumerator, lcm);
    }

    public Fraction multiply(Fraction f) {
        return new Fraction((this.numerator * f.getNumerator()), (this.denominator * f.getDenominator()));
    }

    public Fraction reciprocal() {
       if (this.numerator == 0) {
		   return new Fraction(this.numerator, this.denominator);
	   } else {
		   return new Fraction(this.denominator, this.numerator);
	   }
    }
    
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }
}"
Mengi,Berna,berna.mengi@campus.tu-berlin.de,Beendet,"20. Juni 2022  18:58","26. Juni 2022  18:01","5 Tage 23 Stunden","11,83","void
; static
; private","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Getter und Setter","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""1""],[""5(15)"","""","""","""","""",""0"",""0""],[""6(15)"","""","""","""",""0"",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {
  private int numerator, denominator;

  public static int GCD(int x, int y) {
    if(y == 0) return x;
    return GCD(y, x % y);
  }

  public static int LCM(int x, int y) {
    return (x * y) / GCD(x, y);
  }

  public Fraction(int numerator, int denominator) {
    if(denominator == 0) {
      this.numerator = numerator;
      this.denominator = 1;
    }
    else if(denominator < 0) {
      this.numerator = -numerator;
      this.denominator = -denominator;
    }
    else {
      this.numerator = numerator;
      this.denominator = denominator;
    }
    shorten();
  }

  public int getNumerator() {
    return numerator;
  }

  public int getDenominator() {
    return denominator;
  }

  public double toDouble() {
    return ((double) getNumerator()) / ((double) getDenominator());
  }

  public String toString() {
    return String.format(""%d/%d"", getNumerator(), getDenominator());
  }

  public void shorten() {
    int divisor = GCD(getNumerator(), getDenominator());
    if(getNumerator() < 0) {
      divisor = GCD(-getNumerator(), getDenominator());
    }
    numerator /= divisor;
    denominator /= divisor;
  }

  public Fraction add(Fraction f) {
    int x1 = getNumerator(), x2 = f.getNumerator();
    int y1 = getDenominator(), y2 = f.getDenominator();
    return new Fraction(((x1*y2)+(y1*x2)), (y1*y2));
  }

  public Fraction multiply(Fraction f) {
    int x = getNumerator() * f.getNumerator();
    int y = getDenominator() * f.getDenominator();
    return new Fraction(x, y);
  }

  public Fraction reciprocal() {
    int x = getNumerator();
    int y = getDenominator();
    if(getNumerator() != 0) {
      x = getDenominator();
      y = getNumerator();
    }
    return new Fraction(x, y);
  }

  public Fraction divide(Fraction f) {
    return multiply(f.reciprocal());
  }
}"
Lemanczyk,"Maksymilian Karol",m.lemanczyk@campus.tu-berlin.de,Beendet,"21. Juni 2022  12:11","24. Juni 2022  13:54","3 Tage 1 Stunde","14,25","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","void
; private","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"","""",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""",""0"",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {
    private int numerator, denominator;
    
     // Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

     // Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    
 //Beginn der Aufgabe  
    /*
 jeder Bruchch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    	if (denominator>0) {
    		this.denominator=denominator;
    		this.numerator=numerator;
    	}
    	if (denominator==0) {
    		this.denominator=0;
    		this.numerator=numerator;
    	}
    	if (denominator<0) {
    		this.denominator=(-1*denominator);
    		this.numerator=(-1*numerator);
    	}
    	shorten();
    	
    }

    //Holt sich den Nenner
    public int getDenominator() {
        return denominator;
    }

    //Holt sich den Zähler
    public int getNumerator() {
        return numerator;
    }

    //Konvertiert in einen Dezimalbruch
    public double toDouble() {
        return (double)numerator/(double)denominator;
    }
    
    //Erstellt nen String
    public String toString() {
        String a =(numerator+""/""+denominator);
        return a;
    }

    //Kürzt den Bruch
    public void shorten() {
    	int alt = numerator;
    	numerator=numerator/GCD(Math.abs(numerator),Math.abs(denominator));
    	denominator=denominator/GCD(Math.abs(alt),Math.abs(denominator));
    }
    
    //Addiert zwei Brüche
    public Fraction add(Fraction f) {
       Fraction res = new Fraction ((numerator*f.denominator)+(f.numerator*denominator),(denominator*f.denominator)); 
       res.shorten ();
       return res;
    }

    //Multipliziert zwei Brüche
    public Fraction multiply(Fraction f) {
    	Fraction res = new Fraction((numerator*f.numerator),(denominator*f.denominator));
    	res.shorten();
    	return res;
    }

    //Bildet den Kehrwert für Zähler ungleich 0
    public Fraction reciprocal() {
       if (numerator!=0) {
    	  Fraction res = new Fraction (denominator,numerator);
    	  return res;
       }else return this;   
    }
    
    //Dividiert durch den übergeben  Bruch
    public Fraction divide(Fraction f) {
       Fraction divi = f.reciprocal();
       Fraction res = this.multiply(divi);
    	return res;
    } 
}"
Puder,"Carolin-Antonia Heike",puder@campus.tu-berlin.de,Beendet,"21. Juni 2022  12:13","24. Juni 2022  17:01","3 Tage 4 Stunden","13,00","void
; static
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        	this.numerator = numerator;
        	this.denominator = denominator;
        	if(numerator<0) {
        		this.numerator = -numerator;
        		this.denominator = -denominator;
        		shorten();
        	}
        	if(denominator == 0) {
        		denominator += 1;
        	}
        	else {
        		this.numerator = numerator;
        		this.denominator = denominator;
        		shorten();
        	}
    }
    
    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        	if (denominator == 0){
        		denominator = 1;
        	}
        	return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        	return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(int numerator, int denominator) {
        	numerator = this.numerator;
       	denominator = this.denominator;
        	double fraction = (double)numerator/denominator;
        	return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        	return (numerator+""/""+denominator+""\n"");
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        	int shortFraction = GCD(numerator, denominator);
        	this.numerator = numerator/shortFraction;
        	this.denominator = denominator/shortFraction;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       		int n_numerator = this.numerator;
       		int n_denominator = this.denominator;
       	n_numerator = n_numerator * f.denominator + f.numerator * n_denominator;
        	n_denominator = n_denominator * f.denominator;
        	Fraction n = new Fraction (n_numerator, n_denominator);
       	n.shorten();
       		return n;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    		int n_numerator = this.numerator;
       		int n_denominator = this.denominator;
        	n_numerator = n_numerator * f.numerator;
        	n_denominator = n_denominator * f.denominator;
        	Fraction n = new Fraction (n_numerator, n_denominator);
        	n.shorten();
        	return n;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        	int n_numerator = this.numerator;
       		int n_denominator = this.denominator;
        	if(n_numerator != 0){
           	 	int neuNumerator = n_denominator;
            		int neuDenominator = n_numerator;
            	Fraction r = new Fraction (neuNumerator, neuDenominator);
            	r.shorten();
            		return r;
    		}
    		else {
    			Fraction r = new Fraction (n_numerator, n_denominator);
    			return r;
    		}
    	}
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       		int d_numerator = this.numerator;
       		int d_denominator = this.denominator;
       	d_numerator = d_numerator * f.denominator;
        	d_denominator = d_denominator * f.numerator;
        	Fraction d = new Fraction (d_numerator, d_denominator);
        	d.shorten();
        	return d;
    }
    
}"
Kahl,"Patrick Paul Tobias",p.kahl@campus.tu-berlin.de,Beendet,"21. Juni 2022  12:56","26. Juni 2022  23:53","5 Tage 10 Stunden","6,42","Verhindern das Überladen von Methoden
; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","void
; private","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: private; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""",""0"",""0"",""1""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Schümer,Paolo,paolo.schuemer@campus.tu-berlin.de,Beendet,"21. Juni 2022  13:16","26. Juni 2022  23:59","5 Tage 10 Stunden","4,33","static
; void
; private","Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: private; Teil 2: public; Teil 3: public; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"","""","""",""""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""1""],[""5(15)"","""","""","""","""",""0"",""0""],[""6(15)"","""","""","""","""",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17"","""","""","""",""0"","""",""0""],[""5(17)"","""","""","""","""",""1"",""1""],[""6(17)"","""","""","""","""",""1"",""""],[""7"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int zNumerator, int zDenominator) {

        if(pDenominator<0){
            numerator = -zNumerator;
            denominator = -zDenominator;
        }
        if(pDenominator == 0){
            denominator = 1;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return denominator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(int numerator, int denominator) {
        double fraction = numerator / denominator;
        return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator + "" = "" + fraction;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int factorC = GCD(numerator, denominator);
        numerator = numerator/factorC;
        denominator = denominator/factorC;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       numerator = numerator * f.denominator + f.numerator * denominator;
        denominator = denominator * f.denominator;
        cancel();
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        numerator = numerator * f.numerator;
        denominator = denominator * f.denominator;
        cancel();
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(denominator<0){
            numerator = -numerator;
            denominator = -denominator;
		}
		if(denominator != 0){
            int newNumerator = numerator;
            int newDenominator = denominator;
            numerator = newDenominator;
            denominator = newNumerator;
			cancel();
		}
		
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        numerator = numerator * f.denominator;
        denominator = denominator * f.numerator;
        cancel();
    }
    

}"
Macht,Isabella,i.macht@campus.tu-berlin.de,Beendet,"21. Juni 2022  14:12","26. Juni 2022  11:20","4 Tage 21 Stunden","13,70","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","void
; class
; private","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: private; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"","""",""""],[""4(15)"","""","""","""","""",""51"",""""],[""5(15)"","""","""","""","""","""",""52""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"","""",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"","""",""""],[""4(17)"","""","""","""","""",""51"",""""],[""5(17)"","""","""","""","""","""",""52""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            this.numerator = (numerator * (-1));
            this.denominator = denominator * (-1);
        } else if (denominator == 0) {
            this.numerator = numerator;
            this.denominator = 1;
        } else {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return numerator * 1.0 / denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return(Integer.toString(numerator) + ""/"" + Integer.toString(denominator));
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int numer = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
        int denr = denominator * f.getDenominator();
        return new Fraction(numer, denr);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = numerator * f.numerator;
        int newDenominator = denominator * f.denominator;
        return new Fraction(newNumerator, newDenominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0) {
            int kehr = numerator;
            numerator = denominator;
            denominator = kehr;
            return new Fraction(numerator, kehr);
        } else {
            return new Fraction(numerator, denominator);
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        /*Fraction reciprocal = reciprocal();
        Fraction newNumerator = reciprocal.multiply(f); */
        int newNumerator = numerator * f.getDenominator();
        int newDenominator = denominator * f.numerator;
        return new Fraction(newNumerator, newDenominator);
    }
    /*public static void main(String[] args) {
        Fraction f = new Fraction(2,0);
        System.out.println(f.getNumerator()+""/""+f.getDenominator());
    }*/
}"
Dorn,"Anton Fridolin",a.dorn@campus.tu-berlin.de,Beendet,"21. Juni 2022  15:45","26. Juni 2022  23:52","5 Tage 8 Stunden","9,42","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}",void,"In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        

        if(denominator == 0){
            this.numerator = numerator;
            this.denominator = 1;
            
        }
        else if(numerator == 0){
            this.numerator = 0;
            this.denominator = 1;
        }

        else if(denominator < 0){
            this.numerator = -1 * numerator;
            this.denominator = -1 * denominator;
            shorten();
            
        
        }else{
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(int numerator, int denominator) {

        double ausgabe = (double)(numerator/denominator);
        return ausgabe;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return getNumerator() + ""/"" + getDenominator();
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/ggt;
        this.denominator = this.denominator/ggt;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    /*public Fraction add(Fraction f) {
        /*Fraction a = new Fraction(numerator * (LCM(numerator, denominator)), denominator);
        Fraction b = new Fraction(f.numerator * (LCM(f.numerator, f.denominator)), f.denominator);
       return (a + b);*/

       /*Fraction c = new Fraction((f.denominator * numerator)/LCM(numerator, denominator), (denominator * f.numerator)/LCM(f.numerator, f.denominator));
       return c;*/

        //Fraction add = new Fraction(((LCM(thi, getDenominator())) * f.getDenominator() * getNumerator()) + ((LCM(f.getNumerator(), f.getDenominator())) * f.getNumerator() * getDenominator()), (LCM(getNumerator(), getDenominator())) * (LCM(f.getNumerator(), f.getDenominator())));
        //return add;
        //Fraction addi = new Fraction((f.getDenominator() * this.numerator + f.getNumerator() * this.denominator)/(LCM(this.denominator, f.getDenominator() )));
        //return addi;


   // }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction multi = new Fraction(f.getNumerator() * this.numerator, f.getDenominator() * this.denominator);
        return multi;

    }
    
    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    /*public Fraction reciprocal() {
        if(numerator != 0){
           Fraction rec = new Fraction(denominator, numerator);
           return rec;

        }else{
            Fraction norec = new Fraction(numerator, denominator);
            return norec;
        }

       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    /*public Fraction divide(Fraction f) {
        Fraction div = new Fraction(reciprocal.multiply(numerator, denominator));
        return div;
    }*/
}"
Hinrichs,"Sandra Maria",s.hinrichs@campus.tu-berlin.de,Beendet,"21. Juni 2022  16:46","25. Juni 2022  10:56","3 Tage 18 Stunden","5,42","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""17\n17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"",""-"",""-"",""-"",""-"",""-"",""-""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator<1) denominator * (-1);
		if (denominator == 0) denominator = 1;
		this.numerator = numerator;
		this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double Bruch = numerator/denominator;
        return Bruch;
		
		
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		
		String r = numerator/denominator;
		return r;
		
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int x = GCD(denominator, numerator)
		denominator = denominator/x;
		numerator = numerator/x;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		
		
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Paluch,"Maurice Jonathan Justin",m.paluch@campus.tu-berlin.de,Beendet,"21. Juni 2022  16:57","24. Juni 2022  14:15","2 Tage 21 Stunden","14,25","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","void
; private","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"","""",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        	if(denominator<=0) {
        		if(denominator==0) denominator=1;
        		if(denominator<0) {
        			denominator *= -1;
        			numerator *= -1;
        		}
        	}
        	 this.numerator = numerator;
             this.denominator = denominator;
             shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/(double)denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (numerator +""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(numerator, denominator);
        numerator /= teiler;
        denominator /= teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    	Fraction b= new Fraction(f.numerator*denominator+numerator*f.denominator, f.denominator*denominator);
    	b.shorten();
    	return b;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    	Fraction b= new Fraction(f.numerator,f.denominator);
    	b.numerator *= numerator;
    	b.denominator *= denominator;
    	b.shorten();
        return b;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	if(numerator != 0) {
    		int newnum = denominator;
    		int newdenom = numerator;
    		Fraction f = new Fraction(newnum, newdenom);
    		return f;
    	}
    	return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	Fraction c= new Fraction(f.numerator,f.denominator);
    	Fraction b= new Fraction(numerator,denominator);
    	b.numerator *= c.denominator;
    	b.denominator *= c.numerator;
    	b.shorten();  	
    	return b;
    }
    
}"
Schäfer,"Julia Désirée",julia.d.schaefer@campus.tu-berlin.de,Beendet,"22. Juni 2022  11:04","22. Juni 2022  16:33","5 Stunden 28 Minuten","13,00","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Setzen falscher Attributwerte verhindern

; Verhindern das Überladen von Methoden
; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","private
; void","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""",""1"","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if(denominator <= 0) {
          if (denominator == 0) {
            this.denominator = 1;
          } else {
            this.denominator = -denominator;
            this.numerator = -numerator;
          }
        } else {
          this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
      return (double) this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
      String geteilt = ""/"";
      return this.numerator + geteilt + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
      int ggT = GCD(numerator, denominator);
      this.numerator = numerator/ggT;
      this.denominator = denominator/ggT;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
      int a = LCM(this.denominator, f.denominator);
      int b = a/this.denominator * this.numerator;
      int c = a/f.denominator * f.numerator;
      Fraction added = new Fraction(b + c, a);
      return added;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
      Fraction mul = new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
      shorten();
      return mul;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
      Fraction diese = new Fraction(this.numerator, this.denominator);
      if (this.numerator != 0) {
        Fraction kw = new Fraction(this.denominator, this.numerator);
        return kw;
      }
      return diese;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
      Fraction div = multiply(f.reciprocal());
      return div;
    }

}"
Gasch,Niclas,n.gasch@campus.tu-berlin.de,Beendet,"22. Juni 2022  11:20","26. Juni 2022  23:59","4 Tage 12 Stunden","14,58","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","private
; void
; static","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
    	this.denominator = denominator;
    	
    	if(this.denominator == 0) {
        	this.denominator = 1;
        }
    	
    	shorten();
    	
    	if(this.denominator < 0) {
        	this.denominator = this.denominator*(-1);
        	this.numerator = this.numerator*(-1);
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = this.numerator +""/""+ this.denominator;
        return str;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/gcd;
        this.denominator = this.denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
       int newDenom = lcm;
       int newNum = (this.numerator*(lcm/this.denominator)) + (f.numerator*(lcm/f.denominator));
       Fraction fadd = new Fraction(newNum, newDenom);
       return fadd;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    	int newNum = this.numerator * f.numerator;
    	int newDenom = this.denominator * f.denominator;
    	Fraction fmul = new Fraction(newNum, newDenom);
        return fmul;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	int newNum = this.numerator;
    	int newDenom = this.denominator;
        if(this.numerator > 0) {
     	   newNum = this.denominator;
     	   newDenom = this.numerator;
        }else if(this.numerator < 0) {
        	newNum = this.denominator*(-1);
      	   newDenom = this.numerator*(-1);
        }
        Fraction rec = new Fraction(newNum, newDenom);
        return rec;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    }
    
}"
Hake,"Anna Franziska",a.hake@campus.tu-berlin.de,Beendet,"22. Juni 2022  12:58","26. Juni 2022  23:47","4 Tage 10 Stunden","5,17","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; void","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: public; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""0"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""7"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Lewandowski,"Constantin Dietmar",c.lewandowski@campus.tu-berlin.de,Beendet,"22. Juni 2022  14:13","23. Juni 2022  12:35","22 Stunden 22 Minuten","13,58","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","static
; private
; void","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator > 0) {
            this.numerator = numerator;
            this.denominator = denominator;
        } else if (denominator == 0) {
            this.numerator = numerator;
            this.denominator = 1;
        } else if (denominator < 0) {
            this.numerator = -1 * numerator;
            this.denominator = -1 * denominator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator / denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """" + numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = Math.abs(Fraction.GCD(this.getNumerator(), this.getDenominator()));
        this.numerator = (int) (numerator / gcd);
        this.denominator = (int) (denominator / gcd);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = Math.abs(Fraction.LCM(this.getDenominator(), f.getDenominator()));
        int n = this.getNumerator() * (lcm / this.getDenominator()) + f.getNumerator() * (lcm / f.getDenominator());
        return new Fraction(n, lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
       return new Fraction(this.getNumerator() * f.getNumerator(), this.getDenominator() * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.getNumerator() == 0) return new Fraction(this.getNumerator(), this.getDenominator());
       else return new Fraction(this.getDenominator(), this.getNumerator());
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }
    
}"
Grafelmann,"Tjorven Björn",grafelmann@campus.tu-berlin.de,Beendet,"22. Juni 2022  16:43","24. Juni 2022  22:00","2 Tage 5 Stunden","12,67","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","void
; static
; private","Setter-Methoden haben in der Regel den Rückgabetyp void","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
        if (this.denominator == 0) {
			this.denominator = 1;
		}else if (this.denominator < 0){
			this.numerator=-this.numerator;
			this.denominator = Math.abs(this.denominator);
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double i = ((double) getNumerator())/((double) getDenominator());
		return i;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String ausgabe = (getNumerator()+""/""+getDenominator());
		return ausgabe;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int g = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator/g;
		this.denominator = this.denominator/g;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       	Fraction t = new Fraction (getNumerator(), getDenominator());
		Fraction r = new Fraction (1, 1);
		r.numerator = f.numerator*t.denominator+t.numerator*f.denominator;
		r.denominator = f.denominator*t.denominator;
		r.shorten();
		return r;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction t = new Fraction (getNumerator(), getDenominator());
        t.numerator = t.numerator*f.numerator;
		t.denominator = t.denominator*f.denominator;
		t.shorten();
		return t;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction t = new Fraction (getNumerator(), getDenominator());
		if (numerator != 0){
			int n = t.numerator;
			int d = t.denominator;
		   if (numerator > 0) {
				t.numerator = d;
				t.denominator = n;
		   }else{
				t.numerator = -Math.abs(d);
				t.denominator = Math.abs(n);
		   }
		}
		t.shorten();
	  return t;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction t = new Fraction (getNumerator(), getDenominator());
        t.numerator = t.numerator*f.denominator;
		t.denominator = t.denominator*f.numerator;
		t.shorten();
		return t;
    }
    
}"
Bosner,Celina,c.bosner@campus.tu-berlin.de,Beendet,"22. Juni 2022  19:13","26. Juni 2022  23:22","4 Tage 4 Stunden","12,00","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","static
; private
; void","Getter und Setter","Zugriff auf private Attribute ermöglichen","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: private; Teil 2: private; Teil 3: public; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""50"","""",""""],[""5(15)"","""","""","""","""",""51"",""""],[""6(15)"","""","""","""","""","""",""52""],[""7(15)"",""-"",""-"",""-"",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""50"","""",""""],[""5(17)"","""","""","""","""",""51"",""""],[""6(17)"","""","""","""","""","""",""52""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""1"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) denominator = 1;
        else if (denominator < 0) {
            numerator = -numerator;
            denominator = -denominator;
        }
        
        this.numerator= numerator;
        this.denominator= denominator;
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / (double) this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int greatestCommonDivider = GCD(this.numerator, this.denominator);
        this.numerator /= greatestCommonDivider;
        this.denominator /= greatestCommonDivider;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        // gleichnamiger Nenner durch Multiplikation beider Nenner
        // dann Zähler vervielfachen, damit sie auf den neuen Nenner passen

        int newDenominator = f.denominator * this.denominator;
        int newNumerator = f.numerator * (newDenominator / f.denominator) +
                           this.numerator * (newDenominator / this.denominator);
        return new Fraction(newNumerator, newDenominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0) return new Fraction(this.numerator, this.denominator);
       else return new Fraction(this.denominator, this.numerator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f = f.reciprocal();
        return this.multiply(f);
    }
    
}"
Fujiya,Tsuzuru,tsuzuru.fujiya@campus.tu-berlin.de,Beendet,"22. Juni 2022  21:03","26. Juni 2022  19:59","3 Tage 22 Stunden","10,57","private
; void","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    void setBreite(int breite) {
        this.breite = breite;
    }
    
    int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""1"",""-"",""-"",""-"",""-"",""-"",""-""],[""2"","""","""","""","""","""",""""],[""3"","""","""","""",""undef"",""undef"",""undef""],[""4"",""undef"","""",""undef"","""","""",""""],[""5"","""",""undef"","""","""","""",""""],[""6"","""","""","""","""","""",""""],[""7"","""","""","""","""","""",""""],[""8"","""","""","""","""","""",""""],[""9"","""","""","""","""","""",""""],[""10"","""","""","""","""","""",""""],[""11"","""","""","""",""0"","""",""""],[""12"","""","""","""","""",""0"",""""],[""13"","""","""","""","""","""",""1""],[""14"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe

    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = Math.abs(denominator);
        if (denominator < 0) {
            this.numerator = -this.numerator;
        }
        if (denominator == 0) {
            this.denominator = 1;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double wk = ((double) numerator / (double) denominator);
        return wk;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch = String.valueOf(numerator) + ""/"" + String.valueOf(denominator);
        return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = Math.abs(GCD(numerator, denominator));
        numerator = numerator / gcd;
        denominator = denominator / gcd;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(denominator, f.getDenominator());
        if (denominator == f.getDenominator()) {
            Fraction s = new Fraction(f.getNumerator() + numerator, denominator);
            return s;
        }
        int n = numerator*(lcm/denominator);
        int m = f.getNumerator()*(lcm/f.getDenominator());
        Fraction e = new Fraction(n+m,lcm);
        return e;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction w = new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
        return w;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0) {
            Fraction n = new Fraction(denominator, numerator);
            return n;
        } else {
            return this;
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction u = new Fraction(numerator * f.reciprocal().getNumerator(), this.denominator * f.reciprocal().getDenominator());
        return u;
    }
}"
Hänsel,"Tilo Kurt",t.haensel@campus.tu-berlin.de,Beendet,"23. Juni 2022  10:51","26. Juni 2022  23:59","3 Tage 13 Stunden","12,75","void
; private
; static","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""50"","""","""","""","""",""""],[""12"","""",""51"","""","""","""",""""],[""13"","""","""",""52"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (numerator < 0 && denominator < 0) {
			this.numerator = numerator*(-1);
			this.denominator = denominator*(-1);
		} else if (numerator >= 0 && denominator < 0) {
			this.numerator = numerator*(-1);
			this.denominator = denominator*(-1);
		} else if (denominator == 0) {
			this.numerator = numerator;
			this.denominator = 1;
		} else {
			this.numerator = numerator;
			this.denominator = denominator;
		}	
		shorten();	
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double x = numerator;
		double y = denominator;
        return (x/y);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (numerator+""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int kürzen = GCD(numerator, denominator);
		this.numerator = numerator/kürzen;
		this.denominator = denominator/kürzen;
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int erweitern = LCM(denominator, f.getDenominator());
	   Fraction g = new Fraction(1, 1);
	   g.numerator = (numerator*(erweitern/denominator))+(f.getNumerator()*(erweitern/f.getDenominator()));
	   g.denominator = (erweitern);
	   g.shorten();
	   return g;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction h = new Fraction(1, 1);
        h.numerator = numerator*f.getNumerator();
		h.denominator = denominator*f.getDenominator();
		h.shorten();
		return h;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction i = new Fraction(1, 1);
		if(numerator != 0) {
			int zwischenzaehler = numerator;
			i.numerator = denominator;
			i.denominator = zwischenzaehler;
		} else {
			i.numerator = numerator;
			i.denominator = denominator;
		}
		
       return i;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction q = new Fraction(1, 1);
	   q = f.reciprocal();
	   Fraction j = new Fraction(1, 1);
	   j = multiply(q);
	   j.shorten();
	   return j;
    }
	
}"
"Alonso Pardo","Laura Christina",l.alonsopardo@tu-berlin.de,Beendet,"23. Juni 2022  12:36","26. Juni 2022  23:59","3 Tage 11 Stunden","6,67","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","private
; void
; static","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""",""1"","""","""",""50"",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""50"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""1"","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""",""0"","""","""",""1"",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor, der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * 
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
         if(denominator<0){
            Terminal.println(""Unerlaubte Zahl"");
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Böning,"Felix Gabriel",f.boening@campus.tu-berlin.de,Beendet,"24. Juni 2022  08:46","26. Juni 2022  23:59","2 Tage 15 Stunden","12,58","static
; private
; void","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden können überladen werden","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""",""0"",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"",""0"",""1"",""0"","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""1""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"",""0"",""0"",""1"","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		if(denominator == 0)
		{
			this.denominator = 1;
		}
		else if(denominator < 0){
			this.numerator = numerator * (-1); 
			this.denominator = denominator * (-1);
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return this.numerator;  
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double e = (double) this.numerator / this.denominator;
		return e;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String zaehler = Integer.toString(this.numerator);
		String nenner = Integer.toString(this.denominator);
		return zaehler+""/""+nenner;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int d = GCD (this.numerator, this.denominator);
		if (d < 0){
			d *= -1;
		}
		this.numerator = numerator / d;
		this.denominator = denominator / d;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int k = LCM (this.denominator, f.getDenominator());
	   int a = k / this.denominator;
	   int b = k / f.getDenominator();
	   Fraction addi = new Fraction((this.numerator * a) + (f.numerator * b), k);
	   return addi;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int n = this.numerator * f.getNumerator();
		int d = this.denominator * f.getDenominator();
		Fraction mult = new Fraction(n, d);
		return mult; 
	}
    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {		
	if (this.numerator != 0){
		int nd = this.numerator; 
		int nn = this.denominator; 
		Fraction k = new Fraction(nn, nd);
		return k;
	}
	Fraction n = new Fraction(this.numerator, this.denominator);
	return n;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction q = this.multiply(f.reciprocal());
		return q;
    }
    
}"
Bachmann,Alois,alois.bachmann@campus.tu-berlin.de,Beendet,"24. Juni 2022  09:28","24. Juni 2022  10:42","1 Stunde 13 Minuten","14,25","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    void setBreite(int breite) {
        this.breite = breite;
    }
    
    int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}",void,"Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0){
            this.numerator = -numerator;
            this.denominator = -denominator;
        } else {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        if (denominator == 0){
            this.denominator = 1;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) ((double)this.numerator / (double)this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
        this.numerator /= gcd;
        this.denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.getDenominator());
       int f_n = f.getNumerator() * (lcm / f.getDenominator());
       int t_n = this.getNumerator() * (lcm / this.getDenominator());
       int d = lcm;
       Fraction fnew = new Fraction((f_n + t_n), d);
       return fnew;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction((f.getNumerator() * this.numerator), (f.getDenominator() * this.denominator));
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0){
        return new Fraction(this.numerator, this.denominator);
       } else {
        return new Fraction(this.denominator, this.numerator);
       } 
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction fre = f.reciprocal();
        Fraction mul = fre.multiply(this);
        return mul;
    }
    
}"
Schramm,Steffen,steffen.schramm@campus.tu-berlin.de,Beendet,"24. Juni 2022  16:46","26. Juni 2022  17:54","2 Tage 1 Stunde","5,25","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","static
; private
; void","Setter-Methoden haben in der Regel den Rückgabetyp void","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern das Überladen von Methoden","Getter und Setter","public class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""--"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Nguyen,"Cong Huan",cong.h.nguyen@campus.tu-berlin.de,Beendet,"24. Juni 2022  17:02","25. Juni 2022  16:06","23 Stunden 4 Minuten","13,33","private
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Verhindern, dass Attributswerte gesetzt werden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter und Setter","Teil 1: private; Teil 2: ; Teil 3: private; Teil 4: ; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: ; Teil 7: ; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""Adresse 50"",""Adresse 51"",""Adresse 52""],[""4(15)"",""0"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""Adresse 50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""Adresse 50"",""Adresse 51"",""Adresse 52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""Adresse 50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if (denominator > 0) {
            this.denominator = denominator;
        } else if(denominator == 0) {
            this.denominator = 1;
        } else {
            this.denominator = -denominator;
            this.numerator = -numerator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.getNumerator()/this.getDenominator();
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """" + this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggT = GCD(this.numerator, this.denominator);
        this.numerator /= ggT;
        this.denominator /= ggT;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int kgV = LCM(this.getDenominator(), f.getDenominator());
        int multi_this = kgV/this.getDenominator();
        int multi_f = kgV/f.getDenominator();
        int new_den = this.getDenominator() * multi_this;
        int new_num = this.getNumerator() * multi_this;
        new_num += f.getNumerator() * multi_f;
        Fraction result = new Fraction(new_num, new_den);
        result.shorten();
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.getNumerator() * f.getNumerator(), this.getDenominator() * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.getNumerator() == 0){
            return new Fraction(this.getNumerator(), this.getDenominator());
        }
        return new Fraction(this.getDenominator(), this.getNumerator());
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }

}"
Roza,"Jan Philip",roza@campus.tu-berlin.de,Beendet,"24. Juni 2022  17:37","25. Juni 2022  14:34","20 Stunden 56 Minuten","14,08","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void
; private","Setzen falscher Attributwerte verhindern

; Verhindern, dass Attributswerte gesetzt werden

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0){
            this.numerator = -numerator;
        }
        if(denominator==0){
            denominator = 1;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();


    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double gk = (double) numerator/denominator;
        return gk;

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;


    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd;
        do {
            gcd = GCD(numerator, denominator);
            numerator = numerator / gcd;
            denominator = denominator / gcd;
        }while(gcd > 1);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int den = LCM(f.denominator,denominator);
        int num = (den/f.denominator)*f.numerator+(den/denominator)*numerator;
        return new Fraction(num,den);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction frac = new Fraction (numerator*f.numerator,denominator*f.denominator);
        return frac;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        int num = numerator;
        int den = denominator;
        if(numerator!=0){
            num = denominator;
            den = numerator;
        }
        return new Fraction(num, den);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction frac = new Fraction (f.numerator, f.denominator);
        Fraction recipResult = frac.reciprocal();
        Fraction multipResult = multiply(recipResult);
        return multipResult;
    }

}"
Yang,Fan,fan.yang.2@campus.tu-berlin.de,Beendet,"25. Juni 2022  10:59","25. Juni 2022  16:54","5 Stunden 54 Minuten","14,25","Getter und Setter","void
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator < 0){
            this.denominator = denominator * (-1);
            this.numerator = numerator * (-1);
        }else if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        }else{
            this.denominator = denominator;
            this.numerator = numerator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double a = 0;
        a = ((double)numerator / (double)denominator);
        return a;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String a = """";
        a += numerator + ""/"" + denominator;
        return a;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a = GCD(numerator, denominator);
        this.numerator = numerator / a;
        this.denominator = denominator / a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int a = LCM(denominator, f.getDenominator());
       int b = (a / this.denominator)*(this.numerator);
       int c = (a / f.getDenominator())*(f.getNumerator());
       int d = b + c;
       Fraction result = new Fraction(d , a);
       return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int a = this.numerator * f.getNumerator();
        int b = this.denominator * f.getDenominator();
        Fraction result = new Fraction(a , b);
        result.shorten();
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(this.numerator == 0){
        Fraction result = new Fraction(this.numerator, this.denominator);
        return result;
       }else{
        int a = this.numerator;
        int b = this.denominator;
        Fraction result = new Fraction(b, a);
        return result;
       }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction a = f.reciprocal();
       Fraction b = new Fraction(this.numerator, this.denominator);
       Fraction result = b.multiply(a);
       return result;
    }
    
}"
Richter,"Serdal Kemâl",richter.3@campus.tu-berlin.de,Beendet,"25. Juni 2022  11:40","26. Juni 2022  23:59","1 Tag 12 Stunden","13,33","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Verhindern das Überladen von Methoden
; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","private
; void","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""50(11)"",""0"","""","""","""","""",""""],[""11"","""","""","""","""","""",""""],[""51(12)"","""",""0"","""","""","""",""""],[""12"","""","""","""","""","""",""""],[""52(13)"","""","""",""1"","""","""",""""],[""13"","""","""","""","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		
		if (denominator == 0) {
			this.denominator = 1;
		}
		if (denominator < 0 && numerator < 0) {
			this.denominator = Math.abs(denominator);
			this.numerator = Math.abs(numerator);
		}
		if (this.denominator < 0) {
			this.denominator = Math.abs(denominator);
			this.numerator = (~(Math.abs(numerator) - 1));
		}
		shorten();

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		/*
        this.numerator = this.numerator;
		this.denominator = this.denominator;
		return (double) (this.numerator / this.denominator);
		*/
		
		double a = this.numerator;
		double b = this.denominator;
		double numerator = a;
		double denominator = b;
		return numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String f;
		f = this.numerator + ""/"" + this.denominator;
		return f;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int gcd = GCD(this.numerator, this.denominator);
		int a = this.numerator;
		int b = this.denominator;
		a = a / gcd;
		b = b / gcd;
		this.numerator = a;
		this.denominator = b;	
		/*
		System.out.println(this.numerator);
		System.out.println(this.denominator);
		System.out.println(GCD(this.numerator, this.denominator));
        this.numerator = (int) this.numerator / (int) GCD(this.numerator, this.denominator);
		this.denominator = (int) this.denominator / (int) GCD(this.numerator, this.denominator);
		System.out.println(this.numerator);
		System.out.println(this.denominator);
		*/
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
	   int a;
	   int b;
	   int c;
	   this.numerator = this.numerator * (int) (lcm / this.denominator);
	   f.numerator = f.numerator * (int) (lcm / f.denominator);
	   a = this.numerator;
	   b = f.numerator;
	   c = a + b;
	   Fraction k = new Fraction(c, lcm);
	   return k;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int num = this.numerator * f.numerator;
		int denom = this.denominator * f.denominator;
		Fraction k = new Fraction(num, denom);
		k.shorten();
		return k;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		int num;
		int denom;
		Fraction k;
       if (this.numerator != 0) {
		   denom = this.numerator;
		   num = this.denominator;
		   k = new Fraction(num, denom);
		   return k;
	   } else {
		   k = new Fraction(this.numerator, this.denominator);
		   return k;
	   }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction j;
		j = this.multiply(f.reciprocal());
       return j;
    }
    
}"
Matthes,Felix,felix.matthes@campus.tu-berlin.de,Beendet,"25. Juni 2022  12:19","26. Juni 2022  23:59","1 Tag 11 Stunden","5,58","void
; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""2(15)"","""","""","""",""0"",""0"",""1""],[""3(15)"","""","""","""",""1"","""",""""],[""4(15)"","""","""","""","""","""",""0""],[""5(15)"","""","""","""","""",""0"",""""],[""6(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""2(17)"","""","""","""",""1"",""0"",""0""],[""3(17)"","""","""","""",""0"","""",""""],[""4(17)"","""","""","""","""",""0"",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""","""",""""],[""17"",""0"",""0"",""0"",""-"",""-"",""-""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Qin,Yushu,qin.1@campus.tu-berlin.de,Beendet,"25. Juni 2022  13:39","25. Juni 2022  21:18","7 Stunden 38 Minuten","13,75","void
; private","In Objektmethoden können lokale Variablen deklariert werden","Setter-Methoden haben in der Regel den Rückgabetyp void","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern das Überladen von Methoden
; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Teil 1: private; Teil 2: public; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0){
			this.denominator = 0-denominator;
			this.numerator = 0-numerator;
		}
		else if(denominator == 0){
			this.denominator =1;
			this.numerator = numerator;
		}
		else{
			this.denominator = denominator;
			this.numerator = numerator;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        shorten();
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        shorten();
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double a,b;
		a = (double)numerator;
		b = (double)denominator;
        return a/b;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a = GCD(numerator,denominator);
		numerator = numerator/a;
		denominator=denominator/a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction r = new Fraction(0,0);
	   r.numerator = numerator*f.denominator + f.numerator*denominator;
	   r.denominator = denominator * f.denominator;
	   r.shorten();
	   return r;
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction r = new Fraction(0,0);
		r.numerator = numerator*f.numerator;
		r.denominator = denominator * f.denominator;
		r.shorten();
		return r;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       Fraction r=new Fraction(0,0);
	   if(numerator!=0){
		   r.denominator=numerator;
		   r.numerator = denominator;
	   }
	   else{
		   r.denominator=denominator;
		   r.numerator =numerator;
	   }
	   return r;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction r = new Fraction(0,0);
	    r.numerator = numerator*f.denominator;
		r.denominator = denominator * f.numerator;
		r.shorten();
		return r;
    }
    
}"
Will,Kai,k.will@campus.tu-berlin.de,Beendet,"25. Juni 2022  15:19","26. Juni 2022  17:10","1 Tag 1 Stunde","12,82","void
; static
; private","class Rechteck { 
    int breite;
    
    void setBreite(int breite) {
        this.breite = breite;
    }
    
    int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: public; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"","""",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"","""",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }

    public Fraction(int numerator, int denominator) {
      if (denominator<0){
        denominator*=(-1);
        numerator*=(-1);
      }
      if (denominator==0){
        this.denominator=1;
        this.numerator=numerator;
      }
      else{
        this.denominator=denominator;
        this.numerator=numerator;
      }
      shorten();

    }

    public int getDenominator() {
      return this.denominator;
    }

    public int getNumerator() {
      return this.numerator;
    }

    public double toDouble() {
      double d=(double)numerator/denominator;
      return d;
    }

    public String toString() {
      String str=(numerator+""/""+denominator);
      return str;

    }

    public void shorten() {
      int gcd =GCD(numerator, denominator);
      numerator /= gcd;
      denominator /= gcd;
    }

    public Fraction add(Fraction f) {
      Fraction summe=new Fraction((numerator*f.getDenominator())+(f.getNumerator()*denominator), denominator*f.getDenominator());
      return summe;
    }

    public Fraction multiply(Fraction f) {
      Fraction produkt=new Fraction(f.getNumerator()*numerator, f.getDenominator()*denominator);
      return produkt;
    }


    public Fraction reciprocal() {
      if (numerator==0){
        Fraction gehtnicht=new Fraction(numerator, denominator);
        return gehtnicht;
      }
      else{
        Fraction rezip=new Fraction(denominator, numerator);
        return rezip;
      }
    }

    public Fraction divide(Fraction f) {
      Fraction div=new Fraction(numerator*f.getDenominator(), denominator*f.getNumerator());
      return div;
    }

}"
Jakobs,"Chiara Sophie Elisa",c.jakobs@campus.tu-berlin.de,Beendet,"25. Juni 2022  21:56","26. Juni 2022  23:59","1 Tag 2 Stunden","12,50","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","static
; private
; void","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: private; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: private; Teil 7: private; Teil 8: private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""0"","""",""""],[""5(15)"","""","""","""","""",""0"",""""],[""6(15)"","""","""","""","""","""",""1""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""1"","""",""""],[""5(17)"","""","""","""","""",""0"",""""],[""6(17)"","""","""","""","""","""",""0""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if(denominator < 0) {
            this.denominator = -denominator;
            this.numerator = -numerator;
        } else if(denominator == 0) {
            this.denominator = 1;
        } else {
            this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() { 
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator; 
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        return new Fraction((numerator*(LCM(denominator, f.denominator)/denominator)+f.numerator*(LCM(denominator, f.denominator)/f.denominator)), LCM(denominator, f.denominator));
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.numerator, denominator*f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(numerator != 0) {
            int x = numerator;
            numerator = denominator;
            denominator = x;
            return new Fraction(numerator, denominator);
        } else {
            return new Fraction(numerator, denominator);
        } 
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return new Fraction(numerator*f.denominator, denominator*f.numerator);
    } 
}"
Dobbelaere,"Sebastien Frederic",s.dobbelaere@campus.tu-berlin.de,Beendet,"26. Juni 2022  00:22","26. Juni 2022  23:59","23 Stunden 36 Minuten","4,25","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden können überladen werden","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
     int breite;
    
     void setBreite(int breite) {
        this.breite = breite;
    }
    
     int getBreite() {
        return this.breite;
    }
}

 public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","static
; void
; private","Teil 1: private; Teil 2: private; Teil 3: private; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: public; Teil 7: public; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        System.out.println(""+numerator+""+""/""+""+denominator+"");
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator(int numerator, int denominator) {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator(int numerator, int denominator) {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(int numerator, int denominator) {
        return float n = numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString(int numerator, int denominator) {
        System.out.println(""+numerator+""+""/""+""+denominator+"");
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten(int numerator, int denominator) {
        return (""+numerator+""+""/""+""+denominator+"")
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Janiel,"Jan Tadeus",j.janiel@campus.tu-berlin.de,Beendet,"26. Juni 2022  21:18","26. Juni 2022  22:24","1 Stunde 5 Minuten","4,17","Getter und Setter","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","Teil 1: private; Teil 2: private; Teil 3: public; Teil 4: public; Teil 5: this.prozessor = prozessor; this.kerne = kerne; this.taktfrequenz = taktfrequenz;; Teil 6: private; Teil 7: private; Teil 8: public","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""",""0"","""",""0"",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if (denominator == 0) {
            throw new IllegalArgumentException(""The denominator is zero."");
        }
        if(numerator==0){
            this.numerator = 0;
            this.denominator = 1;
        }
        else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
        if(denominator<0){
            this.numerator = -1*this.numerator;
            this.denominator = -1*this.denominator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return this.numerator / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        if(denominator!=1)
            return numerator+""/""+denominator;
        else
            return numerator+"""";
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator,denominator);
        numerator = numerator/gcd;
        denominator = denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        return new Fraction(f.numerator*this.denominator+this.numerator*f.denominator,f.denominator*this.denominator);
}

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(f.numerator*this.numerator,f.denominator*this.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(this.numerator != 0){
            
            return new Fraction(getDenominator(),getNumerator())
        }
        return this;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return new Fraction(f.numerator*this.denominator,f.denominator*this.numerator);
    }
}"
