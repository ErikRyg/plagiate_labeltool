Nachname,Vorname,E-Mail-Adresse,Status,"Begonnen am",Beendet,"Verbrauchte Zeit","Bewertung/15,00","Antwort 1","Antwort 2","Antwort 3","Antwort 4","Antwort 5","Antwort 6","Antwort 7","Antwort 8","Antwort 9","Antwort 10"
Wolf,"Johannes Peter",j.wolf.1@campus.tu-berlin.de,Beendet,"17. Dezember 2020  09:57","23. Dezember 2020  01:24","5 Tage 15 Stunden","12,50",new,3,int[],"char string;",geca,n-1,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char [breite+2][hoehe+2]  ;
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    public static void main (String[] args) {
		
		int []array = Terminal.askIntArray(""Queue:\n"");
		
	
		for (int i=0; i<array.length;i++){
			Terminal.println(array[indexOfMax(array)]);
			array[indexOfMax(array)]= Integer.MIN_VALUE;		
		}	
	}
	public static int indexOfMax (int [] x){
		int max = x[0];
		int index =0;
	
		for (int i = 0; i<x.length;i++) {
			if (x[i]>max){
			
			max = x[i];
			index = i;}
		}
	return index;
	}		
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int [][] addar = new int[10][10];
		getUpdate(TREES,addar);
		add(TREES,addar,END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for (int i=0;i<x.length;i++){
			for (int j=0;j<x.length;j++){
				if (x[i][j] >=TREE && x[i][j]<=END ) {x[i][j] += y[i][j];}
				if (x[i][j] >END) {x[i][j]=0;}
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x,int[][] y) {
        for (int i=0;i<=x.length-1;i++){
			for (int j=0;j<=x.length-1;j++){
				if (x[i][j] > TREE|| neighborIsOnFire(x,i,j)==true )  {y[i][j] += 1;}
			}
		}
		return  y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Lietz,"Alexander Pascal",a.lietz@campus.tu-berlin.de,Beendet,"17. Dezember 2020  13:02","7. Januar 2021  13:11","21 Tage","13,21",int,-3.5,"den gleichen Datentyp.","char string;",3,3,"Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 2; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: 3; Teil 16: 0; Teil 17: 0; Teil 18: 0; Teil 19: 0; Teil 20: %; Teil 21: %; Teil 22: 4; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 5; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: undef; Teil 36: 8(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 9(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 2; Teil 49: %; Teil 50: 10(5); Teil 51: %; Teil 52: %; Teil 53: 1; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 11(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 9(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 3; Teil 70: %; Teil 71: 10(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: 2; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: 2; Teil 97: -; Teil 98: %; Teil 99: 6; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;

    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char[][] array;
        array = new char[breite+2][hoehe+2];

        for(int i = 0; i <= (hoehe+1); i++) {
            for(int j = 0; j <= (breite+1); j++) {
                if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
                    System.out.print(""A"");
                    array[j][i] = 'A';
                }
                else {
                    System.out.print(""B"");
                    array[j][i] = 'B';
                }
            }
            System.out.print(""\n"");
        }

        System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

        for(int i = 0; i <= (hoehe+1); i++){
            for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
            System.out.print(""\n"");
        }
    }

    public static void main(String[] args){
        frame();
    }
}","public class Queue {

    public static void main(String[] args) {
        int[] wartezeit = Terminal.askIntArray(""Queue:\n"");
        int max;

        for (int i = 0; i < wartezeit.length + 1; i++) {
            max = indexOfMax(wartezeit);
            if (max != -1) {
                Terminal.println(wartezeit[max]);
                wartezeit[max] = Integer.MIN_VALUE;
            } else {
                System.exit(0);
            }
        }
    }


    //Diese Methode findet den Index der größten Wartezeit im Array
    public static int indexOfMax(int[] wartezeit) {


        int output = -1;
        int maxAt = 0;

        for (int i = 0; i < wartezeit.length; i++) {
            if (wartezeit[i] == Integer.MIN_VALUE) {
                //IF macht gar nichts, es wird mit nächsten Index weitergearbeitet

            } else {
                maxAt = wartezeit[i] > wartezeit[maxAt] ? i : maxAt;
                output = maxAt;
            }
        }
        return output;
    }
}","import javax.swing.*;

public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        add(TREES,getUpdate(TREES),END);

    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {

        for(int i = 0; i < x[0].length; i++){
            for (int j = 0; j < x[1].length; j++){
                int summe;
                summe = (x[i][j] + y[i][j]) % (max + 1);

                    if(summe <= max){
                        x[i][j] = summe;
                    }else{
                       x[i][j] = x[i][j];
                    }
                }
            }
    }


    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    public static int[][] getUpdate(int[][] x) {
        int[][] y = new int[x[0].length][x[1].length];
        for (int i = 0; i < x[0].length; i++){
            for (int j = 0; j < x[1].length; j++){
                if (x[i][j] > TREE || x[i][j] == TREE && neighborIsOnFire(x,i,j) ){
                    y[i][j] = 1;
                }else {
                    y[i][j] = 0;
                }
            }
        }
        return y;
    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Wegert,"Johan Ole",j.wegert@campus.tu-berlin.de,Beendet,"17. Dezember 2020  15:41","17. Dezember 2020  16:56","1 Stunde 15 Minuten","14,10",new,geca,"1, 1, 2","den gleichen Datentyp.","boolean if;",3,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: &; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
            char[][] array=new char[breite+2][hoehe+2];
    	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String arg[]){
    int[] q=Terminal.askIntArray(""Queue:\n"");
    for(int i=0;i<q.length;i++){
        System.out.println(q[indexOfMax(q)]);
        q[indexOfMax(q)]=Integer.MIN_VALUE;
    }
    }
    public static int indexOfMax(int[] a){
        int max=Integer.MIN_VALUE;
        int index=0;
        for(int i=0;i<a.length;i++){
            if(a[i]>max){
                max=a[i];
                index=i;
            }
        }
        return index;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int[][] TRE=new int[TREES.length][TREES[0].length];
        for(int i=0;i<TREES.length;i++){
            for(int j=0;j<TREES[0].length;j++){
                if(TREES[i][j]>TREE){
                    TRE[i][j]+=1;
                }  
                else if(TREES[i][j]==0){
                    if(neighborIsOnFire(TREES,i,j)){
                        TRE[i][j]=1;
                    }
                } 
   
            }
        }
        add(TREES,TRE,END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y,int max) {
        for(int i=0;i<x.length;i++){
            for(int j=0;j<x[0].length;j++){
                x[i][j]=(x[i][j]+y[i][j])%(max+1);
            }
        }
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Tesch,Johanna,j.tesch@campus.tu-berlin.de,Beendet,"18. Dezember 2020  10:26","22. Dezember 2020  12:36","4 Tage 2 Stunden","13,56",3,fdb,-3.5,"int null;",n-1,"den gleichen Datentyp.","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: 3; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: 4; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static void main(String[] args) {
		
		int[] array = Terminal.askIntArray(""Queue:\n"");
		
		int indMax = indexOfMax(array); 
		
		for(int i = array.length; i>0; i--) {
			if(indMax != -1) {
				Terminal.println(array[indMax]);
				array[indMax] = Integer.MIN_VALUE;
				indMax = indexOfMax(array);
			}
			else {
				System.exit(0);
			}
		}
	}
	
	public static int indexOfMax(int[] array) {
		
		int r = array[0];
		int ind = 0; 
		
		if(allDiff(array)) {
			for(int i = 0; i<array.length; i++) {
				if(r<=array[i]) {
					r = array[i];
					ind = i;
				}
			}
		}
		else {
			ind = -1;
		}
		return ind; 
	}
	
	public static boolean allDiff(int array[]) {
		boolean result = false; 
		for(int i = 1; i<array.length; i++) {
			if(array[0] != array[i]) {
				result = true;
			}
		}
		return result;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		TREES = add(TREES, getUpdate(TREES), 6);
	}
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x, int[][] y, int max) {
		int[][] treesNeu = new int[x.length][x[1].length];		
		
		for(int i = 0; i<x.length; i++) {						
			for(int j = 0; j<x[1].length; j++) {				
				treesNeu[i][j] = x[i][j] + y[i][j];
			}
		}
		for(int i = 0; i<x.length; i++) {						
			for(int j = 0; j<x[1].length; j++) {				
				if(treesNeu[i][j]>max) {
					treesNeu[i][j] = 0;
				}		
			}				
		}
		return treesNeu;		
	}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
	public static int[][] getUpdate(int[][] x) {
		int [][] y = new int[x.length][x[1].length];			
		for(int i = 0; i<x.length; i++) {						
			for (int j = 0; j<x[1].length; j++) {				
				if(x[i][j] > 0) {
					y[i][j] = 1;
				}
				else if(x[i][j]==0 && neighborIsOnFire(TREES, i, j) == true) {
					y[i][j] = 1;
				}
			}
		}
		return y; 
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Müller-Hardy,"Finnegan Maximilian",f.mueller-hardy@campus.tu-berlin.de,Beendet,"18. Dezember 2020  11:48","8. Januar 2021  10:25","20 Tage 22 Stunden","9,87","1, 1, 2",3,"den gleichen Datentyp.",3,geca,n-1,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 2; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: -; Teil 77: %; Teil 78: 12(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 5; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 2.0; Teil 99: 6; Teil 100: -; Teil 101: -; Teil 102: -; Teil 103: -; Teil 104: %; Teil 105: -; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{

	public static void main(String[] args){
		int[] array = Terminal.askIntArray(""Queue:\n"");
		int abgearbeitet_location = 0;
		int taco = 0;
		for (int i = 0; i <= array.length; i++){
			abgearbeitet_location = indexOfMax(array); //gets location of max value in array
			
			if (i < array.length && taco != -1){
				taco = array[abgearbeitet_location]; //assigns location of max value to variable
				System.out.println(taco);//prints max value at location
				array[abgearbeitet_location] = Integer.MIN_VALUE;//sets max value at location in array to MIN_VALUE	
			} 
			 
		}
		
	}	

	public static int indexOfMax(int[] array){
		int max = Integer.MIN_VALUE;
		int index = 0;
		int done = 0;
		for (int element : array){
			if (element == Integer.MIN_VALUE){
				done += 1;
				//System.out.println(""done value is ""+done);
			}
			if (done == array.length){
				return -1;
			}	
		}
		for (int i = 0; i < array.length; i++){
			if (array[i] > max){
				max = array[i];
				index = i;
			}	
		}
		return index;
	}
	
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Lex,Matthias,m.lex@campus.tu-berlin.de,Beendet,"18. Dezember 2020  12:39","10. Januar 2021  23:52","23 Tage 11 Stunden","14,72","zahlen = new int[3];",n-1,3,int[],"char string;","1, 1, 2","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
	public static void main(String[] args){
    int[] x = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0; i < x.length; i++){
			int k = indexOfMax(x);
			System.out.println(x[k]);
			x[k] = Integer.MIN_VALUE;
		}
		
	}
    
	public static int indexOfMax(int[] a){
		int max = 0;
		int index = -1;
			for(int i = 0; i < a.length; i++){
				if(a[i] > max){
					max = a[i];
					index = i;
				}
			}
			return index;
		
	}
	
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {		
		add(TREES, getUpdate(TREES), 6);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for(int i=0;i<x.length;i++){
			for(int j=0;j<x[i].length;j++){
				x[i][j]=((x[i][j]+y[i][j])%(max+1));
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int[x.length][x[0].length];
			for(int i = 0; i < x.length; i++){
				for(int j = 0; j <x[i].length; j++){
					if(x[i][j] == 0 && neighborIsOnFire(x, i, j) || x[i][j] > 0) y[i][j] = 1;
					else y[i][j] = 0;
				}
			}
		return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Mesfun-Ghebrekidan,Yoel,yoel.mesfun-ghebrekidan@campus.tu-berlin.de,Beendet,"18. Dezember 2020  18:20","10. Januar 2021  17:41","22 Tage 23 Stunden","10,21",3,geca,3,"1, 1, 2",-3.5,"char string;","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5(8); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 5(9); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 5(10); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 5(11); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 5(9); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 5(10); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 5(11); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 5(9); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 5(11); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 5(12); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 5(13); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 1,5; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
	
	public static void main (String [] args) {
	
		Framed.breite = 1;
		Framed.hoehe = 1;
		Framed.frame();
	}
	
	public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
    	char [] [] array = new char [breite+2] [hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				     array [j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

	public static void main (String [] args) {
	    
	    int [] yolo=  (Terminal.askIntArray(""Queue:\n""));
	   
	    
	    for(int i=0; i< yolo.length; i++) {
	    	int z= indexOfMax(yolo);
	    	Terminal.println(yolo[z]);
	    	yolo[z]= Integer.MIN_VALUE;
	    }
	}
	public static int indexOfMax(int [] a) {	
		   
		   int b = a[0];
		   int c= 0;
		   for(int i=0; i< a.length; i++) {
			   
			   if (b < a[i]) {
				   b=a[i];
				   c=i;
				   
			   } 
			  
		   }
	   
		   	if( b == Integer.MIN_VALUE){ 
			   return -1;
		   	}
		   	else {
		   		return c;
		   	}
		   	
			
		   	
	   
	   
	   }
	    
	}","public class Forest { 
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Klemt,"Dorothea Klara",d.klemt@campus.tu-berlin.de,Beendet,"19. Dezember 2020  18:13","10. Januar 2021  23:59","22 Tage 5 Stunden","10,10","char string;","0, 1, 1",geca,"zahlen = new int[3];",3,new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: %","public class Framed {

	public static void main(String[] args) {
		frame();
	}

    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [] [] array = new char [breite+2] [hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

	public static void main (String[] args) {
		int [] queue = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0; i < queue.length; i++) {
			int index = indexOfMax(queue);
			if(index == -1) {
				break;
			}
			System.out.println(queue[index]);
			queue[index] = Integer.MIN_VALUE;
		}
	}

	public static int indexOfMax(int[] queue){
		int index = -1;
		int biggest = 0;
		for(int i=0; i < queue.length; i++) {
			if(queue[i]>biggest) {
				biggest = queue[i];
				index = i;
			}
		}
		return index;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Ramge,Max,ramge@campus.tu-berlin.de,Beendet,"19. Dezember 2020  19:56","10. Januar 2021  23:47","22 Tage 3 Stunden","8,89","char string;",n-1,2,Compilerfehler,3,-3.5,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: %; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 3; Teil 42: %; Teil 43: 5; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 2; Teil 50: 5; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 6; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 7; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 8; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 9; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 10; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 11; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 12; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 13; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][]array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    
	
    public static int indexOfMax(int[]u){
		
		int r = -1;
		int max = Integer.MIN_VALUE;
		for(int i=0;i<u.length;i++){
			if (u[i] > max){
				max = u[i];
				r = i;
			}
		}
		return r;
	}
	
	public static void main(String[] args) {
		int[]arr = Terminal.askIntArray(""Queue:\n"");
		while(indexOfMax(arr) != -1){
			System.out.println (arr[indexOfMax(arr)]);
			arr[indexOfMax(arr)] = Integer.MIN_VALUE;
		}
	}
}","public class Forest {
	
	//java RunForest -cls2 -ascii

   
    // Die Wald-Repraesentation ->von Main
    public static int[][] TREES;
	
	public static int[][]T= TREES;
	
	
	//public static int y = T.length;			//[y][x]
    //public static int x = T[0].length;
	
	
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    

		
		
		
    public static void step() {
		burn();
		step();
		TREES = T;
		
	}
		
			
	public static void grow(){
		for(int i=0; i<(T.length-1); i++) {
			for(int ii=0; ii<(T[0].length-1); ii++) {
				
				
				if(T[i][ii]>0){
					T[i][ii]++;
				}
				
				if(T[i][ii]>6){			// BAUM ERWACHSEN
					T[i][ii] = 0;
				}		
			}
		}
		
	}  
	
	public static void burn() {
		
		for(int i=0; i<(T.length-1); i++) {
			for(int ii=0; ii<(T[0].length-1); ii++) {   //LINKS nach RECHTS
				if(neighborIsOnFire(T,i,ii)&&indexInBounds(T,i,ii)){
					T[i][ii]++;
				}
					
					
					
				}
			}
	}
    
		
	
	public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
	

    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    

     
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Günther,Till,9f091c3fdba2e9ee628d741520967ce1,Beendet,"20. Dezember 2020  19:20","10. Januar 2021  16:49","20 Tage 21 Stunden","6,56",n-1,"den gleichen Datentyp.",true,"zahlen = new int[3];",int[],"1, 1, 2","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 10(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 11(5); Teil 37: %; Teil 38: %; Teil 39: 2; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 3; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 10(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: -; Teil 82: -; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 1,5; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array=new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main (String [] args){
		int[] b= Terminal.askIntArray(""Queue:\n"");
		for (int i=0;b.length>i;i++){
			Terminal.println(indexOfMax(b));
			int k=indexOfMax(b);
			k=Integer.MIN_VALUE;
			}
			
	}
	public static int indexOfMax(int[] a) {   
		for (int i=1; i <a.length ;i++)
			for (int j=a.length-1;j>=i;j--){
				if (a[j]<a[j-1]){
					int h=a[j];
					a[j]=a[j-1];
					h=a[j-1];
				}
			}
			return a[h];
	}
	
			
 
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Witri,"Farah Shavira",witri@campus.tu-berlin.de,Beendet,"20. Dezember 2020  20:29","10. Januar 2021  21:12","21 Tage","14,02",-3.5,"den gleichen Datentyp.","zahlen = new int[3];","char string;","1, 1, 2",3,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: fib(a); Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 12(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 13(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 5; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 2; Teil 92: 6; Teil 93: -; Teil 94: -; Teil 95: -; Teil 96: -; Teil 97: -; Teil 98: -; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112:","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char [breite + 2][hoehe + 2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String[] args) {

        int[] array = Terminal.askIntArray(""Queue:\n"");
        while(indexOfMax(array) != -1){
            int index = indexOfMax(array);
            Terminal.println(array[index]);
            array[index] = Integer.MIN_VALUE;
        }
    }

    public static int indexOfMax(int[] array){
        int index = 0;
        int max = array[0];

        for(int i = 1; i < array.length; i++){
            if (max < array[i]){
                index = i;
                max = array[i];
            }
        }

        if(max == Integer.MIN_VALUE){
            return -1;
        }
        return index;
    }
}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int
            TREE = 0,
            FIRE_START = 1,
            FIRE_END = 3,
            END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        add(TREES, getUpdate(TREES), 6);


    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for (int a = 0; a < x.length; a++){
            for (int b = 0; b < y.length; b++){

                if( (x[a][b] + y[a][b]) <= max ){
                    x[a][b] = x[a][b] + y[a][b];
                }
                else{
                    x[a][b] = (x[a][b] + y[a][b]) % (max + 1);
                }

            }
        }
    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    public static int[][] getUpdate(int[][] x) {
        int[][] y = new int[x.length][x.length];

        for(int i = 0; i < TREES.length; i++){
            for(int j = 0; j < TREES.length; j++){
                if (x[i][j] > 0){
                    y[i][j] += 1;
                }

                if ( (x[i][j] == 0) && neighborIsOnFire(x, i, j)){
                    y[i][j] += 1;
                }

                if (x[i][j] > 6){
                    y[i][j] = 0;
                }

            }
        }



        /*for(int i = 0; i < x.length; i++){
            for(int j = 0; j < x.length; j++){
                if( (x[i][j] >= TREES[i][j]) && neighborIsOnFire(x, i, j)){

                }
            }
        }*/

        return y;
    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Felchner,"Felix Reinhard",f.felchner@campus.tu-berlin.de,Beendet,"20. Dezember 2020  20:29","10. Januar 2021  15:17","20 Tage 18 Stunden","14,49",int[],n-1,new,"zahlen = new int[3];","1, 1, 2",3,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: -; Teil 24: -; Teil 25: -; Teil 26: -; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2,0; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    public static void main(String[] args) {
		int[] queue = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0; i < queue.length; i++) {
			int index = indexOfMax(queue);
			Terminal.println(queue[index]);
			queue[index] = -1;
		}
		
	}
	
	public static int indexOfMax(int[] que) {
		int indexOflargest = 0;
		if(que == null || que.length == 0) {
			return -1;
		}
		for(int i = 1; i < que.length; i++) {
			if(que[i] > que[indexOflargest]) {
				indexOflargest = i;
			}
		}
		return indexOflargest;
	}
    
}","public class Forest {
	// Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    	add(TREES, getUpdate(TREES), END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
    	for(int i = 0; i < x.length; i++) {
    		for(int j = 0; j < x[i].length; j++) {
    			
        		x[i][j] = (x[i][j] + y[i][j])%(max+1);
        	}
    	}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
    	int[][] y = new int[x.length][x[0].length];
    	
    	for(int i = 0; i < x.length; i++) {
    		for(int j = 0; j < x[i].length; j++) {
    			
    			if(x[i][j] > 0) {
    				y[i][j] = 1;
    			} else if(x[i][j] == 0) {
    				if(neighborIsOnFire(x, i, j)) {
    					y[i][j] = 1;
    				} else {
    					y[i][j] = 0;
    				}
    			} else {
					y[i][j] = 0;
				}
    			
    		}
    	}
    	return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
    
    
    
}"
Ramadani,Adisa,adisa.ramadani@campus.tu-berlin.de,Beendet,"21. Dezember 2020  00:18","10. Januar 2021  23:59","20 Tage 23 Stunden","0,00",-,-,-,-,-,-,"Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112:","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Schrenk,"Philipp Albert",p.schrenk@campus.tu-berlin.de,Beendet,"21. Dezember 2020  00:57","10. Januar 2021  23:59","20 Tage 23 Stunden","14,21","1, 1, 2",3,geca,int[],new,3,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 9(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: 4; Teil 84: %; Teil 85: 11(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 12(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main(String[] args) {
		int[] array = Terminal.askIntArray(""Queue:\n"");
		for(int j = 0; j < array.length; j++) {
		int maxInd = indexOfMax(array);
		System.out.println(array[maxInd]);
		array[maxInd] = Integer.MIN_VALUE;
		}
	}
	
    public static int indexOfMax(int[] arr) {
		int maxInd = 0;
		for(int i = 0; i < arr.length; i++) {
			if(arr[i] > arr[maxInd]) {
				maxInd = i;
			}
		}
		if (maxInd >= 0) {
			return maxInd;
		}
		else {
			return maxInd = -1;
		}
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		int[][] update = getUpdate(TREES);		
		add(TREES, update, 6);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for(int i = 0; i < x.length; i++) {
			for(int j = 0; j < x[i].length; j++) {
				x[i][j] = (x[i][j] + y[i][j]) % (max + 1);
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] update = new int[x.length][x[0].length];
		for(int i = 0; i < x.length; i++) {
			for(int j = 0; j < x[i].length; j++) {
				if(x[i][j] > 0) {
					update[i][j] = 1;
				}
				else if(neighborIsOnFire(x, i, j) && x[i][j] == 0) {
					update[i][j] = 1;
				}
				else {
					update[i][j] = 0;
				}
			}
		}
		return update;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Wegener,Erik,erik.wegener@campus.tu-berlin.de,Beendet,"21. Dezember 2020  07:54","21. Dezember 2020  07:58","3 Minuten 28 Sekunden","1,50","0, 1, 1",n-1,8.5,int[],do,"den gleichen Datentyp.","Teil 1: 1; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: 2; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: 3; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: 4; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: 5; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: 6; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: 7; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: 7; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: 8; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: 9; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112:","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Niewiarra,"Julian Baptiste",niewiarra@campus.tu-berlin.de,Beendet,"21. Dezember 2020  09:58","10. Januar 2021  13:18","20 Tage 3 Stunden","14,28",-3.5,n-1,"den gleichen Datentyp.",geca,int[],"zahlen = new int[3];","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: unfef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 2; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 9(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array =new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static int[] queue;
	
	public static void main (String[] args){
    
		//Terminal.println(Queue.indexOfMax(Terminal.askIntArray("""")));
	
		queue = Terminal.askIntArray(""Queue:\n"");		
		int k = indexOfMax(queue);
		while(k > -1){
			System.out.println(queue[k]);
			queue[k] = Integer.MIN_VALUE;
			k = indexOfMax(queue);
		}
	}
	
	public static int indexOfMax(int[] schlange){
		int wert = schlange[0];
		int position = 0;
	
		for(int i = 1; i < schlange.length; i++){
			if(schlange[i] > wert){
				wert = schlange[i];
				position = i;
			}
		}
		if(wert == Integer.MIN_VALUE){position= -1;}
		return position;
	}   
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
	public static void step() {
		
		int actStatus;
		int[][] aend = new int[TREES.length][TREES.length];
		
		for(int i = 0; i < TREES.length; i++){
			for(int j = 0; j < TREES[i].length; j++){
				// den Eintrag in der Position (i, j) abrufen, dann Fallunterscheidungen
				actStatus = TREES[i][j];
				if((actStatus > 0) && (actStatus < 6)){
					aend[i][j] = actStatus + 1;
				}
				else if ((actStatus == 0) && (neighborIsOnFire(TREES,i,j))){
					aend[i][j] = 1;
				}
				else if ((actStatus == 0) && ((neighborIsOnFire(TREES,i,j) == false))){
					aend[i][j] = 0;
				}

				else if(actStatus == 6){
					aend[i][j] = 0;
				}
				else{
					aend[i][j] = actStatus;
				}
				
			}
		}
		TREES = aend;
    }  

    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Mäding,"Toni Siegfried",t.maeding@campus.tu-berlin.de,Beendet,"21. Dezember 2020  10:14","10. Januar 2021  21:26","20 Tage 11 Stunden","3,92","zahlen = new int[3];",geca,3,"1, 1, 2","den gleichen Datentyp.","char string;","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(4); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(4); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(4); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(4); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 12(4); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 12; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 4; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 5; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
         int[][] array = new int [breite+6][hoehe+6];//Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main (String[]args)
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Klocksin,"Malte Carl",m.klocksin@campus.tu-berlin.de,Beendet,"21. Dezember 2020  12:06","7. Januar 2021  15:01","17 Tage 2 Stunden","11,69",3,"0, 1, 2",n-1,"zahlen = new int[3];",int[],"int null;","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 9(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 1; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args){
		int[] queue = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0;i < queue.length;i++){
		Terminal.println(queue[indexOfMax(queue)]);
		queue[indexOfMax(queue)] = Integer.MIN_VALUE;
		}
    }
	public static int indexOfMax(int[] queue){
		int maximum = 0;
		int indexOfMax = 0;
		for(int i = 0; i < queue.length;i++){
			if (queue[i] > maximum){
				maximum = queue[i];
				indexOfMax = i;
			}
		}
		return indexOfMax;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		add(TREES, getUpdate(TREES), END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				if(x[i][j] + y[i][j] <= max){
					x[i][j] = x[i][j] + y[i][j];
				}
				else{
					x[i][j] = 0;
				}
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int [TREES.length][TREES[0].length];
		for(int i = 0;i < 10;i++){
			for(int j = 0;j < 10;j++){
				if(neighborIsOnFire(x, i, j) && (x[i][j]==0)){
					y[i][j] += 1;
				}else if(x[i][j] > 0){
					y[i][j] += 1;
				}
			}
		}
		return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Wontorra,Lara,lara.wontorra@campus.tu-berlin.de,Beendet,"21. Dezember 2020  13:01","9. Januar 2021  20:08","19 Tage 7 Stunden","9,81","zahlen = new int[3];",int[],geca,n-1,3,-3.5,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(11); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 10(11); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 2; Teil 69: %; Teil 70: %; Teil 71: 11(11); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 9(11); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: 4; Teil 84: %; Teil 85: 12(9); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(9); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: -; Teil 105: 2; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array;
        array=new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args) {
    int[] array=Terminal.askIntArray(""Queue:\n"");
    for (int i=0; i<array.length; i++) {
        int max;  
        max=indexOfMax(array);
        System.out.println(array[max]);
        array[max]=Integer.MIN_VALUE;
        
        }
    }
    
    public static int indexOfMax(int[] array) {
        int max=0;
        for(int i=1; i<array.length; i++) {
            if(array[i]>array[max]) max=i;
        }
            return max;
        
    }

}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Abdalla,"Hanen K Moustafa",hanen.abdalla@campus.tu-berlin.de,Beendet,"21. Dezember 2020  14:56","10. Januar 2021  21:09","20 Tage 6 Stunden","9,14",-3.5,"zahlen = new int[3];",int[],n-1,geca,array,"Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 4; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: -; Teil 14: -; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: 4; Teil 44: 0; Teil 45: 0; Teil 46: 0; Teil 47: 0; Teil 48: -; Teil 49: -; Teil 50: 5; Teil 51: %; Teil 52: 1; Teil 53: %; Teil 54: %; Teil 55: -; Teil 56: -; Teil 57: 9; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: -; Teil 63: =; Teil 64: 10; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 2; Teil 70: -; Teil 71: 9; Teil 72: %; Teil 73: %; Teil 74: 1; Teil 75: %; Teil 76: %; Teil 77: -; Teil 78: 10; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: 0; Teil 83: 3; Teil 84: -; Teil 85: 9; Teil 86: %; Teil 87: 1; Teil 88: %; Teil 89: 2; Teil 90: %; Teil 91: -; Teil 92: 12; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: undef; Teil 98: -; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: undef; Teil 105: -; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: undef; Teil 112: 2","public class Framed {
  public static int breite = 6;
  public static int hoehe = 3;
  
  public static void frame() {
//        System.out.println(hoehe);
    char[][] array = new char[breite+2][hoehe+2];
    
    //Hier soll das Array initialisiert werden!
    for (int i = 0; i < (hoehe + 2); i++) {
      for (int j = 0; j < (breite + 2); j++) {
        if ((i == 0 || j == 0) || (i == (hoehe + 1) || j == (breite + 1))) {
          System.out.print(""A"");
          array[j][i] = 'A';
        } else {
          System.out.print(""B"");
          array[j][i] = 'B';
        }
      }
      System.out.print(""\n"");
    }
    
    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");
    
    for (int i = 0; i < (hoehe + 2); i++) {
      for (int j = 0; j < (breite + 2); j++) {
        System.out.print(array[j][i]);
      }
      System.out.print(""\n"");
    }
  }
  public static void main(String[] args){
    Framed.breite=3;
    Framed.hoehe=6;
    Framed.frame();
  }
}","public class Queue {
  
  public static void main(String[] args) {
    int[] x = Terminal.askIntArray(""Queue:\n"");
    int y = 0;
    for (int i = 0; i < x.length; i++) {
      for (int j = i + 1; j < x.length; j++) {
        if (x[j] > x[i]) {
          y = x[i];
          x[i] = x[j];
          x[j] = y;
        }
      }
      Terminal.println(x[i]);
    }
  }
  
  static int indexOfMax(int[] x) {
    int max = 0;
    int index = 0;
    for (int j = 0; j < x.length; j++) {
      if (x[j] > max) {
        max = x[j];
        index = j;
      }
    }
    return index;
  }
  
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Kemmler,"Erich Lorenz Boy",kemmler@campus.tu-berlin.de,Beendet,"21. Dezember 2020  15:43","7. Januar 2021  00:36","16 Tage 8 Stunden","14,55",int[],n-1,geca,3,"zahlen = new int[3];","den gleichen Datentyp.","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: -; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 9(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 10(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: 2; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args){
		
		int [] array = Terminal.askIntArray(""Queue:\n"");
		
		for(int i=0; i<array.length; i++){
			int index = indexOfMax(array);
			Terminal.println(array[index]);
            array[index] =  Integer.MIN_VALUE;
		}
	}
	
	public static int indexOfMax(int arr []) {
		int index = 0;
		int max = arr [index];
		
		for(int i = 0; i < arr.length; i++){
			if(arr[i] > max) {
				max = arr [i];
				index = i;
			}
		}
		return index;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * lasst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
			add(TREES, getUpdate(TREES), END);
	}
	
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {		
		
		for(int i = 0; i < x.length; i++){
			for(int j = 0; j < x[0].length; j++){
				x[i][j] = (x[i][j] + y[i][j])%(max+1);
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int [][] Update = new int [TREES.length][TREES[0].length];
		for (int i = 0; i < Update.length; i++) {
            for (int j = 0; j < Update[i].length; j++) {
				
				if (x[i][j] > TREE){
					Update[i][j] = Update[i][j] +1;
				}
				
				if(((x[i][j] == TREE)&&(neighborIsOnFire(x,i,j)))==true){
					Update[i][j] = Update[i][j] +1 ;
				}
				
				if (x[i][j] > END){
					Update[i][j]= 0;
				}
				
			}
		}
		return Update;
    }
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Kramer,"John Kurt Achim",76f9603c443ba12fadf70dd5369b96a0,Beendet,"21. Dezember 2020  20:25","10. Januar 2021  09:31","19 Tage 13 Stunden","8,60",3,"char string;",n-1,new,geca,int,"Teil 1: 3; Teil 2: undef; Teil 3: undef; Teil 4: undef; Teil 5: undef; Teil 6: -; Teil 7: -; Teil 8: 4; Teil 9: undef; Teil 10: 1; Teil 11: undef; Teil 12: undef; Teil 13: -; Teil 14: -; Teil 15: 5; Teil 16: undef; Teil 17: %; Teil 18: undef; Teil 19: undef; Teil 20: -; Teil 21: fib(a); Teil 22: 5(9); Teil 23: undef; Teil 24: %; Teil 25: undef; Teil 26: undef; Teil 27: 2; Teil 28: %; Teil 29: 5(10); Teil 30: undef; Teil 31: %; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112:","public class Framed {
	public static void main(String[] args) {
	Framed.frame();}
    public static int breite = 6;
    public static int hoehe = 3;

public static void frame() {
        //Hier soll das Array initialisiert werden!
		char[][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }
		System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static void main(String[] args) {
		int[] array= new int[5];
		array= Terminal.askIntArray(""Queue: \n"");
		for (int i=0;i<array.length;i++) {
			System.out.println(array[indexOfMax(array)]);
			array[indexOfMax(array)]=Integer.MIN_VALUE;
		}
	
		 }
	 
    public static int indexOfMax(int[] array) {
		int max=Integer.MIN_VALUE;
		int index=0;
		for (int i=0;i<array.length;i++) {
			
			if(max<array[i]) {
				max=array[i];
				index=i;
			}
		}
	return index;
}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Schellong,"Sören Rafael",r.schellong@campus.tu-berlin.de,Beendet,"22. Dezember 2020  09:53","10. Januar 2021  23:11","19 Tage 13 Stunden","13,65",new,"char string;",geca,"zahlen = new int[3];",3,"1, 2, 3","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 2; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 9(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char array[][] = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main (String[] args) {
		int[] numbers = Terminal.askIntArray(""Queue:\n"");
		for (int i=0; i<numbers.length; i++){
			int ind = indexOfMax(numbers);
			if (ind==-1) {
				break;
			}
			int min = numbers[ind];
			Terminal.println(min);
			 numbers[ind] = Integer.MIN_VALUE;
		}
	}

	
	public static int indexOfMax (int [] nums) {
		int max = nums[0];
		int indMax = 0;
		for(int i=0; i < nums.length;i++) {
			if (max < nums[i]) {
				max = nums[i];
				indMax = i;
			}
		}	if (max == Integer.MIN_VALUE) {
				return -1;
			}
		return indMax;
	}
}","public class Forest {
   

    public static int[][] TREES;
    

    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    

    public static void step() {
		int max = END;
		int[][] SUMME = new int [TREES.length][TREES[0].length];
		SUMME = getUpdate(TREES);
		add(TREES,SUMME,max);		
		
    }  
    

    public static void add(int[][] x, int[][] y, int max) {
		for (int i=0; i<x.length; i++){
			for (int j=0; j<x[i].length; j++) {
				if (0 != (x[i][j]+y[i][j]) % (max+1))
				x[i][j] = x[i][j]+y[i][j];
				else x[i][j] = 0;
			}
		}	
				
			
    }
    

    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int [x.length] [x[0].length];
		for (int i=0; i<x.length; i++){
			for (int j=0; j<x[i].length; j++) {
				if (x[i][j]>0) {
					y[i][j]++;
				}	
					
				else if (x[i][j] == 0 && neighborIsOnFire(x,i,j)==true)
					y[i][j]++;
					
				else y[i][j] = 0; 
				
				
			}
		}	return y;				
	}
    

    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }


    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Taranuschitsch,Kristina,k.taranuschitsch@campus.tu-berlin.de,Beendet,"22. Dezember 2020  10:09","10. Januar 2021  19:09","19 Tage 9 Stunden","14,96",3,"zahlen = new int[3];","den gleichen Datentyp.",geca,3,new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [] [] array = new char [breite+2] [hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
	public static void main(String[] args) {
		
		int [] zahlen = Terminal.askIntArray(""Queue:\n""); 
		
		for (int i = 0; i < zahlen.length; i++) { 
			
			int indexmax = indexOfMax(zahlen);
			
				if (indexmax == -1) {
					break;
				} 
			
				else {	
				Terminal.println(zahlen [indexmax]); 
				zahlen [indexmax] = Integer.MIN_VALUE;
				}	
		}	
		
	}
		
		public static int indexOfMax(int [] zahlen) {
			 int max=0;  
			 

			 for (int i = 0; i < zahlen.length; i++) {
				 
			 if (zahlen[i] > zahlen[max]) {
					 max = i; 
				 }   
			
			 }
			
			if (zahlen[max] == Integer.MIN_VALUE) {   
					max = -1;
				 }
				 
			
			return max; 
			 
		
		}
		

}","public class Forest {
   
    
    public static int[][] TREES;
    
    
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
  
    public static void step() {
	int [][] update = getUpdate(TREES);	
	add(TREES, update, END);
	
    }  
    

    public static void add(int[][] x, int[][] y, int max) {
		for(int i=0;i < x.length;i++){    
			for(int j=0; j< x[i].length;j++){    
				
				if((x[i][j]+y[i][j])%(max+1) == 0) {
				x[i][j] = 0;
				}
				
				else{
				x [i][j] = x[i][j] + y[i] [j];		
					}	
		
		
			}			
		}
    }
    
    
    public static int[][] getUpdate(int[][] x) {
		
		int[][] y = new int [x.length] [x[0].length];
			for(int i = 0; i < x.length; i++) {
				for(int j = 0; j < x[i].length; j++) {
				
					if (x[i][j] > TREE) {
					y[i][j] += 1;
					}	
				
					if(x[i][j] == TREE && neighborIsOnFire(x,i,j) == true) {
					y[i][j] += 1;
					}
	
				}
			}	
		return y;
	} 
    
   
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
  
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Weiß,Jasmina,jasmina.weiss@campus.tu-berlin.de,Beendet,"23. Dezember 2020  11:29","10. Januar 2021  15:20","18 Tage 3 Stunden","9,76","zahlen = new int[3];",int[],n-1,new,3,"1, 1, 2","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 8(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 12(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 13(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: -; Teil 85: 5; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 1,5; Teil 92: 6; Teil 93: -; Teil 94: -; Teil 95: -; Teil 96: -; Teil 97: %; Teil 98: -; Teil 99: 7; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static void main(String[] args) {
		int[] array = Terminal.askIntArray(""Queue: \n"");
		int maxIndex = 0;
		while (maxIndex > -1) {
			maxIndex = indexOfMax(array);
			if (maxIndex > -1) {
				System.out.println(array[maxIndex]);
				array[maxIndex] = Integer.MIN_VALUE;
			}
		}
	}

	public static int indexOfMax(int[] array) {
		int x = 0;
		int maxIndex = -1;
		for (int i = 0; i < array.length; i++) {
			if (array[i] > x) {
				x = array[i];
				maxIndex = i;

			}
		}
		return maxIndex;

	}
}","public class Forest {
		   
	    // Die Wald-Repraesentation
	    public static int[][] TREES = {
	    	     {0, 0, -1, 0, 0, 0, 0, 0, 4, 0},
	    	        {0, -1, -1, 0, 0, 0, 0, 0, -1, 0},
	    	        {-1, -1, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {-1, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
    	        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	    		
	    };
	    
	    
	    
	    // Zustaende der Zellen
	    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
        
	    
	    /**
	     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
	     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
	     * laesst dabei nur Werte kleiner gleich END zu.
	     */
	    public static void step() {
	    	
	    }  
	    
	    /**
	     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
	     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
	     * des Modulo-Operators (%) an.
	     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
	     * @param x Der erste Summand.
	     * @param y Der zweite Summand.
	     * @param max Der Maximalwert der Summe.
	     */
	    //public static void add(int[][] x, int[][] y, int max) {
	    //}
	    
	    /**
	     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
	     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
	     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
	     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
	     * (neighborIsOnFire)
	     * @param x
	     * @return 
	     */
	    public static int[][] getUpdate(int[][] x) {
	        int [][] y = new int [x.length][x.length];
	        
	        
	    	
	    	
	    	
	    }
	    
	    /**
	     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
	     * brennt.
	     * @param x Das Array (der Wald/ die Baeume).
	     * @param i Index der Zelle in der 1.Array-Dimension.
	     * @param j Index der Zelle in der 2. Array-Dimension.
	     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
	     */
	    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
	        for(int k = i-1; k <= i+1; k++) {
	            for(int l = j-1; l <= j+1; l++) {
	                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    }
	    
	    /**
	     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
	     * @param x Der Wert einer Zelle (Zellstatus).
	     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
	     */
	    public static boolean isOnFire(int x) {
	        return x >= FIRE_START && x <= FIRE_END;
	    }
	    
	    /**
	     * Ueberprueft, ob der Index (i,j) im Array x liegt.
	     * @param x Das Array.
	     * @param i Index in der 1.Array-Dimension.
	     * @param j Index in der 2.Array-Dimension.
	     * @return True, wenn der Index im Array existiert, sonst false.
	     */
	    public static boolean indexInBounds(int[][] x, int i, int j) {
	        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
	    }

}"
Korkmaz,Asena,asena.korkmaz@campus.tu-berlin.de,Beendet,"23. Dezember 2020  11:40","10. Januar 2021  16:36","18 Tage 4 Stunden","13,24",n-1,geca,"1, 1, 2",3,-3.5,"zahlen[0] = 1;","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: fib(a); Teil 29: 6; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 7; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 8; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(8); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: i = 2; Teil 56: %; Teil 57: 10(8); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 9; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: i = 2; Teil 70: %; Teil 71: 10; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 5(12); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 13; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
      char [][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main(String[] args) {
       int[] array = Terminal.askIntArray(""Queue:\n"");

       for(int i = 0; i < array.length; i++) {
             int currentHighestIndex = indexOfMax(array);
             Terminal.println(array[currentHighestIndex]);
             array[currentHighestIndex] = Integer.MIN_VALUE;

       }
}
        public static int indexOfMax(int[] intArray){
        	int max = intArray[0];
           int largestIndex = 0;
           for ( int i = 1; i < intArray.length; i++ ) {
            if ( intArray[i] > intArray[largestIndex]) 
            	largestIndex = i;
            if (intArray[i] > max)
            	max = intArray[i];
	}
	if(max == Integer.MIN_VALUE) {
	    return -1;
	    } else {
	         return largestIndex;
	         }
	    }

}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int[][] updatedTrees = getUpdate(TREES);
        add(TREES, updatedTrees, END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for(int i = 0; i < x.length; i++){
            for(int j = 0; j < x[i].length; j++){
                x[i][j] = (x[i][j]+y[i][j])%(max+1);
            }
        }
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x Array zu aktualisieren.
     * @return Update matrix zum addieren.
     */
    public static int[][] getUpdate(int[][] x) {
        int[][]y = new int[x.length][x[0].length];
        for(int i = 0; i < x.length; i++){
            for(int j = 0; j < x[i].length; j++){
                if(x[i][j] > TREE || (x[i][j] == 0 && neighborIsOnFire(x, i, j))){
                    y[i][j] = 1;
                } else{
                    y[i][j] = 0;
                }
            }
        }

        return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Kilic,Ceren,ceren.kilic@campus.tu-berlin.de,Beendet,"23. Dezember 2020  13:38","10. Januar 2021  17:40","18 Tage 4 Stunden","13,87",n-1,"zahlen = new int[3];",geca,3,"den gleichen Datentyp.",new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: undef; Teil 14: undef; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 5; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 6; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 7; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 8; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 10; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 11; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 12; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 13; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];//Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main(String[] args) {
       int[] array = Terminal.askIntArray(""Queue:\n"");
	
       for(int i = 0; i < array.length; i++) {
             int indexhigh = indexOfMax(array);
             Terminal.println(array[indexhigh]);
             array[indexhigh] = Integer.MIN_VALUE;
		
       }
}
        public static int indexOfMax(int[] array){
        	int a = 0;
		int maximumwert = array[0];
           
           for ( int i = 1; i < array.length; i++ ) {
            if ( array [i] > maximumwert ) {
		maximumwert = array[i];
		a= i;
            	}
	}
	boolean c= maximumwert == Integer.MIN_VALUE;
if(c) {
	    return -1;
	    } else {
	         return a;
	         }
	    }

}","public class Forest {
   
        public static int[][] TREES;
    
    
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    
    public static void step() {
        int[][] treesNew = getUpdate(TREES);
        add(TREES, treesNew, END);
    }  
    
    
    public static void add(int[][] x, int[][] y, int max) {
        for(int a = 0; a < x.length; a++){
            for(int b = 0; b < x[a].length; b++){
                x[a][b] = (x[a][b]+y[a][b])%(max+1);
            }
        }
    }
    
    
    public static int[][] getUpdate(int[][] x) {
        int[][]y = new int[x.length][x[0].length];
        for(int a = 0; a < y.length; a++){
            for(int b = 0; b < y[a].length; b++){
boolean z = x[a][b] > TREE;
                if(z)
                    y[a][b] = 1;
boolean c= x[a][b] == 0 && neighborIsOnFire(x, a, b);
                if(c)
                    y[a][b] = 1;
            }
        }

        return y;
    }
    
       public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
   
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Ohlendorf,Lasse,b8ec4bc7fa13cac6e41f2b7afb9c79c8,Beendet,"23. Dezember 2020  16:16","10. Januar 2021  20:24","18 Tage 4 Stunden","10,75","den gleichen Datentyp.",n-1,int[],"1, 1, 2",-3.5,geca,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: 2; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: v; Teil 90: -; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: -; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];//Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args){
        
        int temp;
        int[] num = Terminal.askIntArray(""Queue:\n"");
        int count = num.length;
        for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) 
            {
                if (num[i] < num[j]) 
                {
                    temp = num[i];
                    num[i] = num[j];
                    num[j] = temp;
                }
            }
        }
        
        for (int i = 0; i < count - 1; i++) 
        {
            Terminal.println(num[i]);
        }
        Terminal.println(num[count - 1]);
    }
    
    public static int indexOfMax(int[] num ){
        if ( num == null || num.length == 0 )
        return -1; 
        int Max = 0;
        for ( int i = 1; i < num.length; i++ ){
         if ( num[i] > num[Max] ) Max = i;
        }
        return Max; 
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Ardisson,"Maxim Dimitri",ardisson@campus.tu-berlin.de,Beendet,"24. Dezember 2020  02:00","10. Januar 2021  23:59","17 Tage 21 Stunden","13,14","den gleichen Datentyp.",int[],-3.5,3,new,geca,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 12(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 5; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 2.0; Teil 99: 6; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: -; Teil 112: -","public class Framed {

    public static int breite = 6;
    public static int hoehe = 3;

    public static void main(String[] args) {
      frame();
    }

    public static void frame() {
        //Hier soll das Array initialisiert werden!
      char[][] array = new char[breite+2][hoehe+2];

	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A';
			    }
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{

  public static void main(String[] args) {
    int[] zahlen = Terminal.askIntArray(""Queue:\n"");
    while (isAllEqual(zahlen)==false){
    int max = indexOfMax(zahlen);
    System.out.print(zahlen[max]+""\n"");
    zahlen[max] = Integer.MIN_VALUE;
  }
  }

  public static int indexOfMax(int[] array){

    if(array == null || array.length == 0) return -1;


    int indexLargest = 0;
    for (int i = 1; i < array.length; i++){
    if(array[i] > array[indexLargest]) indexLargest = i;
    }
    if(isAllEqual(array)) return -1;
    return indexLargest;
  }

  public static boolean isAllEqual(int[] a){
       for(int i=1; i<a.length; i++){
           if(a[0] != a[i]){
               return false;
           }
       }

       return true;
   }

}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
     public static void step() {
 //omfg
        int[][] tree = new int[TREES.length][TREES.length];
        int positionswert;
        for(int k = 0; k<TREES.length; k++){
            for(int l = 0; l < TREES[k].length; l++){
                positionswert = TREES[k][l];
                if(positionswert < 0){
                    tree[k][l] = positionswert;
                }
                else{
            if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l))) tree[k][l]=1;
            if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l)==false)) tree[k][l]=0;
            if (positionswert == 6) tree[k][l]=0;
            if ((positionswert > 0) && (positionswert < 6)){
                tree[k][l] = positionswert + 1;
            }
        }
    }
 }

 TREES = tree;
     }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Gosling,"Kian Peter",gosling@campus.tu-berlin.de,Beendet,"26. Dezember 2020  22:19","10. Januar 2021  22:33","15 Tage","4,41",new,"den gleichen Datentyp.","0, 1, 1",-3.5,n-1,3,"Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 2; Teil 9: -; Teil 10: -; Teil 11: -; Teil 12: -; Teil 13: -; Teil 14: -; Teil 15: 3; Teil 16: 0; Teil 17: 0; Teil 18: 0; Teil 19: 0; Teil 20: -; Teil 21: -; Teil 22: 4; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: -; Teil 28: -; Teil 29: 5; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: -; Teil 35: undef; Teil 36: 8(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: -; Teil 42: %; Teil 43: 9(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 2; Teil 49: %; Teil 50: 10(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: 1.5; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 6; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: -; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: -; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char[100][100]; //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
public static void main (String[] args) {
    int[] array;
    array = Terminal.askIntArray(""Queue:\n"");
    
    for(int i = 0; i < array.length-1; i++) {
        int index = indexOfMax(array); 
        Terminal.println(array[index]); 
        array[index] = Integer.MIN_VALUE;
    }
    
}

public static int indexOfMax(int[] a) {
        int currentIndex = 0; 
        int sum = 0; 
        for(int i = 0; i == (a.length - 2); i++) {
            if(a[i] > a[i+1]) {
                currentIndex = i;
            } else if(a[i] < a[i+1]) {
                currentIndex = i+1; 
            }
        }
        
        if(a[0] == Integer.MIN_VALUE) {
            for(int i = 0; i >= a.length; i++) {
                int nextInt = a[i]; 
                sum = sum + nextInt; 
            }
            if(sum == Integer.MIN_VALUE * a.length) {
                return -1; 
            }
        } 
        
        return currentIndex; 
    }

}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    public static int[][] updateMatrix;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int length = TREES.length; 
        int height = TREES[0].length; 
        for(int x = 0; x >= length; x++) {
            for(int y = 0; y >= height; y++) {
                if(TREES[x][y] > 0 && TREES[x][y] < 7) {
                    updateMatrix[x][y] = TREES[x][y] + 1;
                } else if(TREES[x][y] == 0) {
                    if(neighborIsOnFire(TREES, y, x) == true) {
                        updateMatrix[x][y] = 1;
                    }
                } else if(TREES[x][y] > 6) {
                    TREES[x][y] = 0; 
                }
            }
            
        }
        getUpdate(TREES);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static void getUpdate(int[][] x) {
        for(int i = 0; i <= TREES.length; i++) {
            for(int j = 0; j <= TREES.length; j++) {
                TREES[i][j] = TREES[i][j] + updateMatrix[i][j];
            }
        }
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Mittelstädt,"Lina Sophia",l.mittelstaedt@campus.tu-berlin.de,Beendet,"27. Dezember 2020  12:45","10. Januar 2021  23:59","14 Tage 11 Stunden","10,14","den gleichen Datentyp.","zahlen = new int[3];",Compilerfehler,"char string;",-3.5,geca,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    	public static void main(String[] args) {
		frame();
	}
    
    public static void frame() {
      char[][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue { 
    public static void main (String[] args) {
	int [] array =Terminal.askIntArray(""Queue:\n"");
		for (int i =0; i <array.length;i++){
			int index = indexOfMax (array);
			if (index ==-1) {
				break;
			}
		
			System.out.println(array[index]);
			array[index] = Integer.MIN_VALUE;
		}
	}
	
	public static int indexOfMax (int[] array) {
		int index = -1;
		int biggest=0;
		for(int i=0;i<array.length;i++) {
			if (array[i] > biggest) {
				biggest = array [i];
				index = i;
			}
		}
	
		return index;
    
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Chaudhary,Pradeep,p.chaudhary@campus.tu-berlin.de,Beendet,"27. Dezember 2020  13:09","10. Januar 2021  23:51","14 Tage 10 Stunden","7,15",int[],3,geca,3,"zahlen = new int[3];",new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 9(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 10(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 4; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: -; Teil 77: %; Teil 78: 12(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 5; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 2.0; Teil 99: 6; Teil 100: -; Teil 101: -; Teil 102: -; Teil 103: -; Teil 104: %; Teil 105: -; Teil 106: ; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
"Mailhos Nogues","Lucas Fel",642dc2fc24f2168530e7533d52e691ae,Beendet,"27. Dezember 2020  13:35","7. Januar 2021  22:25","11 Tage 8 Stunden","13,19","boolean if;","zahlen = new int[3];",int[],n-1,2,"0, 1, 2","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 1; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main (String[] args) {
        int[] array = Terminal.askIntArray(""Queue:\n"");


        for(int i = 0; i < array.length; i++) {
            System.out.println(array[indexOfMax(array)]);
            array[indexOfMax(array)] = Integer.MIN_VALUE;
        }
    }


    public static int indexOfMax (int[] x){
        int max = x[0];
        int index = 0;
        for (int i = 1; i < x.length; i++) {
            if (x[i] > max) {
                max = x[i];
                index = i;
            }
        }
        //if ((int)max > Integer.MIN_VALUE) {
            return index;
        //}else {
        //    return -1;
        }
}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */

    public static void step() {
        //int[][] newTrees = new int[x[1].length][x[2].length];
        int[][] updateM = fireMatrix(TREES);

        for (int i = 0; i < TREES[1].length; i++) {
            for (int j = 0; j < TREES[2].length; j++) {

                if (TREES[i][j] > 0 && TREES[i][j] < 6) {
                    TREES[i][j] = TREES[i][j] + 1;
                }else if(TREES[i][j] == 0 && updateM[i][j] == 1){
                    TREES[i][j] = TREES[i][j] +1;
                }else if(TREES[i][j] == 6){
                    TREES[i][j] = 0;

                }
            }
            ;
        }
    }

    public static int[][] fireMatrix(int[][] x) {
        int[][] updateM = new int[x[1].length][x[2].length];

        for (int i = 0; i < x[1].length; i++) {
            for (int j = 0; j < x[2].length; j++) {
            if (neighborIsOnFire(TREES, i, j)){
                updateM[i][j] = 1;
                }else{
                updateM[i][j] = 0;
                }

            }
        }
        return updateM;
    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
//    public static void add(int[][] x, int[][] y, int max) {
//        int[][] newTrees = new int[TREES[1].length][TREES[2].length];
//
//        for (int i = 0; i < TREES[1].length; i++) {
//            for (int j = 0; j < TREES[2].length; j++) {
//               newTrees[i][j] = x[i][j] + y[i][j];
//            }
//        }
//    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
//    public static int[][] getUpdate(int[][] x) {
//        int[][] updateMatrix = new int[x[1].length][x[2].length];
//
//        for (int i = 0; i < x[1].length; i++) {
//            for (int j = 0; j < x[2].length; j++) {
//                if (x[i][j] > 0) {
//                    updateMatrix[i][j] = x[i+1][j+1];
//                }else if(x[i][j] == 0 && neighborIsOnFire(TREES, i, j)){
//                    updateMatrix[i][j] = x[i+1][j+1];
//                }else if(x[i][j] == 6){
//                    updateMatrix[i][j] = 0;
//                }
//            }
//            ;
//        }
//    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Aung,Okkar,okkar.aung@campus.tu-berlin.de,Beendet,"27. Dezember 2020  18:27","10. Januar 2021  23:59","14 Tage 5 Stunden","10,19","1, 1, 2",-3.5,geca,Compilerfehler,n-1,new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: -; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 1,5; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
public static void main (String[] args) {
	frame();
}
	
        public static void frame () {

        char [] [] array = new char [breite+2] [hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
 public static void main (String[] args) {
   
   int [] queue =  Terminal.askIntArray(""Queue: \n"");
   for (int i=0; i<queue.length;i++){
	 int index = indexOfMax(queue);
	 if(index == -1) {
	 break;
	 }
	 System.out.println(queue[index]);
	 queue[index] = Integer.MIN_VALUE;
	 
	 
   }

 }

public static int indexOfMax(int[] intArray) {
   if (intArray.length == 0 || intArray == null)
   return -1;

   int largestNumber = 0;
   for (int i=1; i < intArray.length; i++) {
     if (intArray[i]>intArray[largestNumber])
     largestNumber = i;

   }
   return largestNumber;
 }


}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Bloch,"Céline Louisa",c.bloch.1@campus.tu-berlin.de,Beendet,"28. Dezember 2020  16:12","10. Januar 2021  23:59","13 Tage 7 Stunden","9,45","zahlen = new int[3];",-3.5,3,Compilerfehler,geca,3,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1+b[0]; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 9(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 10(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: b[2]+1; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 4; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: undef; Teil 68: undef; Teil 69: -; Teil 70: %; Teil 71: 12(5); Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: 13(5); Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: 11(5); Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: 12(5); Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: 5; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: 6; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112:","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue { 
    public static void main ( String[] args) {
    int [] array = Terminal.askIntArray (""Queue:\n"");
        for (int i = 0; i < array.length;i++){
            int index = indexOfMax (array);
            if (index == -1) {
                break;
            }

            System.out.println(array[index]);
            array[index] = Integer.MIN_VALUE;
        }
    }
    public static int indexOfMax (int[] array) {
        int index = -1;
        int biggest = 0;
        for(int i=0;i<array.length;i++) {
            if (array[i] > biggest) {
                biggest = array [i];
                index = i;
            }
        }
        return index;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Seidel,Frithjof,frithjof.seidel@campus.tu-berlin.de,Beendet,"30. Dezember 2020  18:31","3. Januar 2021  14:14","3 Tage 19 Stunden","14,69",-3.5,"zahlen = new int[3];",geca,"char string;",3,n-1,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][]array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
	public static void main (String[] args) {
		int[] array = Terminal.askIntArray(""Queue:\n""); //erfragt Integer-Array
		for (int i=0; i<array.length;i++) {
			System.out.println(array[indexOfMax(array)]);
			array[indexOfMax(array)]=Integer.MIN_VALUE;
		}

    }
	
	public static int indexOfMax (int[] a) { //extrahiert Index des groessten Elements
		int max = 0;
		int index = 0;
		for (int i=0; i<a.length;i++) {
			if (a[i]>max) {
				max = a[i];
				index = i;
			}
		}
		if (a[index]<0) {
			return -1;
		}
		return index;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
	// 10x10
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		add(TREES,getUpdate(TREES),END);
		return;
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for (int i=0; i<x.length; i++) {
			for (int j=0; j<x[i].length; j++) {
				x[i][j]=(x[i][j]+y[i][j])%(max+1);
			}
		}
		return;
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return y
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int [x.length][x.length];
		for (int i=0; i<x.length;i++){
			for (int j=0; j<x[i].length;j++) {
				if ( (TREES[i][j] > TREE) || ((TREES[i][j]==TREE) && neighborIsOnFire(TREES,i,j))) {
					y[i][j]=1;

				}
				else {
					y[i][j]=0;
				}
			}
		}
		return y; //gibt die Aktualisierungs-Matrix zurück
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Morsalpoor,Mohadese,m.morsalpoor@tu-berlin.de,Beendet,"1. Januar 2021  11:56","10. Januar 2021  22:34","9 Tage 10 Stunden","10,74",new,-3.5,3,"den gleichen Datentyp.","1, 1, 2",int[],"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{
	public static void main(String[] args){
	    int[] warteschlange= Terminal.askIntArray(""Queue:\n"");
	      for(int i=0; i<warteschlange.length; i++){
			int index= indexOfMax(warteschlange);
			Terminal.println(warteschlange[index]);
			warteschlange[index]=Integer.MIN_VALUE;
			
			
		}
			
		
	}
	public static int findMax(int[] a){
		int max= a[0];
		for(int i=1; i<a.length;i++){
			if(a[i]>max){
				max=a[i];
			}
		}
		return max;
	}
	
	public static int indexOfMax(int[] a){
        int max = findMax(a);
        for(int i = 0; i < a.length; i++){
            if(a[i] == max) 
               return i;
		}		
		return -1;
		
		
		
     
		
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int m=TREES.length;
		int n=TREES[m].length;
		int[][]x=new int[m][n];
	    add(getUpdate(x),TREES,END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
          for(int i=0;i<x.length;i++){
			for(int j=0;j<x[i].length;j++){
				if(x[i][j]+y[i][j]<=max){
					x[i][j]=(x[i][j]+y[i][j])%(max+1);
				}
				
			}
			
		
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
        int m=x.length;
		int n=x[m].length;
		int[][] y= new int[m][n];
		for(int i=0;i<x.length;i++){
			for(int j=0;j<x[i].length;j++){
				if(x[i][j]>TREE || (x[i][j]==TREE && neighborIsOnFire(x,i,j)==true)){
					y[i][j]=x[i][j];
				}
				
			}
			
		
		}
		return y;
   }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Terziyska,Radina,r.terziyska@campus.tu-berlin.de,Beendet,"1. Januar 2021  12:24","10. Januar 2021  23:59","9 Tage 11 Stunden","7,60","zahlen = new int[3];","int null;","den gleichen Datentyp.",int,"{1,2}",new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: %; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: undef; Teil 17: 1; Teil 18: undef; Teil 19: undef; Teil 20: %; Teil 21: %; Teil 22: 2(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 3(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 4(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 1; Teil 43: 5; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 6; Teil 51: -; Teil 52: -; Teil 53: -; Teil 54: -; Teil 55: %; Teil 56: -; Teil 57: 7; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 8; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 2; Teil 77: %; Teil 78: 10; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 11; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 12; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 13; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+ 2][hoehe+ 2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String[] args) {
    	int[] inputArray = Terminal.askIntArray(""Queue:\n"");
    	int maxIndex = indexOfMax(inputArray);
    	
    	while (maxIndex != -1) {
    		Terminal.println(inputArray[maxIndex]);
    		inputArray[maxIndex] = Integer.MIN_VALUE;
    		maxIndex = indexOfMax(inputArray);
    	}
    	
    }

	public static int indexOfMax(int[] array) {
		int max = array[0];
		int index = -1;
		
		for (int i = 0; i < array.length; i++) {
			if (array[i] >= max) {
				if (array[i] != Integer.MIN_VALUE) {
					max = array[i];
					index = i; 
				}
			}
		}

		return index;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Hofmann,Timo,timo.hofmann@campus.tu-berlin.de,Beendet,"2. Januar 2021  03:29","10. Januar 2021  20:32","8 Tage 17 Stunden","14,45","zahlen = new int[3];","den gleichen Datentyp.",-3.5,"1, 1, 2",int[],3,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: -; Teil 77: %; Teil 78: 12(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 5; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 2.0; Teil 99: 6; Teil 100: -; Teil 101: -; Teil 102: -; Teil 103: -; Teil 104: %; Teil 105: -; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String[] args){

        int[] array = Terminal.askIntArray(""Queue:\n"");

        int abort = 0;

        for (int i = 0; abort != -1; i++){

            int index_max = indexOfMax(array);

            Terminal.println(array[index_max]);
            array[index_max] = Integer.MIN_VALUE;

            abort = indexOfMax(array);
        }
    }

    public static int indexOfMax(int[] array){

        boolean b = true;

        for (int i = 0; i < array.length; i++){

            if (array[i] != Integer.MIN_VALUE){

                b = false;
                break;
            }
        }

        if (b) {

            return -1;
        }

        int max = 0;
        int max_index = 0;

        for (int i=0; i < array.length; i ++){

            if (array[i] > max){

                max = array[i];
                max_index = i;
            }
        }
        return max_index;
    }
}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {

        add(TREES, getUpdate(TREES), END);
    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {

        for (int i = 0; i < x.length; i++){

            for (int j = 0; j < x[i].length; j++){

                x[i][j] = (x[i][j] + y[i][j]) % (max + 1);
            }
        }
    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    public static int[][] getUpdate(int[][] x) {

        int hoehe = x.length;
        int breite = x[0].length;

        int[][] y = new int[hoehe][breite];

        for (int i = 0; i < hoehe; i++){

            for (int j = 0; j < breite; j++){

                if ((x[i][j] > TREE) || (x[i][j] == TREE && neighborIsOnFire(x, i, j)) ){

                    y[i][j] = 1;
                }
            }
        }
        return y;
    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Todorovski,Adrian,adrian.todorovski@campus.tu-berlin.de,Beendet,"3. Januar 2021  16:08","10. Januar 2021  17:11","7 Tage 1 Stunde","9,61","1, 1, 2",int[],geca,"zahlen = new int[3];",3,3,"Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 2; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: 3; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 4; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 5; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 6; Teil 37: -; Teil 38: -; Teil 39: -; Teil 40: -; Teil 41: -; Teil 42: -; Teil 43: 8; Teil 44: undef; Teil 45: undef; Teil 46: undef; Teil 47: undef; Teil 48: undef; Teil 49: undef; Teil 50: 9; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 2; Teil 56: %; Teil 57: 9; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 9; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 10; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 11; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 12; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 13; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: -; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
	public static void main (String[] args) {
		frame();
	}
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");
		
	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	
	public static void main (String[] args) { 
		
	int[] array = Terminal.askIntArray(""Queue:\n"");
	for(int i = indexOfMax(array); i> -1 ; i = indexOfMax(array))	{
		System.out.println(array[i]);
		array[i] = Integer.MIN_VALUE;
	}
	
	}
	
	
		public static int indexOfMax(int[] array) {
			int max = Integer.MIN_VALUE;
			int index = -1;
			for(int i = 0; i< array.length; i++) {
			if (array[i]>max) {
				max = array[i];
				index = i;
				
			}
		}
		
			return index;
		}


}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Skodlerak,Torben,skodlerak@tu-berlin.de,Beendet,"4. Januar 2021  10:11","10. Januar 2021  21:31","6 Tage 11 Stunden","14,43",geca,int[],3,new,"den gleichen Datentyp.",n-1,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: 0; Teil 17: 1; Teil 18: 1; Teil 19: 2; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: -; Teil 49: %; Teil 50: 12(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 8(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 9(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 3; Teil 70: %; Teil 71: 10(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
	public static void main (String[] args) {
		
		frame(); 
		
	}
		
    public static void frame() {
        int [] [] array = new int [breite+2] [hoehe+2]; //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	   for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                if ((i == 0 || j == 0) || (i == (hoehe+1) || j == (breite+1))) {
					System.out.print (""A""); 
					array [j] [i] = 'A'; 
				}
				else { 
					System.out.print (""B"");
					array [j] [i] = 'B';
				}
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args){
        
        int temp;
        int[] num = Terminal.askIntArray(""Queue:\n"");
        int count = num.length;
        for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) 
            {
                if (num[i] < num[j]) 
                {
                    temp = num[i];
                    num[i] = num[j];
                    num[j] = temp;
                }
            }
        }
        
        for (int i = 0; i < count - 1; i++) 
        {
            Terminal.println(num[i]);
        }
        Terminal.println(num[count - 1]);
    }
    
    public static int indexOfMax(int[] num ){
        if ( num == null || num.length == 0 )
        return -1; 
        int Max = 0;
        for ( int i = 1; i < num.length; i++ ){
         if ( num[i] > num[Max] ) Max = i;
        }
        return Max; 
        
    }
}","public class Forest {
    public static int[][] TREES;
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    public static void step() {
                add(TREES,getUpdate(TREES),END);
    }  
    public static void add(int[][]x, int[][]y, int max){
         for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){ 
                    x[i][j] = (x[i][j] + y[i][j])%(max+1);
                 
            }
       }
    }
    public static int[][] getUpdate(int [][]x){
        int[][] y= new int[TREES.length][TREES.length];
        for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){
                if( x[i][j] > TREE || x[i][j] == TREE && neighborIsOnFire(TREES,i,j)){
                y[i][j]=1;
                }
                else{
                    y[i][j]=0;
                }
            } 
        }
        return y;
    }
    
	
	
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Lindner,Lucie-Marie,l.lindner@campus.tu-berlin.de,Beendet,"4. Januar 2021  15:24","9. Januar 2021  22:58","5 Tage 7 Stunden","14,24",3,"1, 1, 2",n-1,"char string;",3,new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 7(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 8(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 9(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 7(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 8(5); Teil 58: %; Teil 59: %; Teil 60: 1; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 9(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 7(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 8(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 9(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: 2; Teil 90: %; Teil 91: %; Teil 92: 11(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
        int[] a = Terminal.askIntArray(""Queue:\n"");
        int maxIndex = Queue.indexOfMax(a);
        while (maxIndex != -1) {
            System.out.println(a[maxIndex]);
            a[maxIndex] = Integer.MIN_VALUE;
            maxIndex = Queue.indexOfMax(a);
        }


    }

    public static int indexOfMax(int[] a) {
        int index = 0;
        for (int i = 1; i < a.length; i++) {
            if (a[index] < a[i]) { 
                index = i;
            }
        }
        if (a[index] == Integer.MIN_VALUE) {
            return -1;
        }
        return index;
    }

}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;


    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        Forest.add(TREES, Forest.getUpdate(TREES), 6);
    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     *
     * @param x   Der erste Summand.
     * @param y   Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                x[i][j] = (x[i][j] + y[i][j]) % (max+1);
                //System.out.println(x[i][j]+ "" = "" +  x[i][j] + "" + "" + y[i][j]);
            }
        }
    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     *
     * @param x
     */
    public static int[][] getUpdate(int[][] x) {
        int[][] update = new int[x.length][x.length];
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                if (x[i][j] > 0) {
                    update[i][j] = 1;
                }
                if (x[i][j] == 0 && Forest.neighborIsOnFire(x, i, j)) {
                    update[i][j] = 1;
                }
                //System.out.println(i + ""x"" + j + "": "" + x[i][j]);
            }
        }
        return update;
    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     *
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for (int k = i - 1; k <= i + 1; k++) {
            for (int l = j - 1; l <= j + 1; l++) {
                if (indexInBounds(x, k, l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     *
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     *
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Padberg,"Ruben Bernhard",ruben.padberg@campus.tu-berlin.de,Beendet,"4. Januar 2021  18:57","10. Januar 2021  21:51","6 Tage 2 Stunden","13,26",3,"char string;",int[],new,"den gleichen Datentyp.",8.5,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 2; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 9(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 5; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 2; Teil 99: 6; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static void main (String[] args){
		int[] numbers = Terminal.askIntArray(""Queue:\n"");
		for(int i=0; i<numbers.length; i++){		
			int currentHighestIndex = indexOfMax(numbers);
			System.out.println(numbers[currentHighestIndex]);
			numbers[currentHighestIndex]=Integer.MIN_VALUE;
		}
		
	}
		
	public static int indexOfMax (int[] numbers){
		int maxValue = numbers[0];
		int index = 0;
		
			for(int a = 0; a < numbers.length; a++) {
				if(maxValue < numbers[a]) {
				maxValue = numbers[a];
				index = a;
				}		
			}
			if(maxValue==Integer.MIN_VALUE){
				return -1;
			}
			else{
				return index;
			}
		}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
	 *
	 * This method should simulate one time unit and has to be implemented.
	 * SUGGESTION: add (add) the result of getUpdate to TREES and allow only values <= END.
     */
    public static void step() {
		Forest.add(Forest.TREES, Forest.getUpdate(Forest.TREES), END);
		
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
	 
	 * SUGGESTION: add the elements of y to the elements of x if the sum is <= max. for that you can use the modulo operator (%). x=(x+y)%(max+1)
	 * @param x the first summand
	 * @param y the second summand
	 * @param max the maximum value of the sum.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for(int i=0; i<x.length; i++){
			for(int j=0; j<x[i].length; j++){
				x[i][j]=x[i][j]+y[i][j];
				x[i][j]=(x[i][j])%(max+1);
			}
		}
	}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
	 *
	 * SUGGESTION: Calculates the summand to update the Forest.
	 * for that another array y of the size of x is created.
	 * if a cell in x contains a value > TREE or the value is equal to TREE and a neighbor of the cell burns (neighborIsOnFire)
	 * @param x
	 * @return
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int[x.length][x[0].length];
		for(int i=0; i<x.length; i++){
			for(int j=0; j<x[i].length; j++){
				if(x[i][j]>0 || (x[i][j]==0 && Forest.neighborIsOnFire(x,i,j)==true)){
					y[i][j]=1;
				}
				else y[i][j]=0;
				}
			}
		return y;
	
	}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
	 *
	 * Checks if a (Moore-)neighbor of the cell with index (i,j) inside the array x burns.
	 * @param x the array (the forest/ the trees).
	 * @param i index of the cell 1. dimension.
	 * @param j index of the cell 2. dimension.
	 * @return True, if the neighbor of a cell burns, false, if no neighbor burns.
	 *
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
	 *
	 * checks, if the status value x represents a fire.
	 * @param x the value of a cell (cell status).
	 * @return True if the value represents a fire, when not false
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
	 *
	 *checks, if the index (i,j) is inside the Array x.
	 * @param x the array.
	 * @param i index of the 1. array dimension.
	 * @param j index of the 2. array dimension.
	 * @return true, if the index exists inside the array, when not false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}

	/**
	* WHAT TO DO:
	* the forest is simulated as an 2D array, TREES, the variable is already given and is intitialized outside the program.
	* the value of a cell stands for it's condition:
	* <0 stone
	* 0 fully grown tree
	* 1-3 burning tree
	* 4-6 growing tree
	*
	* you are requested to write the step method (the method head is given) that simulates one time unit according to the following rules.
	* when calling the method:
	* every value > 0 in TREES becomes +1 higher
	* every value equal 0 increases by 1, if a neighbor cell has a value between 1 and 3
	* contains a cell a value > 6, it'S value becomes 0 (so that a growing tree becomes a fully grown tree)
	* 
	* Hint:
	* Forest doesn't need a main method (look RunForest).
	*/"
Korn,"Eric Rene",eric.korn@campus.tu-berlin.de,Beendet,"5. Januar 2021  12:09","10. Januar 2021  13:13","5 Tage 1 Stunde","14,27",3,-3.5,new,"1, 1, 2",3,"char string;","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 2; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 9(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: 2.0; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
		int[] array = Terminal.askIntArray(""Queue:\n"");
		int min = Integer.MIN_VALUE;
		int index = 0;
		do {
			index = indexOfMax(array);
			if (index != (-1)) {
				System.out.println(array[index]);
				array[index] = min;
			}
		} while (index != (-1));
	}
	
	public static int indexOfMax(int[] a) {
		int count = 0;
		int max = 0;
		int maxIndex = 0;
		for (int i = 0; i < a.length; i++) {
			if (a[i] == Integer.MIN_VALUE) {
			count ++;
			}
			else if (a[i] > max) {
			max = a[i];
			maxIndex = i;
			}
		}
		if (count == a.length)
		return -1;
		else
		return maxIndex;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        TREES = getUpdate(TREES);
    }  
    
    public static int[][] getUpdate(int[][] x) {
        int[][] y = new int[x.length][x[0].length];
		for (int i = 0; i < x.length; i++) {
			for (int j = 0; j < x[i].length; j++) {
				int zahl = x[i][j];
				if (zahl == 0 && neighborIsOnFire(x, i, j)) {
					y[i][j] = FIRE_START;
				} else if (zahl == 6) {
					y[i][j] = TREE;
				} else if (zahl > 0) {
					y[i][j] = zahl + 1;
				} else {
                    y[i][j] = x[i][j];
                }
			}
		}
		return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Latz,"Simon Leonhard",s.latz@campus.tu-berlin.de,Beendet,"5. Januar 2021  14:12","10. Januar 2021  20:24","5 Tage 6 Stunden","13,94",int[],geca,3,-3.5,new,"zahlen = new int[3];","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 12(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 5; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 2.0; Teil 99: 6; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{
  public static void main(String[] args) {
    int[] nummer = Terminal.askIntArray(""Queue:\n"");
    while (isAllEqual(nummer)==false){
    int max = indexOfMax(nummer);
    System.out.print(nummer[max]+""\n"");
    nummer[max] = Integer.MIN_VALUE;
    }
  }
  public static int indexOfMax(int[] array){
      if(array == null || array.length == 0) return -1;
      int indexLargest = 0;
      for (int i = 1; i < array.length; i++){
      if(array[i] > array[indexLargest]) indexLargest = i;
    }
    if(isAllEqual(array)) return -1;
    return indexLargest;
  }
  public static boolean isAllEqual(int[] a){
       for(int i=1; i<a.length; i++){
           if(a[0] != a[i]){
               return false;
           }
       }
       return true;
   }

}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
     public static void step() {
   int[][] tree = new int[TREES.length][TREES.length];
   int positionswert; //der aktuelle Eintrag
   for(int k = 0; k<TREES.length; k++){
   for(int l = 0; l < TREES[k].length; l++){
   positionswert = TREES[k][l];
   if(positionswert < 0){
   tree[k][l] = positionswert;
   }
   else{
   if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l))) tree[k][l]=1;
   if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l)==false)) tree[k][l]=0;
   if (positionswert == 6) tree[k][l]=0;
   if ((positionswert > 0) && (positionswert < 6)){
   tree[k][l] = positionswert + 1;
   }
   }
   }
   }
   //zurück in TREES
   TREES = tree;
       }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    //public static int[][] getUpdate(int[][] x) {
    //}

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Lietz,"Leonie Luisa",leonie.lietz@campus.tu-berlin.de,Beendet,"5. Januar 2021  16:06","10. Januar 2021  13:34","4 Tage 21 Stunden","14,48","den gleichen Datentyp.",3,new,3,"1, 1, 2",int[],"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: 0; Teil 17: 1; Teil 18: 0; Teil 19: 0; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: -; Teil 94: -; Teil 95: -; Teil 96: -; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char['A']['B'];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main(String[] args) {
		int [] x = Terminal.askIntArray("""");
		Terminal.println(""Queue:"");
		
		for (int i = indexOfMax(x); i < x.length; i = indexOfMax(x)){
			Terminal.println(x[i]);
			x[i] = Integer.MIN_VALUE;
			i = indexOfMax(x);
			if (x[i] < 0){
				break;
			}
		}
    }

	public static int indexOfMax(int[] y) {
		int largest = 0; 
		for(int i = 0; i < y.length; i++ ){
			if ( y[i] > y[largest] ) largest = i;
		}
		return largest;
    }
	
	
	
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;

    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		int [][] trees = Forest.TREES;
		Forest.TREES = add(trees, getUpdate(trees), END);
		}  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int [][] add(int[][] x, int[][] y, int max) {
		for(int i = 0; i< x.length; i++){
			for(int j =0; j < x[0].length; j++){
				x[i][j] = (x[i][j] + y[i][j])%(max + 1);
			}
		}
		return x;
		
	}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
	 
    public static int[][] getUpdate(int[][] x) {
		int a = x.length; 
		int b = x[0].length;
		int [][] y = new int [a][b]; 
		for(int i = 0; i < a; i++) {
			for( int j = 0; j< b; j++) {
				//Terminal.println(x[i][j]);
				//Terminal.println(x[i][j] > TREE);
				if ( x[i][j] > TREE) {
					y[i][j] = 1;
				}
				else if (neighborIsOnFire(x, i, j) == true && x[i][j]==0){
					y[i][j] = 1;
				}
				else {
					y[i][j] = 0;
				}
			}
		}
		return y;
		
	}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Hogel,Stephan,2d485c3a9c60231ba2c51ed3cb4b4cdb,Beendet,"5. Januar 2021  17:31","10. Januar 2021  15:18","4 Tage 21 Stunden","10,49","char string;",3,"den gleichen Datentyp.",-3.5,int[],geca,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: -; Teil 24: -; Teil 25: -; Teil 26: -; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
		int[] queue = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0; i < queue.length; i++) {
			int index = indexOfMax(queue);
			Terminal.println(queue[index]);
			queue[index] = -1;
		}
		
	}
	
	public static int indexOfMax(int[] que) {
		int indexOflargest = 0;
		if(que == null || que.length == 0) {
			return -1;
		}
		for(int i = 1; i < que.length; i++) {
			if(que[i] > que[indexOflargest]) {
				indexOflargest = i;
			}
		}
		return indexOflargest;
	}

            }","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        add(TREES, getUpdate(TREES), END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Uth,"Celine Victoria",a06a412970e89d27a5d2a53764297db5,Beendet,"6. Januar 2021  10:57","10. Januar 2021  11:38","4 Tage","5,08",3,new,"zahlen = new int[3];",-3.5,"1, 1, 2","char string;","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 9(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: 2; Teil 28: %; Teil 29: 10; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 1; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 3; Teil 42: %; Teil 43: 10; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: false; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 10; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 3; Teil 78: 5; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 6; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 12; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 1; Teil 99: 13; Teil 100: -; Teil 101: -; Teil 102: -; Teil 103: -; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[10][20];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Kalz,Andreas,a.kalz.1@tu-berlin.de,Beendet,"6. Januar 2021  13:51","6. Januar 2021  14:49","57 Minuten 35 Sekunden","14,32",geca,"char string;","zahlen = new int[3];",8.5,n-1,"den gleichen Datentyp.","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: _; Teil 109: _; Teil 110: _; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    public static void main(String[] args) {
    	int [] queue = Terminal.askIntArray(""Queue:\n""); 
    	int index = indexOfMax(queue);
    	while(index > -1) {
    		System.out.println(queue[index]);
    		queue[index] = Integer.MIN_VALUE;
    		index = indexOfMax(queue);
    	}
    }

    public static int indexOfMax(int[] arr) {
    	int maxElem = -1;
    	int maxElemIndex = -1;
    	for (int i = 0; i < arr.length; i++) {
    		if (arr[i] > maxElem) {
    			maxElem = arr[i];
    			maxElemIndex = i;
    		}
    	}
    	return maxElemIndex;
    }
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    	int [][] futureForest = new int[TREES.length][];
    	for (int i = 0; i < TREES.length; i++) {
    		futureForest[i] = new int[TREES[i].length];
    		for (int j = 0; j < TREES[i].length; j++) {
    			if (TREES[i][j] > 0) {
    				futureForest[i][j] = (TREES[i][j]+1)%7;
    			} else if(TREES[i][j] == TREE && neighborIsOnFire(TREES, i, j)) {
    				futureForest[i][j] = FIRE_START;
    			} else {
    				futureForest[i][j] = TREES[i][j];
    			}
    		}
    	}
    	TREES = futureForest;
    }  
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Gontarz,Jakob,jakob.gontarz@campus.tu-berlin.de,Beendet,"6. Januar 2021  17:04","10. Januar 2021  23:59","4 Tage 6 Stunden","13,94",n-1,int[],"den gleichen Datentyp.",new,3,3,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 12(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 5; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 2.0; Teil 99: 6; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
        int[] zahl = Terminal.askIntArray(""Queue:\n"");
        while (gleich(zahl)==false){
        int maxi = indexOfMax(zahl);
        Terminal.println(zahl[maxi]);
        zahl[maxi] =  Integer.MIN_VALUE;
        }
    }
    public static int indexOfMax(int[]array) {
        int index = 0;
        for(int i = 1; i < array.length; i++){
            if (array[i]>array[index]) index = i;
        } 
        if (gleich(array)==true) return -1;
        return index;
    }
    public static boolean gleich (int[]jo){
        for(int i = 1; i < jo.length; i++){
            if(jo[0] != jo[i]) return false;
        } 
        return true;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
   public static void step() {
int[][] tree = new int[TREES.length][TREES.length];
int positionswert;
for(int k = 0; k<TREES.length; k++){
for(int l = 0; l < TREES[k].length; l++){
positionswert = TREES[k][l];
if(positionswert < 0){
tree[k][l] = positionswert;
}
else{
if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l))) tree[k][l]=1;
if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l)==false)) tree[k][l]=0;
if (positionswert == 6) tree[k][l]=0;
if ((positionswert > 0) && (positionswert < 6)){
tree[k][l] = positionswert + 1;
}
}
}
}

TREES = tree;
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Hake,"Anna Franziska",a.hake@campus.tu-berlin.de,Beendet,"6. Januar 2021  19:37","10. Januar 2021  23:55","4 Tage 4 Stunden","2,46",false,"den gleichen Datentyp.",new,"int null;",3,"{1,2}","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 1; Teil 29: 4(8); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 4(9); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 4(10); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 4(11); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 4(12); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 4(9); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 4(10); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 4(11); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 4(12); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 4(13); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 6; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
         char[][] array = new char[hoehe][breite];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
"Ramos Ruiz",Natalia,n.ramosruiz@campus.tu-berlin.de,Beendet,"6. Januar 2021  23:07","10. Januar 2021  23:58","4 Tage","10,10","{1,2,3}",-3.5,"den gleichen Datentyp.",3,"zahlen = new int[3];",new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: undef; Teil 22: 8; Teil 23: -; Teil 24: -; Teil 25: -; Teil 26: -; Teil 27: %; Teil 28: %; Teil 29: 9; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 5(10); Teil 44: undef; Teil 45: 1; Teil 46: undef; Teil 47: undef; Teil 48: 2; Teil 49: %; Teil 50: 5(10); Teil 51: %; Teil 52: undef; Teil 53: 1; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 5(10); Teil 58: %; Teil 59: %; Teil 60: undef; Teil 61: %; Teil 62: 4; Teil 63: %; Teil 64: 5(10); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 5; Teil 70: %; Teil 71: 12; Teil 72: undef; Teil 73: undef; Teil 74: undef; Teil 75: undef; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112:","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;

    public static void main(String[] args) {
            Framed.frame();
        }

    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A';
			    }
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args){
      
        Terminal.println(indexOfMax(Terminal.askIntArray(""Queue:\n"")));
    }
    public static int  indexOfMax(int arr []) {
        int index = 0;
        int max = arr [index];

        
        }
        return index;
    }

}","public class Forest {

    // Die Wald-Repraesentation

	public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {


			add(TREES);

    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x) {
		int max = 6;
		int[][] y = getUpdate(x);
		for(int i = 0; i < x.length; i++) {
			for(int j = 0; j < x.length; j++) {
				x[i][j]=(x[i][j]+y[i][j])%(max+1);
				if(x[i][j] > END) x[i][j] = TREE;
			}
		}
		return x;
    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    public static int[][] getUpdate(int[][] x) {
		int a = x.length;
	int[][] y = new int[a][a];

		for(int i = 0; i < x.length; i++) {
			for(int j = 0; j < x.length; j++) {
				if(x[i][j] > TREE) y[i][j]=1;
					else if(x[i][j]== TREE && neighborIsOnFire(x, i, j)==true) {
						y[i][j]=1;
					}
					else y[i][j]=0;
			}
		}
		return y;
    }
	 /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }


}"
Ciepielowska,"Maria Aleksandra",maria.ciepielowska@campus.tu-berlin.de,Beendet,"7. Januar 2021  13:10","7. Januar 2021  21:20","8 Stunden 9 Minuten","9,74",3,int[],n-1,3,-3.5,"zahlen = new int[3];","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 8; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 3; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: -; Teil 56: %; Teil 57: 4; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 5; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 8; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 9; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: 3; Teil 84: %; Teil 85: 10; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 11; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 12; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 13; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    public static void main(String[] args){
		frame();
	}
    public static void frame() {
        char[][]array=new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
			//System.out.print(""i: ""+Integer.toString(i)+""\n"");
		    for(int j = 0; j <= (breite+1); j++) {
				//System.out.print(""j: ""+Integer.toString(j)+""\n"");
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args){
		int number[]= Terminal.askIntArray(""Queue:\n"");
		int[] numbertwo=number.clone();
		int imax = -99;
	
		for(int i = 0;i< number.length;i++){
			
			imax = indexOfMax(number);
			
			System.out.println(numbertwo[imax]);
			
		}
		
	}
    public static int indexOfMax(int[] tablica){
		
		int indeks = -1;
		int maxwartosc = 0;
		
		for (int i = 0; i < tablica.length; i++) 
		{
			if (maxwartosc < tablica[i]) 
			{
				maxwartosc = tablica[i];
				indeks = i;
			}
		}
		if(indeks>=0){
			tablica[indeks]= Integer.MIN_VALUE; 
		}
		return indeks;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Vorbeck,Tim,tim.vorbeck@campus.tu-berlin.de,Beendet,"7. Januar 2021  14:58","10. Januar 2021  21:26","3 Tage 6 Stunden","13,93","boolean if;",int[],"1, 1, 2",3,new,"den gleichen Datentyp.","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: 0; Teil 17: 1; Teil 18: 1; Teil 19: 2; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: -; Teil 49: %; Teil 50: 12(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 8(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 9(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 3; Teil 70: %; Teil 71: 10(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args){
        
        int temp;
        int[] num = Terminal.askIntArray(""Queue:\n"");
        int count = num.length;
        for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) 
            {
                if (num[i] < num[j]) 
                {
                    temp = num[i];
                    num[i] = num[j];
                    num[j] = temp;
                }
            }
        }
        
        for (int i = 0; i < count - 1; i++) 
        {
            Terminal.println(num[i]);
        }
        Terminal.println(num[count - 1]);
    }
    
    public static int indexOfMax(int[] num ){
        if ( num == null || num.length == 0 )
        return -1; 
        int Max = 0;
        for ( int i = 1; i < num.length; i++ ){
         if ( num[i] > num[Max] ) Max = i;
        }
        return Max; 
    }
}","public class Forest {
    public static int[][] TREES;
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    public static void step() {
               add(TREES,getUpdate(TREES),END);
    }  
    public static void add(int[][]x, int[][]y, int max){
         for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){ 
                    x[i][j] = (x[i][j] + y[i][j])%(max+1);
                 
            }
       
        }
    }
    public static int[][] getUpdate(int [][]x){
        int[][] y= new int[TREES.length][TREES.length];
        for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){
                if( x[i][j] > TREE || x[i][j] == TREE && neighborIsOnFire(TREES,i,j)){
                y[i][j]=1;
                }
                else{
                    y[i][j]=0;
                }
            } 
        }
        return y;
    }
    
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Kolberg,"Niklas Moritz",niklas.m.kolberg@campus.tu-berlin.de,Beendet,"7. Januar 2021  21:33","10. Januar 2021  21:20","2 Tage 23 Stunden","10,89",-3.5,new,3,geca,"1, 1, 2",n-1,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 2; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: 0; Teil 94: %; Teil 95: 0; Teil 96: 0; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {	
	
	public static void main(String[] args) {
		
		int[] inputArray = Terminal.askIntArray(""Queue:\n"");
		while (indexOfMax(inputArray)!= -1){
			System.out.println(inputArray[indexOfMax(inputArray)]);
			inputArray[indexOfMax(inputArray)]=Integer.MIN_VALUE; 
		}
	}
	
	public static int indexOfMax (int[] array){
		  int index = 0;
		  for (int i = 0; i < array.length; i++){
		      if (array[i] >= array[index]){
		    	  index=i;
		      }
		  }
		  if(array[index]!=Integer.MIN_VALUE){
			  return index;
		  }
		  else{
			  return -1;
		  }
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Escabache,"Pia Annick",escabache@campus.tu-berlin.de,Beendet,"8. Januar 2021  12:06","10. Januar 2021  23:59","2 Tage 11 Stunden","10,55",new,geca,3,"zahlen = new int[3];",-3.5,"1, 1, 2","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 12(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: 2; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 12(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 9(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: -; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{
	public static void main(String[] args){
	
		int[] array=Terminal.askIntArray(""Queue:\n"");
  		sort(array);		
		for( int i= 0; i<array.length;i++){
		System.out.println(array[i]);
		}

	}
	public static int[] sort(int[]array){
		
		int temp=0;
		for (int i =0; i<array.length;i++){
			for (int j=1; j<array.length-i; j++){
				if(array[j]>array[j-1]){
					temp=array [j-1];
					array[j-1]=array[j];
					array[j]=temp;
				}
			}
		}
		return array;
	}
		public static int indexOfMax(int[]arr){
		
	
		int Max=0;	
		if (arr.length == 0 )
		return Max=-1;  
	 	
  		for ( int i = 1; i < arr.length; i++ ){
     		if ( arr[i] > arr[Max] ) Max = i;
  		}
  		return Max;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Heyde,Jan-Frederik,heyde@campus.tu-berlin.de,Beendet,"8. Januar 2021  14:50","10. Januar 2021  15:30","2 Tage","10,46",new,"char string;",geca,"zahlen = new int[3];",int[],"den gleichen Datentyp.","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: -; Teil 24: -; Teil 25: -; Teil 26: -; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 4; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char array [][] = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

public static void main(String[] args) {
        int[] queue = Terminal.askIntArray(""Queue:\n"");
        for(int i = 0; i < queue.length; i++) {
            int index = indexOfMax(queue);
            Terminal.println(queue[index]);
            queue[index] = Integer.MIN_VALUE;
        }
        
    }
    
    public static int indexOfMax(int[] q) {
        int indexm = 0;
        if(q == null || q.length == 0) {
            return -1;
        }
        for(int i = 1; i < q.length; i++) {
            if(q[i] > q[indexm]) {
                indexm = i;
            }
        }
        return indexm;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Jakir,"Luka Kristian",jakir@campus.tu-berlin.de,Beendet,"8. Januar 2021  16:24","10. Januar 2021  21:31","2 Tage 5 Stunden","3,24",new,"char string;",n-1,int,3,"zahlen = new int[3];","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: fib(a); Teil 29: 8; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 12(10); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(12); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 10(12); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 12(10); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 9(12); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 10(12); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 12(10); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 6(12); Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14(6); Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static void main(String []args) {
        frame();}
    public static int breite = 6;
    public static int hoehe = 3;
    public static void frame() {
        int[][] array = new int[10][10];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
        int[] x = new int[n];
    }
    
    Terminal.askIntArray(""Queue:\n"");
    Terminal.println(""n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Brockhaus,"Clara Madeleine",c.brockhaus@campus.tu-berlin.de,Beendet,"8. Januar 2021  18:57","10. Januar 2021  12:36","1 Tag 17 Stunden","10,28","1, 1, 2",geca,-3.5,"int null;","zahlen = new int[3];",new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: -; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
public static int[] array() {
	int[] intArray = Terminal.askIntArray(""Queue:\n"");
	return intArray;
}

public static int indexOfMax(int[] array) {
	int max = array[0];
	int index = 0;
	for (int i = 0; i < array.length; i++) {
	  if ( array[i] > max ) {
	      max = array[i];
	      index = i;
	   } 
	}
	return index; 
}

public static void main(String[] args) {
	int[] intArray = array();
	for(int i = 0; i < intArray.length; i++){
		int ind = indexOfMax(intArray);
		Terminal.println(intArray[ind]);
		intArray[ind] = Integer.MIN_VALUE;
		if (ind == -1) {
			break;
		}
	}
}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		int i = 0;
		int j = 0;
		do {
			if(TREES[i][j] >= 0 && TREES[i][j]!= 0) {
				TREES[i][j]++;
			}
			if (TREES[i][j] == 0 && neighborIsOnFire(TREES,i,j)) {
				TREES[i][j] ++;
			}
			if (TREES[i][j] >= 6 && TREES[i][j]!= 6) {
				TREES[i][j] = 0;
			}
		} while(add(getUpdate(TREES),TREES,i+j) <= END);
			
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for( i=0 ; i<x.length ; i++) {
		     if (max<x[i]) {
		            max = x[i] ;
				}
			x = (add(x,y))%(max+1);	
		}
    } //?????????????? 
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int[x.length][x.length];
		int a = 0;
		int b = 0;
		if (x[a][b] >= TREE && x[a][b] != TREE || x[a][b] == TREE && neighborIsOnFire(TREES,a,b)){
			return y = add(x,y);
		}
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Jäger,"Fabia Cecilia",f.jaeger@tu-berlin.de,Beendet,"8. Januar 2021  21:11","10. Januar 2021  15:14","1 Tag 18 Stunden","13,53",-3.5,new,geca,"char string;",n-1,3,"Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 2; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: 3; Teil 16: undef; Teil 17: undef; Teil 18: undef; Teil 19: undef; Teil 20: %; Teil 21: %; Teil 22: 4; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 5; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 2.0; Teil 36: 6; Teil 37: -; Teil 38: -; Teil 39: -; Teil 40: -; Teil 41: %; Teil 42: -; Teil 43: 7; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 8; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 2; Teil 63: %; Teil 64: 10; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: -; Teil 77: %; Teil 78: 12; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 14; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 15; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 16; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String[] args) {
        int[] array = Terminal.askIntArray(""Queue:\n"");
        while (indexOfMax(array) > -1) {
            int arrayIndex = indexOfMax(array);
            System.out.println(array[arrayIndex]);
            array[arrayIndex] = Integer.MIN_VALUE;
        }
    }
    
    public static int indexOfMax(int[] array) {
        int maxIndex = 0;
        for (int i = 1; i < array.length; i++) {
            if (array[i] > array[maxIndex]) {
                maxIndex = i;
            }
        }
        if (array[maxIndex] == Integer.MIN_VALUE) {
            return -1;
        }
        return maxIndex;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int[][] update = getUpdate(TREES);
        add(TREES, update, 6);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                TREES[i][j] = (x[i][j] + y[i][j]) % (max+1);
            }
        }
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
        int[][] update = new int[x.length][x[0].length];
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                if (x[i][j] > 0) {
                    update[i][j] = 1;
                } else if (x[i][j] == 0) {
                    if (neighborIsOnFire(x, i, j)) {
                        update[i][j] = 1;
                    } else {
                        update[i][j] = 0;
                    }
                } else {
                    update[i][j] = 0;
                }
            }
        }
        return update;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Dietrich,"Lukas Sebastian",lukas.dietrich@campus.tu-berlin.de,Beendet,"9. Januar 2021  12:07","10. Januar 2021  19:49","1 Tag 7 Stunden","8,88","char string;",n-1,"den gleichen Datentyp.",3,int,geca,"Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 2; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: 3; Teil 16: 0; Teil 17: 0; Teil 18: 0; Teil 19: 0; Teil 20: %; Teil 21: %; Teil 22: 4; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 5(8); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 5(9); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 5(10); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 5(9); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 5(10); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 5(11); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 5(12); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 5(13); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 5; Teil 86: 0; Teil 87: 1; Teil 88: 1; Teil 89: 2; Teil 90: %; Teil 91: 2.0; Teil 92: 6; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 7; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
	
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    
    	
	
	public static void main(String[] args){
		int[] schlange = Terminal.askIntArray(""Queue:\n"");
		for(int i=0;i<schlange.length;i++) {
			int indexOfMax = indexOfMax(schlange);
			Terminal.println(schlange[indexOfMax]);
			schlange[indexOfMax] = Integer.MIN_VALUE;
		}
		
		
	}
	
	public static int indexOfMax (int [] schlange){
		int indexOfMax=0;
		boolean abgearbeitet = true;
			
			
		for(int i=1;i<schlange.length;i++) {
		
		if (schlange[i]>schlange[indexOfMax])
			{
				 indexOfMax = i;
				
			}		
			
		}
		
			
		for(int i=0;i<schlange.length;i++){
			
			
			if(schlange[i]!=Integer.MIN_VALUE){
				
				abgearbeitet=false;
				
		
				
			}
			
			
			
		}	
	
		if(abgearbeitet){
				
				return -1;
				
		}
		else
		{
		
		
		return indexOfMax;
		
		}
	}
	
	
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Birke,"Matthias Benedict",benedict.birke@campus.tu-berlin.de,Beendet,"9. Januar 2021  12:57","10. Januar 2021  23:08","1 Tag 10 Stunden","6,46",new,"char string;",n-1,"zahlen = new int[3];",3,"den gleichen Datentyp.","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10; Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 9; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 10; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: 2; Teil 55: %; Teil 56: %; Teil 57: 5(12); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: -; Teil 63: 2; Teil 64: 6; Teil 65: -; Teil 66: -; Teil 67: -; Teil 68: -; Teil 69: %; Teil 70: -; Teil 71: 8; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 9; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 10; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 11; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 12; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 13; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
        int[] array= Terminal.askIntArray(""Queue:\n"");
        for (int i=0; i<array.length;i++) {
            int m=indexOfMax(array);
            Terminal.println(array[m]);
            array[m]=Integer.MIN_VALUE;
            
        }
    }
    public static int indexOfMax(int[] array) {
        int max = array[0];
        int x=0;
        for (int i=1; i<array.length;i++) {
            if (array[i]>max){
                max=array[i];
                x=i;
            }
        }
        return x;
    
    }
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Theo,Yovan,yovan.theo@campus.tu-berlin.de,Beendet,"9. Januar 2021  17:00","10. Januar 2021  22:55","1 Tag 5 Stunden","3,59",n-1,geca,"0, 1, 2",3,3,int[],"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 9(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 10(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: 2; Teil 55: %; Teil 56: %; Teil 57: 11(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 12(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 13(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: -; Teil 77: %; Teil 78: 5; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 2; Teil 85: 6; Teil 86: -; Teil 87: -; Teil 88: -; Teil 89: -; Teil 90: %; Teil 91: -; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112:","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Bürgel,Benedikt,b.buergel@campus.tu-berlin.de,Beendet,"9. Januar 2021  17:11","10. Januar 2021  23:34","1 Tag 6 Stunden","12,57",n-1,"int null;",2,"{1,2,3}",geca,"1, 1, 2","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 9(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 10(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 4; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	

	public static void main(String[] args) {
		
		int[] reihe = Terminal.askIntArray(""Queue:\n"");
		
		int min = Integer.MIN_VALUE;
		
		for(int i = 0 ; i < reihe.length; i++) {
		
		Terminal.println(reihe[indexOfMax(reihe)]);
		reihe[indexOfMax(reihe)] = min;
		
		
		
		}
	}
	
	public static int indexOfMax(int[] reihe) {
		int index = 0;
		int max = reihe[index];
		for (int m = 0; m < reihe.length; m++) {
			if (reihe[m] > max) {
				max = reihe[m];
				index = m;
				
			}
			else if(index > m) return -1;
			
		}
		return index;
		
		
		
		
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    
	public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		
		 
			add(TREES);
		
    }
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x) {
		int max = 6;
		int[][] y = getUpdate(x);
		for(int index1 = 0; index1 < x.length; index1++) {
			for(int index2 = 0; index2 < x.length; index2++) {
				x[index1][index2]=(x[index1][index2]+y[index1][index2])%(max+1);
				if(x[index1][index2] > END) x[index1][index2] = TREE;
			}
		}
		return x;
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int m = x.length;
	int[][] y = new int[m][m];
		
		for(int index1 = 0; index1 < x.length; index1++) {
			for(int index2 = 0; index2 < x.length; index2++) {
				if(x[index1][index2] > TREE) y[index1][index2]=1;
					else if(x[index1][index2]== TREE && neighborIsOnFire(x, index1, index2)==true) {
						y[index1][index2]=1;
					}
					else y[index1][index2]=0;
			}
		}	
		return y;
    }
	 /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
    

}"
Napiwotzki,Nicklas,n.napiwotzki@campus.tu-berlin.de,Beendet,"9. Januar 2021  17:24","10. Januar 2021  22:38","1 Tag 5 Stunden","14,81","char string;","zahlen = new int[3];",geca,3,int[],new,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2.0; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
	int[] input;
    input=Terminal.askIntArray(""Queue:\n"");
	int stelle;
    for (int i=0; i<input.length; i++){
		stelle=indexOfMax(input);
		if (stelle == -1){
			break;
		}
		else{
			System.out.println(input[stelle]);
			input[stelle]=Integer.MIN_VALUE;
		}
	}
	}
	public static int indexOfMax(int[] a){
		int index = 0;
		int sum =0;
		for (int i=0; i<a.length; i++){
			sum+=a[i];
		}
		sum=sum/Integer.MIN_VALUE;	
		if (sum==a.length){
			return -1;
		}
		else{
			for (int i=1; i<a.length; i++){
				if (a[index]>a[i]){
				}
				else{
					index=i;
				}
			}
			return index;
		}
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		add(TREES, getUpdate(TREES), END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for(int i=0; i<x.length;i++){
			for(int j=0; j<x[i].length; j++){
				x[i][j]=(x[i][j]+y[i][j])%(max+1);
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][]y = new int[x.length][x.length];
		for(int i=0;i<x.length;i++){
			for(int j=0;j<x.length;j++){
				if(x[i][j]>0){
					y[i][j]=1;
				}
				else if(x[i][j]==0 & neighborIsOnFire(x,i,j)){
					y[i][j]=1;
				}
				else{
					y[i][j]=0;
				}
			}
		}
		return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Arimbawa,"Made Niro Aditya",arimbawa@campus.tu-berlin.de,Beendet,"9. Januar 2021  20:41","10. Januar 2021  14:37","17 Stunden 56 Minuten","13,28",geca,"den gleichen Datentyp.",n-1,Compilerfehler,"1, 1, 2","zahlen = new int[3];","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 3; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 12(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 13(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 5; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 2; Teil 92: 6; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
	public static void main(String [] args){
		
    int[] a = Terminal.askIntArray(""Queue:\n"");
    for (int i = 0;i<a.length;i++){
        int b = indexOfMax(a);
          if (b == -1){
            break;
          }
        System.out.println(a[b]);
        a[b]= Integer.MIN_VALUE;
    }
}
public static int indexOfMax(int[] b){ 
     boolean abgearbeitet = true; 
	 int indexOfMax = 0;
   for(int x = 0;x<b.length;x++){
     if (b[x]> Integer.MIN_VALUE){ 
         abgearbeitet = false;
     }
   }
   if (abgearbeitet){ 
       return (-1);
   }
   else{
	   int max=b[0];
    for(int i = 1;i < b.length;i++){
     if (b[i]>max){
         max = b[i];
     }
        
    }
    for(int i = 0;i <b.length;i++){ 
        if (b[i]==max){ 
          indexOfMax = i; 
        }
    }
return indexOfMax;
}
   }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
	TREES = add(TREES, getUpdate(TREES), END); 
	}
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x, int[][] y, int max) {
		for (int i = 0; i < x.length; i++){
			for (int j = 0; j < x[i].length;j++){
			x[i][j] = (x[i][j]+y[i][j])%(max+1);
		}
    }  
	return x; 
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
	 int[][] y = new int[(x.length)][(x[0].length)];
	 for (int i = 0; i < x.length; i++){
			for (int j = 0; j < x[i].length;j++){
				switch (x[i][j]){
					case 0 : 
					if (neighborIsOnFire(x, i, j)){ 
					y[i][j] = 1; 
					}
					else{ y[i][j] = 0;
					}
					break; 
					case 1 : y[i][j] = 1;break;
					case 2 : y[i][j] = 1;break;
					case 3 : y[i][j] = 1;break;
					case 4 : y[i][j] = 1;break; 
					case 5 : y[i][j] = 1;break; 
					case 6 : y[i][j] = (-6);break; 
					default: y[i][j] = 0;break; 
			}
	 
		}	
    }
	return y; 
	}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Shen,Yishu,yishu.shen@campus.tu-berlin.de,Beendet,"9. Januar 2021  21:48","10. Januar 2021  21:19","23 Stunden 31 Minuten","9,13",-3.5,"boolean if;","zahlen = new int[3];",3,3,fdb,"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: 0; Teil 17: 1; Teil 18: 1; Teil 19: 2; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: -; Teil 49: %; Teil 50: 12(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 8(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: %; Teil 64: 9(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 3; Teil 70: %; Teil 71: 10(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: -; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: %; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args){
        
        int temp;
        int[] num = Terminal.askIntArray(""Queue:\n"");
        int count = num.length;
        for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) 
            {
                if (num[i] < num[j]) 
                {
                    temp = num[i];
                    num[i] = num[j];
                    num[j] = temp;
                }
            }
        }
        
        for (int i = 0; i < count - 1; i++) 
        {
            Terminal.println(num[i]);
        }
        Terminal.println(num[count - 1]);
    }
    
    public static int indexOfMax(int[] num ){
        if ( num == null || num.length == 0 )
        return -1; 
        int Max = 0;
        for ( int i = 1; i < num.length; i++ ){
         if ( num[i] > num[Max] ) Max = i;
        }
        return Max; 
    }
}","public class Forest {
    public static int[][] TREES;
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    public static void step() {
               add(TREES,getUpdate(TREES),END);
    }  
    public static void add(int[][]x, int[][]y, int max){
         for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){ 
                    x[i][j] = (x[i][j] + y[i][j])%(max+1);
                 
            }
       
        }
    }
    public static int[][] getUpdate(int [][]x){
        int[][] y= new int[TREES.length][TREES.length];
        for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){
                if( x[i][j] > TREE || x[i][j] == TREE && neighborIsOnFire(TREES,i,j)){
                y[i][j]=1;
                }
                else{
                    y[i][j]=0;
                }
            } 
        }
        return y;
    }
    
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Mittag,"Fritz Leo Antonius",f.mittag@campus.tu-berlin.de,Beendet,"10. Januar 2021  11:14","10. Januar 2021  23:38","12 Stunden 24 Minuten","1,95","int null;",2,"zahlen = new int[3];",int,"1, 1, 2",new,"Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 2; Teil 9: -; Teil 10: -; Teil 11: -; Teil 12: -; Teil 13: -; Teil 14: -; Teil 15: 3; Teil 16: undef; Teil 17: undef; Teil 18: undef; Teil 19: undef; Teil 20: -; Teil 21: -; Teil 22: 4; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: -; Teil 28: -; Teil 29: 5; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: -; Teil 35: undef; Teil 36: 6; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: -; Teil 42: undef; Teil 43: 7; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: -; Teil 49: undef; Teil 50: 8; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: -; Teil 56: undef; Teil 57: 9; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 2; Teil 63: undef; Teil 64: 10; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 2; Teil 70: undef; Teil 71: 9(10); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: 3; Teil 77: undef; Teil 78: 10(10); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: 3; Teil 84: undef; Teil 85: 9(10); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: 4; Teil 91: undef; Teil 92: 10(10); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: 4; Teil 98: fib(a); Teil 99: 12; Teil 100: %; Teil 101: %; Teil 102: 5; Teil 103: %; Teil 104: %; Teil 105: fib(a); Teil 106: 14; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: undef; Teil 112: undef","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char[][] array = new char [100][100];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
Terminal.askIntArray ( ""Queue:\n"" );
    public class sortieren {

  public static void main( String[] args )  {

    System.out.println( ""Zahl1 eingeben und mit Return abschliessen:"" );
    int a = 0;
    System.out.println( ""Zahl2 eingeben und mit Return abschliessen:"" );
    int b = 0;
    System.out.println( ""Zahl3 eingeben und mit Return abschliessen:"" );
    int c = 0;

    try {
      BufferedReader in = new BufferedReader(
                          new InputStreamReader( System.in ) );
      	a = Integer.parseInt(in.readLine());
	b = Integer.parseInt(in.readLine());
	c = Integer.parseInt(in.readLine());


    } catch( Exception ex ) {
      System.out.println( ex.getMessage() );
    }
  
	if(a+b+c) ==0) {
	System.out.println(""0"");

	}		

	else {
	
		if(a>b) {
			
			if(b>c) {

				System.out.println(c);
				System.out.println(b);
				System.out.println(a);

				}
			else {
				System.out.println(b);
				System.out.println(c);
				System.out.println(a);
				}
			}
		else {
		
			if(a>c) {

				System.out.println(c);
				System.out.println(a);
				System.out.println(b);

				}

			else {

				System.out.println(a);
				System.out.println(c);
				System.out.println(b);

				}

			}
		}

  	}
   }

    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Rosskopp,Thorge,rosskopp@campus.tu-berlin.de,Beendet,"10. Januar 2021  13:49","10. Januar 2021  23:36","9 Stunden 46 Minuten","2,05",n-1,new,fdb,"char string;","0, 1, 1","{1,2,3}","Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 2; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: %; Teil 15: 3; Teil 16: 4; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 4; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: %; Teil 29: 5; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: undef; Teil 36: 6; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 8(6); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 9; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 2; Teil 56: %; Teil 57: 10; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 11; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 12; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 13; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 5(13); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 10; Teil 92: 6; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 7; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14(7); Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        byte[] [] array = new byte[i] [j];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Neß,"Jonas Lennart",jonas.ness@campus.tu-berlin.de,Beendet,"10. Januar 2021  14:48","10. Januar 2021  22:20","7 Stunden 31 Minuten","13,69",n-1,"int null;","0, 1, 2",-3.5,3,int[],"Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: 0; Teil 10: 0; Teil 11: 0; Teil 12: 0; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 8(5); Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 9(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: 2; Teil 35: %; Teil 36: 10(5); Teil 37: %; Teil 38: %; Teil 39: 1; Teil 40: %; Teil 41: %; Teil 42: %; Teil 43: 11(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: 3; Teil 49: %; Teil 50: 9(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 10(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 2; Teil 62: %; Teil 63: %; Teil 64: 11(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: 4; Teil 70: %; Teil 71: 9(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 11(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 12(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 13(5); Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: %; Teil 99: 5; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: 2; Teil 106: 6; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: %; Teil 112: %","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2]  ;
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    //public static int[] Eingabe = Terminal.askIntArray(""Queue:\n"");
		
		public static void main(String[] args){
			int[] Eingabe = Terminal.askIntArray(""Queue:\n"");
			for(int i=0; i<Eingabe.length; i++){
				int maxindex = indexOfMax(Eingabe);
				if(maxindex == -1) {
					break;
				}
				System.out.println(Eingabe[maxindex]);
				Eingabe[maxindex] = Integer.MIN_VALUE;
			}
		}
		
		public static int indexOfMax(int[] Eingabe){
			int momentanMax = 0;
			int momentanInd = 0;
			int laenge = Eingabe.length;
				for(int c=0; c<Eingabe.length; c++){
					if(Eingabe[c] != Integer.MIN_VALUE){
					}
					else{
						if(c == laenge){
							return -1;
						}
					}
				}
				
			
				for(int j=0; j<Eingabe.length; j++){
					int blick = Eingabe[j];
					if(blick >= momentanMax){
					momentanMax = blick;
					momentanInd = j;
					} else{}
				}
			
				return momentanInd;
			
		}
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		int h = TREES.length;
		int v = TREES[0].length;
		int[][] update = new int[h][v];
		update = getUpdate(TREES);
		TREES = add(TREES, update, 6);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x, int[][] y, int max) {
		int laenge = x.length;
		int breite = x[0].length;
		for(int h=0; h<laenge; h++){
			for(int v=0; v<breite; v++){
				x[h][v] = x[h][v] + y[h][v];
			}
		}
		return x;
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int laenge = x.length;
		int breite = x[0].length;
		int[][] update = new int[laenge][breite];
		for(int h=0; h<laenge; h++){
			for(int v=0; v<breite; v++){
				if(x[h][v] == TREE && neighborIsOnFire(x, h, v)){
					update[h][v]++;
				}
				if(isOnFire(x[h][v])){
					update[h][v]++;
				}
				if(x[h][v] >= 4 && x[h][v] <=5){
					update[h][v]++;
				}
				if(x[h][v] == END){
					update[h][v] = -6;
				}
				
			}
		}
		return update;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Heuer,"Lukas Paul Ernst",heuer.1@campus.tu-berlin.de,Beendet,"10. Januar 2021  20:21","10. Januar 2021  23:59","3 Stunden 37 Minuten","5,44","den gleichen Operator.",-3.5,"0, 1, 1",3,"{1,2}","char string;","Teil 1: 2; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 3; Teil 9: undef; Teil 10: undef; Teil 11: undef; Teil 12: undef; Teil 13: %; Teil 14: %; Teil 15: 4; Teil 16: %; Teil 17: 1; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: %; Teil 22: 5; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: undef; Teil 29: 8(5); Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: %; Teil 36: 9(5); Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: 2; Teil 42: %; Teil 43: 10(5); Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: %; Teil 50: 11(5); Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: %; Teil 57: 9(5); Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: 3; Teil 63: %; Teil 64: 10(5); Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: %; Teil 71: 11(5); Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: %; Teil 78: 12(5); Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: %; Teil 85: 13(5); Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: %; Teil 92: 5; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 2.0; Teil 99: 6; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: %; Teil 105: %; Teil 106: 14; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char [][] array= new char  [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public static void step() {

int[][] tree = new int[TREES.length][TREES.length];
int positionswert; 
for(int k = 0; k<TREES.length; k++){
for(int l = 0; l < TREES[k].length; l++){
positionswert = TREES[k][l];
if(positionswert < 0){
tree[k][l] = positionswert;
}
else{
if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l))) tree[k][l]=1;
if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l)==false)) tree[k][l]=0;
if (positionswert == 6) tree[k][l]=0;
if ((positionswert > 0) && (positionswert < 6)){
tree[k][l] = positionswert + 1;
}
}
}
}
TREES = tree;
    }"
Bosner,Celina,c.bosner@campus.tu-berlin.de,Beendet,"10. Januar 2021  21:00","10. Januar 2021  21:29","28 Minuten 9 Sekunden","2,03","1, 1, 2","den gleichen Datentyp.","{1,2}",new,"{1,2,3}",true,"Teil 1: 1; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: -; Teil 8: 2; Teil 9: -; Teil 10: -; Teil 11: -; Teil 12: -; Teil 13: -; Teil 14: -; Teil 15: 3; Teil 16: 4; Teil 17: -; Teil 18: -; Teil 19: -; Teil 20: -; Teil 21: -; Teil 22: 4; Teil 23: %; Teil 24: 1; Teil 25: -; Teil 26: -; Teil 27: -; Teil 28: -; Teil 29: 5; Teil 30: %; Teil 31: %; Teil 32: -; Teil 33: -; Teil 34: -; Teil 35: fib(a); Teil 36: 6; Teil 37: -; Teil 38: -; Teil 39: -; Teil 40: -; Teil 41: -; Teil 42: -; Teil 43: 7; Teil 44: -; Teil 45: -; Teil 46: -; Teil 47: -; Teil 48: -; Teil 49: -; Teil 50: 5(8); Teil 51: -; Teil 52: -; Teil 53: -; Teil 54: -; Teil 55: -; Teil 56: -; Teil 57: 5(9); Teil 58: -; Teil 59: -; Teil 60: -; Teil 61: -; Teil 62: 2; Teil 63: -; Teil 64: 5(10); Teil 65: -; Teil 66: -; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: -; Teil 71: 11; Teil 72: -; Teil 73: -; Teil 74: -; Teil 75: -; Teil 76: -; Teil 77: -; Teil 78: 12; Teil 79: -; Teil 80: -; Teil 81: -; Teil 82: -; Teil 83: -; Teil 84: -; Teil 85: 12(9); Teil 86: -; Teil 87: -; Teil 88: -; Teil 89: -; Teil 90: 2; Teil 91: -; Teil 92: 12(10); Teil 93: -; Teil 94: -; Teil 95: -; Teil 96: -; Teil 97: -; Teil 98: -; Teil 99: 13; Teil 100: -; Teil 101: -; Teil 102: -; Teil 103: -; Teil 104: -; Teil 105: -; Teil 106: 14; Teil 107: -; Teil 108: -; Teil 109: -; Teil 110: -; Teil 111: -; Teil 112: -","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Gäbel,Lara,lara.gaebel@campus.tu-berlin.de,Beendet,"10. Januar 2021  21:45","10. Januar 2021  21:52","6 Minuten 51 Sekunden","2,00",geca,"1, 1, 2","double void;","{1,2}","den gleichen Datentyp.",n-1,"Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112:","public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
