Nachname,Vorname,Antwort 8,Antwort 9,Antwort 10
Name_6,VName_6,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char [breite+2][hoehe+2]  ;
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    public static void main (String[] args) {
		
		int []array = Terminal.askIntArray(""Queue:\n"");
		
	
		for (int i=0; i<array.length;i++){
			Terminal.println(array[indexOfMax(array)]);
			array[indexOfMax(array)]= Integer.MIN_VALUE;		
		}	
	}
	public static int indexOfMax (int [] x){
		int max = x[0];
		int index =0;
	
		for (int i = 0; i<x.length;i++) {
			if (x[i]>max){
			
			max = x[i];
			index = i;}
		}
	return index;
	}		
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int [][] addar = new int[10][10];
		getUpdate(TREES,addar);
		add(TREES,addar,END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for (int i=0;i<x.length;i++){
			for (int j=0;j<x.length;j++){
				if (x[i][j] >=TREE && x[i][j]<=END ) {x[i][j] += y[i][j];}
				if (x[i][j] >END) {x[i][j]=0;}
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x,int[][] y) {
        for (int i=0;i<=x.length-1;i++){
			for (int j=0;j<=x.length-1;j++){
				if (x[i][j] > TREE|| neighborIsOnFire(x,i,j)==true )  {y[i][j] += 1;}
			}
		}
		return  y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_231,VName_231,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;

    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char[][] array;
        array = new char[breite+2][hoehe+2];

        for(int i = 0; i <= (hoehe+1); i++) {
            for(int j = 0; j <= (breite+1); j++) {
                if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
                    System.out.print(""A"");
                    array[j][i] = 'A';
                }
                else {
                    System.out.print(""B"");
                    array[j][i] = 'B';
                }
            }
            System.out.print(""\n"");
        }

        System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

        for(int i = 0; i <= (hoehe+1); i++){
            for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
            System.out.print(""\n"");
        }
    }

    public static void main(String[] args){
        frame();
    }
}","public class Queue {

    public static void main(String[] args) {
        int[] wartezeit = Terminal.askIntArray(""Queue:\n"");
        int max;

        for (int i = 0; i < wartezeit.length + 1; i++) {
            max = indexOfMax(wartezeit);
            if (max != -1) {
                Terminal.println(wartezeit[max]);
                wartezeit[max] = Integer.MIN_VALUE;
            } else {
                System.exit(0);
            }
        }
    }


    //Diese Methode findet den Index der größten Wartezeit im Array
    public static int indexOfMax(int[] wartezeit) {


        int output = -1;
        int maxAt = 0;

        for (int i = 0; i < wartezeit.length; i++) {
            if (wartezeit[i] == Integer.MIN_VALUE) {
                //IF macht gar nichts, es wird mit nächsten Index weitergearbeitet

            } else {
                maxAt = wartezeit[i] > wartezeit[maxAt] ? i : maxAt;
                output = maxAt;
            }
        }
        return output;
    }
}","import javax.swing.*;

public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        add(TREES,getUpdate(TREES),END);

    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {

        for(int i = 0; i < x[0].length; i++){
            for (int j = 0; j < x[1].length; j++){
                int summe;
                summe = (x[i][j] + y[i][j]) % (max + 1);

                    if(summe <= max){
                        x[i][j] = summe;
                    }else{
                       x[i][j] = x[i][j];
                    }
                }
            }
    }


    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    public static int[][] getUpdate(int[][] x) {
        int[][] y = new int[x[0].length][x[1].length];
        for (int i = 0; i < x[0].length; i++){
            for (int j = 0; j < x[1].length; j++){
                if (x[i][j] > TREE || x[i][j] == TREE && neighborIsOnFire(x,i,j) ){
                    y[i][j] = 1;
                }else {
                    y[i][j] = 0;
                }
            }
        }
        return y;
    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_250,VName_250,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
            char[][] array=new char[breite+2][hoehe+2];
    	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String arg[]){
    int[] q=Terminal.askIntArray(""Queue:\n"");
    for(int i=0;i<q.length;i++){
        System.out.println(q[indexOfMax(q)]);
        q[indexOfMax(q)]=Integer.MIN_VALUE;
    }
    }
    public static int indexOfMax(int[] a){
        int max=Integer.MIN_VALUE;
        int index=0;
        for(int i=0;i<a.length;i++){
            if(a[i]>max){
                max=a[i];
                index=i;
            }
        }
        return index;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int[][] TRE=new int[TREES.length][TREES[0].length];
        for(int i=0;i<TREES.length;i++){
            for(int j=0;j<TREES[0].length;j++){
                if(TREES[i][j]>TREE){
                    TRE[i][j]+=1;
                }  
                else if(TREES[i][j]==0){
                    if(neighborIsOnFire(TREES,i,j)){
                        TRE[i][j]=1;
                    }
                } 
   
            }
        }
        add(TREES,TRE,END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y,int max) {
        for(int i=0;i<x.length;i++){
            for(int j=0;j<x[0].length;j++){
                x[i][j]=(x[i][j]+y[i][j])%(max+1);
            }
        }
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_230,VName_230,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static void main(String[] args) {
		
		int[] array = Terminal.askIntArray(""Queue:\n"");
		
		int indMax = indexOfMax(array); 
		
		for(int i = array.length; i>0; i--) {
			if(indMax != -1) {
				Terminal.println(array[indMax]);
				array[indMax] = Integer.MIN_VALUE;
				indMax = indexOfMax(array);
			}
			else {
				System.exit(0);
			}
		}
	}
	
	public static int indexOfMax(int[] array) {
		
		int r = array[0];
		int ind = 0; 
		
		if(allDiff(array)) {
			for(int i = 0; i<array.length; i++) {
				if(r<=array[i]) {
					r = array[i];
					ind = i;
				}
			}
		}
		else {
			ind = -1;
		}
		return ind; 
	}
	
	public static boolean allDiff(int array[]) {
		boolean result = false; 
		for(int i = 1; i<array.length; i++) {
			if(array[0] != array[i]) {
				result = true;
			}
		}
		return result;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		TREES = add(TREES, getUpdate(TREES), 6);
	}
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x, int[][] y, int max) {
		int[][] treesNeu = new int[x.length][x[1].length];		
		
		for(int i = 0; i<x.length; i++) {						
			for(int j = 0; j<x[1].length; j++) {				
				treesNeu[i][j] = x[i][j] + y[i][j];
			}
		}
		for(int i = 0; i<x.length; i++) {						
			for(int j = 0; j<x[1].length; j++) {				
				if(treesNeu[i][j]>max) {
					treesNeu[i][j] = 0;
				}		
			}				
		}
		return treesNeu;		
	}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
	public static int[][] getUpdate(int[][] x) {
		int [][] y = new int[x.length][x[1].length];			
		for(int i = 0; i<x.length; i++) {						
			for (int j = 0; j<x[1].length; j++) {				
				if(x[i][j] > 0) {
					y[i][j] = 1;
				}
				else if(x[i][j]==0 && neighborIsOnFire(TREES, i, j) == true) {
					y[i][j] = 1;
				}
			}
		}
		return y; 
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_232,VName_232,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{

	public static void main(String[] args){
		int[] array = Terminal.askIntArray(""Queue:\n"");
		int abgearbeitet_location = 0;
		int taco = 0;
		for (int i = 0; i <= array.length; i++){
			abgearbeitet_location = indexOfMax(array); //gets location of max value in array
			
			if (i < array.length && taco != -1){
				taco = array[abgearbeitet_location]; //assigns location of max value to variable
				System.out.println(taco);//prints max value at location
				array[abgearbeitet_location] = Integer.MIN_VALUE;//sets max value at location in array to MIN_VALUE	
			} 
			 
		}
		
	}	

	public static int indexOfMax(int[] array){
		int max = Integer.MIN_VALUE;
		int index = 0;
		int done = 0;
		for (int element : array){
			if (element == Integer.MIN_VALUE){
				done += 1;
				//System.out.println(""done value is ""+done);
			}
			if (done == array.length){
				return -1;
			}	
		}
		for (int i = 0; i < array.length; i++){
			if (array[i] > max){
				max = array[i];
				index = i;
			}	
		}
		return index;
	}
	
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_251,VName_251,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
	public static void main(String[] args){
    int[] x = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0; i < x.length; i++){
			int k = indexOfMax(x);
			System.out.println(x[k]);
			x[k] = Integer.MIN_VALUE;
		}
		
	}
    
	public static int indexOfMax(int[] a){
		int max = 0;
		int index = -1;
			for(int i = 0; i < a.length; i++){
				if(a[i] > max){
					max = a[i];
					index = i;
				}
			}
			return index;
		
	}
	
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {		
		add(TREES, getUpdate(TREES), 6);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for(int i=0;i<x.length;i++){
			for(int j=0;j<x[i].length;j++){
				x[i][j]=((x[i][j]+y[i][j])%(max+1));
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int[x.length][x[0].length];
			for(int i = 0; i < x.length; i++){
				for(int j = 0; j <x[i].length; j++){
					if(x[i][j] == 0 && neighborIsOnFire(x, i, j) || x[i][j] > 0) y[i][j] = 1;
					else y[i][j] = 0;
				}
			}
		return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_238,VName_238,"public class Framed {
	
	public static void main (String [] args) {
	
		Framed.breite = 1;
		Framed.hoehe = 1;
		Framed.frame();
	}
	
	public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
    	char [] [] array = new char [breite+2] [hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				     array [j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

	public static void main (String [] args) {
	    
	    int [] yolo=  (Terminal.askIntArray(""Queue:\n""));
	   
	    
	    for(int i=0; i< yolo.length; i++) {
	    	int z= indexOfMax(yolo);
	    	Terminal.println(yolo[z]);
	    	yolo[z]= Integer.MIN_VALUE;
	    }
	}
	public static int indexOfMax(int [] a) {	
		   
		   int b = a[0];
		   int c= 0;
		   for(int i=0; i< a.length; i++) {
			   
			   if (b < a[i]) {
				   b=a[i];
				   c=i;
				   
			   } 
			  
		   }
	   
		   	if( b == Integer.MIN_VALUE){ 
			   return -1;
		   	}
		   	else {
		   		return c;
		   	}
		   	
			
		   	
	   
	   
	   }
	    
	}","public class Forest { 
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_260,VName_260,"public class Framed {

	public static void main(String[] args) {
		frame();
	}

    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [] [] array = new char [breite+2] [hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

	public static void main (String[] args) {
		int [] queue = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0; i < queue.length; i++) {
			int index = indexOfMax(queue);
			if(index == -1) {
				break;
			}
			System.out.println(queue[index]);
			queue[index] = Integer.MIN_VALUE;
		}
	}

	public static int indexOfMax(int[] queue){
		int index = -1;
		int biggest = 0;
		for(int i=0; i < queue.length; i++) {
			if(queue[i]>biggest) {
				biggest = queue[i];
				index = i;
			}
		}
		return index;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_252,VName_252,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][]array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    
	
    public static int indexOfMax(int[]u){
		
		int r = -1;
		int max = Integer.MIN_VALUE;
		for(int i=0;i<u.length;i++){
			if (u[i] > max){
				max = u[i];
				r = i;
			}
		}
		return r;
	}
	
	public static void main(String[] args) {
		int[]arr = Terminal.askIntArray(""Queue:\n"");
		while(indexOfMax(arr) != -1){
			System.out.println (arr[indexOfMax(arr)]);
			arr[indexOfMax(arr)] = Integer.MIN_VALUE;
		}
	}
}","public class Forest {
	
	//java RunForest -cls2 -ascii

   
    // Die Wald-Repraesentation ->von Main
    public static int[][] TREES;
	
	public static int[][]T= TREES;
	
	
	//public static int y = T.length;			//[y][x]
    //public static int x = T[0].length;
	
	
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    

		
		
		
    public static void step() {
		burn();
		step();
		TREES = T;
		
	}
		
			
	public static void grow(){
		for(int i=0; i<(T.length-1); i++) {
			for(int ii=0; ii<(T[0].length-1); ii++) {
				
				
				if(T[i][ii]>0){
					T[i][ii]++;
				}
				
				if(T[i][ii]>6){			// BAUM ERWACHSEN
					T[i][ii] = 0;
				}		
			}
		}
		
	}  
	
	public static void burn() {
		
		for(int i=0; i<(T.length-1); i++) {
			for(int ii=0; ii<(T[0].length-1); ii++) {   //LINKS nach RECHTS
				if(neighborIsOnFire(T,i,ii)&&indexInBounds(T,i,ii)){
					T[i][ii]++;
				}
					
					
					
				}
			}
	}
    
		
	
	public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
	

    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    

     
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_239,VName_239,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array=new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main (String [] args){
		int[] b= Terminal.askIntArray(""Queue:\n"");
		for (int i=0;b.length>i;i++){
			Terminal.println(indexOfMax(b));
			int k=indexOfMax(b);
			k=Integer.MIN_VALUE;
			}
			
	}
	public static int indexOfMax(int[] a) {   
		for (int i=1; i <a.length ;i++)
			for (int j=a.length-1;j>=i;j--){
				if (a[j]<a[j-1]){
					int h=a[j];
					a[j]=a[j-1];
					h=a[j-1];
				}
			}
			return a[h];
	}
	
			
 
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_241,VName_241,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char [breite + 2][hoehe + 2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String[] args) {

        int[] array = Terminal.askIntArray(""Queue:\n"");
        while(indexOfMax(array) != -1){
            int index = indexOfMax(array);
            Terminal.println(array[index]);
            array[index] = Integer.MIN_VALUE;
        }
    }

    public static int indexOfMax(int[] array){
        int index = 0;
        int max = array[0];

        for(int i = 1; i < array.length; i++){
            if (max < array[i]){
                index = i;
                max = array[i];
            }
        }

        if(max == Integer.MIN_VALUE){
            return -1;
        }
        return index;
    }
}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int
            TREE = 0,
            FIRE_START = 1,
            FIRE_END = 3,
            END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        add(TREES, getUpdate(TREES), 6);


    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for (int a = 0; a < x.length; a++){
            for (int b = 0; b < y.length; b++){

                if( (x[a][b] + y[a][b]) <= max ){
                    x[a][b] = x[a][b] + y[a][b];
                }
                else{
                    x[a][b] = (x[a][b] + y[a][b]) % (max + 1);
                }

            }
        }
    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    public static int[][] getUpdate(int[][] x) {
        int[][] y = new int[x.length][x.length];

        for(int i = 0; i < TREES.length; i++){
            for(int j = 0; j < TREES.length; j++){
                if (x[i][j] > 0){
                    y[i][j] += 1;
                }

                if ( (x[i][j] == 0) && neighborIsOnFire(x, i, j)){
                    y[i][j] += 1;
                }

                if (x[i][j] > 6){
                    y[i][j] = 0;
                }

            }
        }



        /*for(int i = 0; i < x.length; i++){
            for(int j = 0; j < x.length; j++){
                if( (x[i][j] >= TREES[i][j]) && neighborIsOnFire(x, i, j)){

                }
            }
        }*/

        return y;
    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_235,VName_235,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    public static void main(String[] args) {
		int[] queue = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0; i < queue.length; i++) {
			int index = indexOfMax(queue);
			Terminal.println(queue[index]);
			queue[index] = -1;
		}
		
	}
	
	public static int indexOfMax(int[] que) {
		int indexOflargest = 0;
		if(que == null || que.length == 0) {
			return -1;
		}
		for(int i = 1; i < que.length; i++) {
			if(que[i] > que[indexOflargest]) {
				indexOflargest = i;
			}
		}
		return indexOflargest;
	}
    
}","public class Forest {
	// Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    	add(TREES, getUpdate(TREES), END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
    	for(int i = 0; i < x.length; i++) {
    		for(int j = 0; j < x[i].length; j++) {
    			
        		x[i][j] = (x[i][j] + y[i][j])%(max+1);
        	}
    	}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
    	int[][] y = new int[x.length][x[0].length];
    	
    	for(int i = 0; i < x.length; i++) {
    		for(int j = 0; j < x[i].length; j++) {
    			
    			if(x[i][j] > 0) {
    				y[i][j] = 1;
    			} else if(x[i][j] == 0) {
    				if(neighborIsOnFire(x, i, j)) {
    					y[i][j] = 1;
    				} else {
    					y[i][j] = 0;
    				}
    			} else {
					y[i][j] = 0;
				}
    			
    		}
    	}
    	return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
    
    
    
}"
Name_509,VName_509,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_262,VName_262,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main(String[] args) {
		int[] array = Terminal.askIntArray(""Queue:\n"");
		for(int j = 0; j < array.length; j++) {
		int maxInd = indexOfMax(array);
		System.out.println(array[maxInd]);
		array[maxInd] = Integer.MIN_VALUE;
		}
	}
	
    public static int indexOfMax(int[] arr) {
		int maxInd = 0;
		for(int i = 0; i < arr.length; i++) {
			if(arr[i] > arr[maxInd]) {
				maxInd = i;
			}
		}
		if (maxInd >= 0) {
			return maxInd;
		}
		else {
			return maxInd = -1;
		}
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		int[][] update = getUpdate(TREES);		
		add(TREES, update, 6);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for(int i = 0; i < x.length; i++) {
			for(int j = 0; j < x[i].length; j++) {
				x[i][j] = (x[i][j] + y[i][j]) % (max + 1);
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] update = new int[x.length][x[0].length];
		for(int i = 0; i < x.length; i++) {
			for(int j = 0; j < x[i].length; j++) {
				if(x[i][j] > 0) {
					update[i][j] = 1;
				}
				else if(neighborIsOnFire(x, i, j) && x[i][j] == 0) {
					update[i][j] = 1;
				}
				else {
					update[i][j] = 0;
				}
			}
		}
		return update;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_257,VName_257,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_236,VName_236,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array =new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static int[] queue;
	
	public static void main (String[] args){
    
		//Terminal.println(Queue.indexOfMax(Terminal.askIntArray("""")));
	
		queue = Terminal.askIntArray(""Queue:\n"");		
		int k = indexOfMax(queue);
		while(k > -1){
			System.out.println(queue[k]);
			queue[k] = Integer.MIN_VALUE;
			k = indexOfMax(queue);
		}
	}
	
	public static int indexOfMax(int[] schlange){
		int wert = schlange[0];
		int position = 0;
	
		for(int i = 1; i < schlange.length; i++){
			if(schlange[i] > wert){
				wert = schlange[i];
				position = i;
			}
		}
		if(wert == Integer.MIN_VALUE){position= -1;}
		return position;
	}   
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
	public static void step() {
		
		int actStatus;
		int[][] aend = new int[TREES.length][TREES.length];
		
		for(int i = 0; i < TREES.length; i++){
			for(int j = 0; j < TREES[i].length; j++){
				// den Eintrag in der Position (i, j) abrufen, dann Fallunterscheidungen
				actStatus = TREES[i][j];
				if((actStatus > 0) && (actStatus < 6)){
					aend[i][j] = actStatus + 1;
				}
				else if ((actStatus == 0) && (neighborIsOnFire(TREES,i,j))){
					aend[i][j] = 1;
				}
				else if ((actStatus == 0) && ((neighborIsOnFire(TREES,i,j) == false))){
					aend[i][j] = 0;
				}

				else if(actStatus == 6){
					aend[i][j] = 0;
				}
				else{
					aend[i][j] = actStatus;
				}
				
			}
		}
		TREES = aend;
    }  

    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_53,VName_53,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
         int[][] array = new int [breite+6][hoehe+6];//Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main (String[]args)
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_244,VName_244,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args){
		int[] queue = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0;i < queue.length;i++){
		Terminal.println(queue[indexOfMax(queue)]);
		queue[indexOfMax(queue)] = Integer.MIN_VALUE;
		}
    }
	public static int indexOfMax(int[] queue){
		int maximum = 0;
		int indexOfMax = 0;
		for(int i = 0; i < queue.length;i++){
			if (queue[i] > maximum){
				maximum = queue[i];
				indexOfMax = i;
			}
		}
		return indexOfMax;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		add(TREES, getUpdate(TREES), END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				if(x[i][j] + y[i][j] <= max){
					x[i][j] = x[i][j] + y[i][j];
				}
				else{
					x[i][j] = 0;
				}
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int [TREES.length][TREES[0].length];
		for(int i = 0;i < 10;i++){
			for(int j = 0;j < 10;j++){
				if(neighborIsOnFire(x, i, j) && (x[i][j]==0)){
					y[i][j] += 1;
				}else if(x[i][j] > 0){
					y[i][j] += 1;
				}
			}
		}
		return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_5,VName_5,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array;
        array=new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args) {
    int[] array=Terminal.askIntArray(""Queue:\n"");
    for (int i=0; i<array.length; i++) {
        int max;  
        max=indexOfMax(array);
        System.out.println(array[max]);
        array[max]=Integer.MIN_VALUE;
        
        }
    }
    
    public static int indexOfMax(int[] array) {
        int max=0;
        for(int i=1; i<array.length; i++) {
            if(array[i]>array[max]) max=i;
        }
            return max;
        
    }

}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_240,VName_240,"public class Framed {
  public static int breite = 6;
  public static int hoehe = 3;
  
  public static void frame() {
//        System.out.println(hoehe);
    char[][] array = new char[breite+2][hoehe+2];
    
    //Hier soll das Array initialisiert werden!
    for (int i = 0; i < (hoehe + 2); i++) {
      for (int j = 0; j < (breite + 2); j++) {
        if ((i == 0 || j == 0) || (i == (hoehe + 1) || j == (breite + 1))) {
          System.out.print(""A"");
          array[j][i] = 'A';
        } else {
          System.out.print(""B"");
          array[j][i] = 'B';
        }
      }
      System.out.print(""\n"");
    }
    
    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");
    
    for (int i = 0; i < (hoehe + 2); i++) {
      for (int j = 0; j < (breite + 2); j++) {
        System.out.print(array[j][i]);
      }
      System.out.print(""\n"");
    }
  }
  public static void main(String[] args){
    Framed.breite=3;
    Framed.hoehe=6;
    Framed.frame();
  }
}","public class Queue {
  
  public static void main(String[] args) {
    int[] x = Terminal.askIntArray(""Queue:\n"");
    int y = 0;
    for (int i = 0; i < x.length; i++) {
      for (int j = i + 1; j < x.length; j++) {
        if (x[j] > x[i]) {
          y = x[i];
          x[i] = x[j];
          x[j] = y;
        }
      }
      Terminal.println(x[i]);
    }
  }
  
  static int indexOfMax(int[] x) {
    int max = 0;
    int index = 0;
    for (int j = 0; j < x.length; j++) {
      if (x[j] > max) {
        max = x[j];
        index = j;
      }
    }
    return index;
  }
  
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_248,VName_248,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args){
		
		int [] array = Terminal.askIntArray(""Queue:\n"");
		
		for(int i=0; i<array.length; i++){
			int index = indexOfMax(array);
			Terminal.println(array[index]);
            array[index] =  Integer.MIN_VALUE;
		}
	}
	
	public static int indexOfMax(int arr []) {
		int index = 0;
		int max = arr [index];
		
		for(int i = 0; i < arr.length; i++){
			if(arr[i] > max) {
				max = arr [i];
				index = i;
			}
		}
		return index;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * lasst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
			add(TREES, getUpdate(TREES), END);
	}
	
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {		
		
		for(int i = 0; i < x.length; i++){
			for(int j = 0; j < x[0].length; j++){
				x[i][j] = (x[i][j] + y[i][j])%(max+1);
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int [][] Update = new int [TREES.length][TREES[0].length];
		for (int i = 0; i < Update.length; i++) {
            for (int j = 0; j < Update[i].length; j++) {
				
				if (x[i][j] > TREE){
					Update[i][j] = Update[i][j] +1;
				}
				
				if(((x[i][j] == TREE)&&(neighborIsOnFire(x,i,j)))==true){
					Update[i][j] = Update[i][j] +1 ;
				}
				
				if (x[i][j] > END){
					Update[i][j]= 0;
				}
				
			}
		}
		return Update;
    }
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_475,VName_475,"public class Framed {
	public static void main(String[] args) {
	Framed.frame();}
    public static int breite = 6;
    public static int hoehe = 3;

public static void frame() {
        //Hier soll das Array initialisiert werden!
		char[][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }
		System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static void main(String[] args) {
		int[] array= new int[5];
		array= Terminal.askIntArray(""Queue: \n"");
		for (int i=0;i<array.length;i++) {
			System.out.println(array[indexOfMax(array)]);
			array[indexOfMax(array)]=Integer.MIN_VALUE;
		}
	
		 }
	 
    public static int indexOfMax(int[] array) {
		int max=Integer.MIN_VALUE;
		int index=0;
		for (int i=0;i<array.length;i++) {
			
			if(max<array[i]) {
				max=array[i];
				index=i;
			}
		}
	return index;
}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_288,VName_288,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char array[][] = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main (String[] args) {
		int[] numbers = Terminal.askIntArray(""Queue:\n"");
		for (int i=0; i<numbers.length; i++){
			int ind = indexOfMax(numbers);
			if (ind==-1) {
				break;
			}
			int min = numbers[ind];
			Terminal.println(min);
			 numbers[ind] = Integer.MIN_VALUE;
		}
	}

	
	public static int indexOfMax (int [] nums) {
		int max = nums[0];
		int indMax = 0;
		for(int i=0; i < nums.length;i++) {
			if (max < nums[i]) {
				max = nums[i];
				indMax = i;
			}
		}	if (max == Integer.MIN_VALUE) {
				return -1;
			}
		return indMax;
	}
}","public class Forest {
   

    public static int[][] TREES;
    

    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    

    public static void step() {
		int max = END;
		int[][] SUMME = new int [TREES.length][TREES[0].length];
		SUMME = getUpdate(TREES);
		add(TREES,SUMME,max);		
		
    }  
    

    public static void add(int[][] x, int[][] y, int max) {
		for (int i=0; i<x.length; i++){
			for (int j=0; j<x[i].length; j++) {
				if (0 != (x[i][j]+y[i][j]) % (max+1))
				x[i][j] = x[i][j]+y[i][j];
				else x[i][j] = 0;
			}
		}	
				
			
    }
    

    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int [x.length] [x[0].length];
		for (int i=0; i<x.length; i++){
			for (int j=0; j<x[i].length; j++) {
				if (x[i][j]>0) {
					y[i][j]++;
				}	
					
				else if (x[i][j] == 0 && neighborIsOnFire(x,i,j)==true)
					y[i][j]++;
					
				else y[i][j] = 0; 
				
				
			}
		}	return y;				
	}
    

    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }


    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_261,VName_261,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [] [] array = new char [breite+2] [hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
	public static void main(String[] args) {
		
		int [] zahlen = Terminal.askIntArray(""Queue:\n""); 
		
		for (int i = 0; i < zahlen.length; i++) { 
			
			int indexmax = indexOfMax(zahlen);
			
				if (indexmax == -1) {
					break;
				} 
			
				else {	
				Terminal.println(zahlen [indexmax]); 
				zahlen [indexmax] = Integer.MIN_VALUE;
				}	
		}	
		
	}
		
		public static int indexOfMax(int [] zahlen) {
			 int max=0;  
			 

			 for (int i = 0; i < zahlen.length; i++) {
				 
			 if (zahlen[i] > zahlen[max]) {
					 max = i; 
				 }   
			
			 }
			
			if (zahlen[max] == Integer.MIN_VALUE) {   
					max = -1;
				 }
				 
			
			return max; 
			 
		
		}
		

}","public class Forest {
   
    
    public static int[][] TREES;
    
    
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
  
    public static void step() {
	int [][] update = getUpdate(TREES);	
	add(TREES, update, END);
	
    }  
    

    public static void add(int[][] x, int[][] y, int max) {
		for(int i=0;i < x.length;i++){    
			for(int j=0; j< x[i].length;j++){    
				
				if((x[i][j]+y[i][j])%(max+1) == 0) {
				x[i][j] = 0;
				}
				
				else{
				x [i][j] = x[i][j] + y[i] [j];		
					}	
		
		
			}			
		}
    }
    
    
    public static int[][] getUpdate(int[][] x) {
		
		int[][] y = new int [x.length] [x[0].length];
			for(int i = 0; i < x.length; i++) {
				for(int j = 0; j < x[i].length; j++) {
				
					if (x[i][j] > TREE) {
					y[i][j] += 1;
					}	
				
					if(x[i][j] == TREE && neighborIsOnFire(x,i,j) == true) {
					y[i][j] += 1;
					}
	
				}
			}	
		return y;
	} 
    
   
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
  
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_272,VName_272,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static void main(String[] args) {
		int[] array = Terminal.askIntArray(""Queue: \n"");
		int maxIndex = 0;
		while (maxIndex > -1) {
			maxIndex = indexOfMax(array);
			if (maxIndex > -1) {
				System.out.println(array[maxIndex]);
				array[maxIndex] = Integer.MIN_VALUE;
			}
		}
	}

	public static int indexOfMax(int[] array) {
		int x = 0;
		int maxIndex = -1;
		for (int i = 0; i < array.length; i++) {
			if (array[i] > x) {
				x = array[i];
				maxIndex = i;

			}
		}
		return maxIndex;

	}
}","public class Forest {
		   
	    // Die Wald-Repraesentation
	    public static int[][] TREES = {
	    	     {0, 0, -1, 0, 0, 0, 0, 0, 4, 0},
	    	        {0, -1, -1, 0, 0, 0, 0, 0, -1, 0},
	    	        {-1, -1, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {-1, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
	    	        {0, 0, 0, 0, 0, 0, 0, 0, -1, 0},
    	        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	    		
	    };
	    
	    
	    
	    // Zustaende der Zellen
	    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
        
	    
	    /**
	     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
	     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
	     * laesst dabei nur Werte kleiner gleich END zu.
	     */
	    public static void step() {
	    	
	    }  
	    
	    /**
	     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
	     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
	     * des Modulo-Operators (%) an.
	     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
	     * @param x Der erste Summand.
	     * @param y Der zweite Summand.
	     * @param max Der Maximalwert der Summe.
	     */
	    //public static void add(int[][] x, int[][] y, int max) {
	    //}
	    
	    /**
	     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
	     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
	     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
	     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
	     * (neighborIsOnFire)
	     * @param x
	     * @return 
	     */
	    public static int[][] getUpdate(int[][] x) {
	        int [][] y = new int [x.length][x.length];
	        
	        
	    	
	    	
	    	
	    }
	    
	    /**
	     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
	     * brennt.
	     * @param x Das Array (der Wald/ die Baeume).
	     * @param i Index der Zelle in der 1.Array-Dimension.
	     * @param j Index der Zelle in der 2. Array-Dimension.
	     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
	     */
	    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
	        for(int k = i-1; k <= i+1; k++) {
	            for(int l = j-1; l <= j+1; l++) {
	                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    }
	    
	    /**
	     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
	     * @param x Der Wert einer Zelle (Zellstatus).
	     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
	     */
	    public static boolean isOnFire(int x) {
	        return x >= FIRE_START && x <= FIRE_END;
	    }
	    
	    /**
	     * Ueberprueft, ob der Index (i,j) im Array x liegt.
	     * @param x Das Array.
	     * @param i Index in der 1.Array-Dimension.
	     * @param j Index in der 2.Array-Dimension.
	     * @return True, wenn der Index im Array existiert, sonst false.
	     */
	    public static boolean indexInBounds(int[][] x, int i, int j) {
	        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
	    }

}"
Name_234,VName_234,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
      char [][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main(String[] args) {
       int[] array = Terminal.askIntArray(""Queue:\n"");

       for(int i = 0; i < array.length; i++) {
             int currentHighestIndex = indexOfMax(array);
             Terminal.println(array[currentHighestIndex]);
             array[currentHighestIndex] = Integer.MIN_VALUE;

       }
}
        public static int indexOfMax(int[] intArray){
        	int max = intArray[0];
           int largestIndex = 0;
           for ( int i = 1; i < intArray.length; i++ ) {
            if ( intArray[i] > intArray[largestIndex]) 
            	largestIndex = i;
            if (intArray[i] > max)
            	max = intArray[i];
	}
	if(max == Integer.MIN_VALUE) {
	    return -1;
	    } else {
	         return largestIndex;
	         }
	    }

}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int[][] updatedTrees = getUpdate(TREES);
        add(TREES, updatedTrees, END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for(int i = 0; i < x.length; i++){
            for(int j = 0; j < x[i].length; j++){
                x[i][j] = (x[i][j]+y[i][j])%(max+1);
            }
        }
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x Array zu aktualisieren.
     * @return Update matrix zum addieren.
     */
    public static int[][] getUpdate(int[][] x) {
        int[][]y = new int[x.length][x[0].length];
        for(int i = 0; i < x.length; i++){
            for(int j = 0; j < x[i].length; j++){
                if(x[i][j] > TREE || (x[i][j] == 0 && neighborIsOnFire(x, i, j))){
                    y[i][j] = 1;
                } else{
                    y[i][j] = 0;
                }
            }
        }

        return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_278,VName_278,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];//Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main(String[] args) {
       int[] array = Terminal.askIntArray(""Queue:\n"");
	
       for(int i = 0; i < array.length; i++) {
             int indexhigh = indexOfMax(array);
             Terminal.println(array[indexhigh]);
             array[indexhigh] = Integer.MIN_VALUE;
		
       }
}
        public static int indexOfMax(int[] array){
        	int a = 0;
		int maximumwert = array[0];
           
           for ( int i = 1; i < array.length; i++ ) {
            if ( array [i] > maximumwert ) {
		maximumwert = array[i];
		a= i;
            	}
	}
	boolean c= maximumwert == Integer.MIN_VALUE;
if(c) {
	    return -1;
	    } else {
	         return a;
	         }
	    }

}","public class Forest {
   
        public static int[][] TREES;
    
    
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    
    public static void step() {
        int[][] treesNew = getUpdate(TREES);
        add(TREES, treesNew, END);
    }  
    
    
    public static void add(int[][] x, int[][] y, int max) {
        for(int a = 0; a < x.length; a++){
            for(int b = 0; b < x[a].length; b++){
                x[a][b] = (x[a][b]+y[a][b])%(max+1);
            }
        }
    }
    
    
    public static int[][] getUpdate(int[][] x) {
        int[][]y = new int[x.length][x[0].length];
        for(int a = 0; a < y.length; a++){
            for(int b = 0; b < y[a].length; b++){
boolean z = x[a][b] > TREE;
                if(z)
                    y[a][b] = 1;
boolean c= x[a][b] == 0 && neighborIsOnFire(x, a, b);
                if(c)
                    y[a][b] = 1;
            }
        }

        return y;
    }
    
       public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
   
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_245,VName_245,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];//Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args){
        
        int temp;
        int[] num = Terminal.askIntArray(""Queue:\n"");
        int count = num.length;
        for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) 
            {
                if (num[i] < num[j]) 
                {
                    temp = num[i];
                    num[i] = num[j];
                    num[j] = temp;
                }
            }
        }
        
        for (int i = 0; i < count - 1; i++) 
        {
            Terminal.println(num[i]);
        }
        Terminal.println(num[count - 1]);
    }
    
    public static int indexOfMax(int[] num ){
        if ( num == null || num.length == 0 )
        return -1; 
        int Max = 0;
        for ( int i = 1; i < num.length; i++ ){
         if ( num[i] > num[Max] ) Max = i;
        }
        return Max; 
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_247,VName_247,"public class Framed {

    public static int breite = 6;
    public static int hoehe = 3;

    public static void main(String[] args) {
      frame();
    }

    public static void frame() {
        //Hier soll das Array initialisiert werden!
      char[][] array = new char[breite+2][hoehe+2];

	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A';
			    }
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{

  public static void main(String[] args) {
    int[] zahlen = Terminal.askIntArray(""Queue:\n"");
    while (isAllEqual(zahlen)==false){
    int max = indexOfMax(zahlen);
    System.out.print(zahlen[max]+""\n"");
    zahlen[max] = Integer.MIN_VALUE;
  }
  }

  public static int indexOfMax(int[] array){

    if(array == null || array.length == 0) return -1;


    int indexLargest = 0;
    for (int i = 1; i < array.length; i++){
    if(array[i] > array[indexLargest]) indexLargest = i;
    }
    if(isAllEqual(array)) return -1;
    return indexLargest;
  }

  public static boolean isAllEqual(int[] a){
       for(int i=1; i<a.length; i++){
           if(a[0] != a[i]){
               return false;
           }
       }

       return true;
   }

}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
     public static void step() {
 //omfg
        int[][] tree = new int[TREES.length][TREES.length];
        int positionswert;
        for(int k = 0; k<TREES.length; k++){
            for(int l = 0; l < TREES[k].length; l++){
                positionswert = TREES[k][l];
                if(positionswert < 0){
                    tree[k][l] = positionswert;
                }
                else{
            if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l))) tree[k][l]=1;
            if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l)==false)) tree[k][l]=0;
            if (positionswert == 6) tree[k][l]=0;
            if ((positionswert > 0) && (positionswert < 6)){
                tree[k][l] = positionswert + 1;
            }
        }
    }
 }

 TREES = tree;
     }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_256,VName_256,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char[100][100]; //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
public static void main (String[] args) {
    int[] array;
    array = Terminal.askIntArray(""Queue:\n"");
    
    for(int i = 0; i < array.length-1; i++) {
        int index = indexOfMax(array); 
        Terminal.println(array[index]); 
        array[index] = Integer.MIN_VALUE;
    }
    
}

public static int indexOfMax(int[] a) {
        int currentIndex = 0; 
        int sum = 0; 
        for(int i = 0; i == (a.length - 2); i++) {
            if(a[i] > a[i+1]) {
                currentIndex = i;
            } else if(a[i] < a[i+1]) {
                currentIndex = i+1; 
            }
        }
        
        if(a[0] == Integer.MIN_VALUE) {
            for(int i = 0; i >= a.length; i++) {
                int nextInt = a[i]; 
                sum = sum + nextInt; 
            }
            if(sum == Integer.MIN_VALUE * a.length) {
                return -1; 
            }
        } 
        
        return currentIndex; 
    }

}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    public static int[][] updateMatrix;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int length = TREES.length; 
        int height = TREES[0].length; 
        for(int x = 0; x >= length; x++) {
            for(int y = 0; y >= height; y++) {
                if(TREES[x][y] > 0 && TREES[x][y] < 7) {
                    updateMatrix[x][y] = TREES[x][y] + 1;
                } else if(TREES[x][y] == 0) {
                    if(neighborIsOnFire(TREES, y, x) == true) {
                        updateMatrix[x][y] = 1;
                    }
                } else if(TREES[x][y] > 6) {
                    TREES[x][y] = 0; 
                }
            }
            
        }
        getUpdate(TREES);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static void getUpdate(int[][] x) {
        for(int i = 0; i <= TREES.length; i++) {
            for(int j = 0; j <= TREES.length; j++) {
                TREES[i][j] = TREES[i][j] + updateMatrix[i][j];
            }
        }
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_254,VName_254,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    	public static void main(String[] args) {
		frame();
	}
    
    public static void frame() {
      char[][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue { 
    public static void main (String[] args) {
	int [] array =Terminal.askIntArray(""Queue:\n"");
		for (int i =0; i <array.length;i++){
			int index = indexOfMax (array);
			if (index ==-1) {
				break;
			}
		
			System.out.println(array[index]);
			array[index] = Integer.MIN_VALUE;
		}
	}
	
	public static int indexOfMax (int[] array) {
		int index = -1;
		int biggest=0;
		for(int i=0;i<array.length;i++) {
			if (array[i] > biggest) {
				biggest = array [i];
				index = i;
			}
		}
	
		return index;
    
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_17,VName_17,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_249,VName_249,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main (String[] args) {
        int[] array = Terminal.askIntArray(""Queue:\n"");


        for(int i = 0; i < array.length; i++) {
            System.out.println(array[indexOfMax(array)]);
            array[indexOfMax(array)] = Integer.MIN_VALUE;
        }
    }


    public static int indexOfMax (int[] x){
        int max = x[0];
        int index = 0;
        for (int i = 1; i < x.length; i++) {
            if (x[i] > max) {
                max = x[i];
                index = i;
            }
        }
        //if ((int)max > Integer.MIN_VALUE) {
            return index;
        //}else {
        //    return -1;
        }
}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */

    public static void step() {
        //int[][] newTrees = new int[x[1].length][x[2].length];
        int[][] updateM = fireMatrix(TREES);

        for (int i = 0; i < TREES[1].length; i++) {
            for (int j = 0; j < TREES[2].length; j++) {

                if (TREES[i][j] > 0 && TREES[i][j] < 6) {
                    TREES[i][j] = TREES[i][j] + 1;
                }else if(TREES[i][j] == 0 && updateM[i][j] == 1){
                    TREES[i][j] = TREES[i][j] +1;
                }else if(TREES[i][j] == 6){
                    TREES[i][j] = 0;

                }
            }
            ;
        }
    }

    public static int[][] fireMatrix(int[][] x) {
        int[][] updateM = new int[x[1].length][x[2].length];

        for (int i = 0; i < x[1].length; i++) {
            for (int j = 0; j < x[2].length; j++) {
            if (neighborIsOnFire(TREES, i, j)){
                updateM[i][j] = 1;
                }else{
                updateM[i][j] = 0;
                }

            }
        }
        return updateM;
    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
//    public static void add(int[][] x, int[][] y, int max) {
//        int[][] newTrees = new int[TREES[1].length][TREES[2].length];
//
//        for (int i = 0; i < TREES[1].length; i++) {
//            for (int j = 0; j < TREES[2].length; j++) {
//               newTrees[i][j] = x[i][j] + y[i][j];
//            }
//        }
//    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
//    public static int[][] getUpdate(int[][] x) {
//        int[][] updateMatrix = new int[x[1].length][x[2].length];
//
//        for (int i = 0; i < x[1].length; i++) {
//            for (int j = 0; j < x[2].length; j++) {
//                if (x[i][j] > 0) {
//                    updateMatrix[i][j] = x[i+1][j+1];
//                }else if(x[i][j] == 0 && neighborIsOnFire(TREES, i, j)){
//                    updateMatrix[i][j] = x[i+1][j+1];
//                }else if(x[i][j] == 6){
//                    updateMatrix[i][j] = 0;
//                }
//            }
//            ;
//        }
//    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_255,VName_255,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
public static void main (String[] args) {
	frame();
}
	
        public static void frame () {

        char [] [] array = new char [breite+2] [hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
 public static void main (String[] args) {
   
   int [] queue =  Terminal.askIntArray(""Queue: \n"");
   for (int i=0; i<queue.length;i++){
	 int index = indexOfMax(queue);
	 if(index == -1) {
	 break;
	 }
	 System.out.println(queue[index]);
	 queue[index] = Integer.MIN_VALUE;
	 
	 
   }

 }

public static int indexOfMax(int[] intArray) {
   if (intArray.length == 0 || intArray == null)
   return -1;

   int largestNumber = 0;
   for (int i=1; i < intArray.length; i++) {
     if (intArray[i]>intArray[largestNumber])
     largestNumber = i;

   }
   return largestNumber;
 }


}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_269,VName_269,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue { 
    public static void main ( String[] args) {
    int [] array = Terminal.askIntArray (""Queue:\n"");
        for (int i = 0; i < array.length;i++){
            int index = indexOfMax (array);
            if (index == -1) {
                break;
            }

            System.out.println(array[index]);
            array[index] = Integer.MIN_VALUE;
        }
    }
    public static int indexOfMax (int[] array) {
        int index = -1;
        int biggest = 0;
        for(int i=0;i<array.length;i++) {
            if (array[i] > biggest) {
                biggest = array [i];
                index = i;
            }
        }
        return index;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_285,VName_285,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][]array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
	public static void main (String[] args) {
		int[] array = Terminal.askIntArray(""Queue:\n""); //erfragt Integer-Array
		for (int i=0; i<array.length;i++) {
			System.out.println(array[indexOfMax(array)]);
			array[indexOfMax(array)]=Integer.MIN_VALUE;
		}

    }
	
	public static int indexOfMax (int[] a) { //extrahiert Index des groessten Elements
		int max = 0;
		int index = 0;
		for (int i=0; i<a.length;i++) {
			if (a[i]>max) {
				max = a[i];
				index = i;
			}
		}
		if (a[index]<0) {
			return -1;
		}
		return index;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
	// 10x10
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		add(TREES,getUpdate(TREES),END);
		return;
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for (int i=0; i<x.length; i++) {
			for (int j=0; j<x[i].length; j++) {
				x[i][j]=(x[i][j]+y[i][j])%(max+1);
			}
		}
		return;
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return y
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int [x.length][x.length];
		for (int i=0; i<x.length;i++){
			for (int j=0; j<x[i].length;j++) {
				if ( (TREES[i][j] > TREE) || ((TREES[i][j]==TREE) && neighborIsOnFire(TREES,i,j))) {
					y[i][j]=1;

				}
				else {
					y[i][j]=0;
				}
			}
		}
		return y; //gibt die Aktualisierungs-Matrix zurück
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_273,VName_273,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{
	public static void main(String[] args){
	    int[] warteschlange= Terminal.askIntArray(""Queue:\n"");
	      for(int i=0; i<warteschlange.length; i++){
			int index= indexOfMax(warteschlange);
			Terminal.println(warteschlange[index]);
			warteschlange[index]=Integer.MIN_VALUE;
			
			
		}
			
		
	}
	public static int findMax(int[] a){
		int max= a[0];
		for(int i=1; i<a.length;i++){
			if(a[i]>max){
				max=a[i];
			}
		}
		return max;
	}
	
	public static int indexOfMax(int[] a){
        int max = findMax(a);
        for(int i = 0; i < a.length; i++){
            if(a[i] == max) 
               return i;
		}		
		return -1;
		
		
		
     
		
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int m=TREES.length;
		int n=TREES[m].length;
		int[][]x=new int[m][n];
	    add(getUpdate(x),TREES,END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
          for(int i=0;i<x.length;i++){
			for(int j=0;j<x[i].length;j++){
				if(x[i][j]+y[i][j]<=max){
					x[i][j]=(x[i][j]+y[i][j])%(max+1);
				}
				
			}
			
		
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
        int m=x.length;
		int n=x[m].length;
		int[][] y= new int[m][n];
		for(int i=0;i<x.length;i++){
			for(int j=0;j<x[i].length;j++){
				if(x[i][j]>TREE || (x[i][j]==TREE && neighborIsOnFire(x,i,j)==true)){
					y[i][j]=x[i][j];
				}
				
			}
			
		
		}
		return y;
   }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_243,VName_243,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+ 2][hoehe+ 2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String[] args) {
    	int[] inputArray = Terminal.askIntArray(""Queue:\n"");
    	int maxIndex = indexOfMax(inputArray);
    	
    	while (maxIndex != -1) {
    		Terminal.println(inputArray[maxIndex]);
    		inputArray[maxIndex] = Integer.MIN_VALUE;
    		maxIndex = indexOfMax(inputArray);
    	}
    	
    }

	public static int indexOfMax(int[] array) {
		int max = array[0];
		int index = -1;
		
		for (int i = 0; i < array.length; i++) {
			if (array[i] >= max) {
				if (array[i] != Integer.MIN_VALUE) {
					max = array[i];
					index = i; 
				}
			}
		}

		return index;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_276,VName_276,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String[] args){

        int[] array = Terminal.askIntArray(""Queue:\n"");

        int abort = 0;

        for (int i = 0; abort != -1; i++){

            int index_max = indexOfMax(array);

            Terminal.println(array[index_max]);
            array[index_max] = Integer.MIN_VALUE;

            abort = indexOfMax(array);
        }
    }

    public static int indexOfMax(int[] array){

        boolean b = true;

        for (int i = 0; i < array.length; i++){

            if (array[i] != Integer.MIN_VALUE){

                b = false;
                break;
            }
        }

        if (b) {

            return -1;
        }

        int max = 0;
        int max_index = 0;

        for (int i=0; i < array.length; i ++){

            if (array[i] > max){

                max = array[i];
                max_index = i;
            }
        }
        return max_index;
    }
}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {

        add(TREES, getUpdate(TREES), END);
    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {

        for (int i = 0; i < x.length; i++){

            for (int j = 0; j < x[i].length; j++){

                x[i][j] = (x[i][j] + y[i][j]) % (max + 1);
            }
        }
    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    public static int[][] getUpdate(int[][] x) {

        int hoehe = x.length;
        int breite = x[0].length;

        int[][] y = new int[hoehe][breite];

        for (int i = 0; i < hoehe; i++){

            for (int j = 0; j < breite; j++){

                if ((x[i][j] > TREE) || (x[i][j] == TREE && neighborIsOnFire(x, i, j)) ){

                    y[i][j] = 1;
                }
            }
        }
        return y;
    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_233,VName_233,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
	public static void main (String[] args) {
		frame();
	}
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");
		
	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	
	public static void main (String[] args) { 
		
	int[] array = Terminal.askIntArray(""Queue:\n"");
	for(int i = indexOfMax(array); i> -1 ; i = indexOfMax(array))	{
		System.out.println(array[i]);
		array[i] = Integer.MIN_VALUE;
	}
	
	}
	
	
		public static int indexOfMax(int[] array) {
			int max = Integer.MIN_VALUE;
			int index = -1;
			for(int i = 0; i< array.length; i++) {
			if (array[i]>max) {
				max = array[i];
				index = i;
				
			}
		}
		
			return index;
		}


}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_253,VName_253,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
	public static void main (String[] args) {
		
		frame(); 
		
	}
		
    public static void frame() {
        int [] [] array = new int [breite+2] [hoehe+2]; //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	   for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                if ((i == 0 || j == 0) || (i == (hoehe+1) || j == (breite+1))) {
					System.out.print (""A""); 
					array [j] [i] = 'A'; 
				}
				else { 
					System.out.print (""B"");
					array [j] [i] = 'B';
				}
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args){
        
        int temp;
        int[] num = Terminal.askIntArray(""Queue:\n"");
        int count = num.length;
        for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) 
            {
                if (num[i] < num[j]) 
                {
                    temp = num[i];
                    num[i] = num[j];
                    num[j] = temp;
                }
            }
        }
        
        for (int i = 0; i < count - 1; i++) 
        {
            Terminal.println(num[i]);
        }
        Terminal.println(num[count - 1]);
    }
    
    public static int indexOfMax(int[] num ){
        if ( num == null || num.length == 0 )
        return -1; 
        int Max = 0;
        for ( int i = 1; i < num.length; i++ ){
         if ( num[i] > num[Max] ) Max = i;
        }
        return Max; 
        
    }
}","public class Forest {
    public static int[][] TREES;
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    public static void step() {
                add(TREES,getUpdate(TREES),END);
    }  
    public static void add(int[][]x, int[][]y, int max){
         for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){ 
                    x[i][j] = (x[i][j] + y[i][j])%(max+1);
                 
            }
       }
    }
    public static int[][] getUpdate(int [][]x){
        int[][] y= new int[TREES.length][TREES.length];
        for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){
                if( x[i][j] > TREE || x[i][j] == TREE && neighborIsOnFire(TREES,i,j)){
                y[i][j]=1;
                }
                else{
                    y[i][j]=0;
                }
            } 
        }
        return y;
    }
    
	
	
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_264,VName_264,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
        int[] a = Terminal.askIntArray(""Queue:\n"");
        int maxIndex = Queue.indexOfMax(a);
        while (maxIndex != -1) {
            System.out.println(a[maxIndex]);
            a[maxIndex] = Integer.MIN_VALUE;
            maxIndex = Queue.indexOfMax(a);
        }


    }

    public static int indexOfMax(int[] a) {
        int index = 0;
        for (int i = 1; i < a.length; i++) {
            if (a[index] < a[i]) { 
                index = i;
            }
        }
        if (a[index] == Integer.MIN_VALUE) {
            return -1;
        }
        return index;
    }

}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;


    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        Forest.add(TREES, Forest.getUpdate(TREES), 6);
    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     *
     * @param x   Der erste Summand.
     * @param y   Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                x[i][j] = (x[i][j] + y[i][j]) % (max+1);
                //System.out.println(x[i][j]+ "" = "" +  x[i][j] + "" + "" + y[i][j]);
            }
        }
    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     *
     * @param x
     */
    public static int[][] getUpdate(int[][] x) {
        int[][] update = new int[x.length][x.length];
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                if (x[i][j] > 0) {
                    update[i][j] = 1;
                }
                if (x[i][j] == 0 && Forest.neighborIsOnFire(x, i, j)) {
                    update[i][j] = 1;
                }
                //System.out.println(i + ""x"" + j + "": "" + x[i][j]);
            }
        }
        return update;
    }

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     *
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for (int k = i - 1; k <= i + 1; k++) {
            for (int l = j - 1; l <= j + 1; l++) {
                if (indexInBounds(x, k, l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     *
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     *
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_277,VName_277,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	public static void main (String[] args){
		int[] numbers = Terminal.askIntArray(""Queue:\n"");
		for(int i=0; i<numbers.length; i++){		
			int currentHighestIndex = indexOfMax(numbers);
			System.out.println(numbers[currentHighestIndex]);
			numbers[currentHighestIndex]=Integer.MIN_VALUE;
		}
		
	}
		
	public static int indexOfMax (int[] numbers){
		int maxValue = numbers[0];
		int index = 0;
		
			for(int a = 0; a < numbers.length; a++) {
				if(maxValue < numbers[a]) {
				maxValue = numbers[a];
				index = a;
				}		
			}
			if(maxValue==Integer.MIN_VALUE){
				return -1;
			}
			else{
				return index;
			}
		}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
	 *
	 * This method should simulate one time unit and has to be implemented.
	 * SUGGESTION: add (add) the result of getUpdate to TREES and allow only values <= END.
     */
    public static void step() {
		Forest.add(Forest.TREES, Forest.getUpdate(Forest.TREES), END);
		
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
	 
	 * SUGGESTION: add the elements of y to the elements of x if the sum is <= max. for that you can use the modulo operator (%). x=(x+y)%(max+1)
	 * @param x the first summand
	 * @param y the second summand
	 * @param max the maximum value of the sum.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for(int i=0; i<x.length; i++){
			for(int j=0; j<x[i].length; j++){
				x[i][j]=x[i][j]+y[i][j];
				x[i][j]=(x[i][j])%(max+1);
			}
		}
	}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
	 *
	 * SUGGESTION: Calculates the summand to update the Forest.
	 * for that another array y of the size of x is created.
	 * if a cell in x contains a value > TREE or the value is equal to TREE and a neighbor of the cell burns (neighborIsOnFire)
	 * @param x
	 * @return
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int[x.length][x[0].length];
		for(int i=0; i<x.length; i++){
			for(int j=0; j<x[i].length; j++){
				if(x[i][j]>0 || (x[i][j]==0 && Forest.neighborIsOnFire(x,i,j)==true)){
					y[i][j]=1;
				}
				else y[i][j]=0;
				}
			}
		return y;
	
	}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
	 *
	 * Checks if a (Moore-)neighbor of the cell with index (i,j) inside the array x burns.
	 * @param x the array (the forest/ the trees).
	 * @param i index of the cell 1. dimension.
	 * @param j index of the cell 2. dimension.
	 * @return True, if the neighbor of a cell burns, false, if no neighbor burns.
	 *
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
	 *
	 * checks, if the status value x represents a fire.
	 * @param x the value of a cell (cell status).
	 * @return True if the value represents a fire, when not false
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
	 *
	 *checks, if the index (i,j) is inside the Array x.
	 * @param x the array.
	 * @param i index of the 1. array dimension.
	 * @param j index of the 2. array dimension.
	 * @return true, if the index exists inside the array, when not false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}

	/**
	* WHAT TO DO:
	* the forest is simulated as an 2D array, TREES, the variable is already given and is intitialized outside the program.
	* the value of a cell stands for it's condition:
	* <0 stone
	* 0 fully grown tree
	* 1-3 burning tree
	* 4-6 growing tree
	*
	* you are requested to write the step method (the method head is given) that simulates one time unit according to the following rules.
	* when calling the method:
	* every value > 0 in TREES becomes +1 higher
	* every value equal 0 increases by 1, if a neighbor cell has a value between 1 and 3
	* contains a cell a value > 6, it'S value becomes 0 (so that a growing tree becomes a fully grown tree)
	* 
	* Hint:
	* Forest doesn't need a main method (look RunForest).
	*/"
Name_274,VName_274,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
		int[] array = Terminal.askIntArray(""Queue:\n"");
		int min = Integer.MIN_VALUE;
		int index = 0;
		do {
			index = indexOfMax(array);
			if (index != (-1)) {
				System.out.println(array[index]);
				array[index] = min;
			}
		} while (index != (-1));
	}
	
	public static int indexOfMax(int[] a) {
		int count = 0;
		int max = 0;
		int maxIndex = 0;
		for (int i = 0; i < a.length; i++) {
			if (a[i] == Integer.MIN_VALUE) {
			count ++;
			}
			else if (a[i] > max) {
			max = a[i];
			maxIndex = i;
			}
		}
		if (count == a.length)
		return -1;
		else
		return maxIndex;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        TREES = getUpdate(TREES);
    }  
    
    public static int[][] getUpdate(int[][] x) {
        int[][] y = new int[x.length][x[0].length];
		for (int i = 0; i < x.length; i++) {
			for (int j = 0; j < x[i].length; j++) {
				int zahl = x[i][j];
				if (zahl == 0 && neighborIsOnFire(x, i, j)) {
					y[i][j] = FIRE_START;
				} else if (zahl == 6) {
					y[i][j] = TREE;
				} else if (zahl > 0) {
					y[i][j] = zahl + 1;
				} else {
                    y[i][j] = x[i][j];
                }
			}
		}
		return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_237,VName_237,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{
  public static void main(String[] args) {
    int[] nummer = Terminal.askIntArray(""Queue:\n"");
    while (isAllEqual(nummer)==false){
    int max = indexOfMax(nummer);
    System.out.print(nummer[max]+""\n"");
    nummer[max] = Integer.MIN_VALUE;
    }
  }
  public static int indexOfMax(int[] array){
      if(array == null || array.length == 0) return -1;
      int indexLargest = 0;
      for (int i = 1; i < array.length; i++){
      if(array[i] > array[indexLargest]) indexLargest = i;
    }
    if(isAllEqual(array)) return -1;
    return indexLargest;
  }
  public static boolean isAllEqual(int[] a){
       for(int i=1; i<a.length; i++){
           if(a[0] != a[i]){
               return false;
           }
       }
       return true;
   }

}","public class Forest {

    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
     public static void step() {
   int[][] tree = new int[TREES.length][TREES.length];
   int positionswert; //der aktuelle Eintrag
   for(int k = 0; k<TREES.length; k++){
   for(int l = 0; l < TREES[k].length; l++){
   positionswert = TREES[k][l];
   if(positionswert < 0){
   tree[k][l] = positionswert;
   }
   else{
   if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l))) tree[k][l]=1;
   if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l)==false)) tree[k][l]=0;
   if (positionswert == 6) tree[k][l]=0;
   if ((positionswert > 0) && (positionswert < 6)){
   tree[k][l] = positionswert + 1;
   }
   }
   }
   }
   //zurück in TREES
   TREES = tree;
       }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    //public static int[][] getUpdate(int[][] x) {
    //}

    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_231,VName_231,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char['A']['B'];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	public static void main(String[] args) {
		int [] x = Terminal.askIntArray("""");
		Terminal.println(""Queue:"");
		
		for (int i = indexOfMax(x); i < x.length; i = indexOfMax(x)){
			Terminal.println(x[i]);
			x[i] = Integer.MIN_VALUE;
			i = indexOfMax(x);
			if (x[i] < 0){
				break;
			}
		}
    }

	public static int indexOfMax(int[] y) {
		int largest = 0; 
		for(int i = 0; i < y.length; i++ ){
			if ( y[i] > y[largest] ) largest = i;
		}
		return largest;
    }
	
	
	
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;

    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		int [][] trees = Forest.TREES;
		Forest.TREES = add(trees, getUpdate(trees), END);
		}  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int [][] add(int[][] x, int[][] y, int max) {
		for(int i = 0; i< x.length; i++){
			for(int j =0; j < x[0].length; j++){
				x[i][j] = (x[i][j] + y[i][j])%(max + 1);
			}
		}
		return x;
		
	}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
	 
    public static int[][] getUpdate(int[][] x) {
		int a = x.length; 
		int b = x[0].length;
		int [][] y = new int [a][b]; 
		for(int i = 0; i < a; i++) {
			for( int j = 0; j< b; j++) {
				//Terminal.println(x[i][j]);
				//Terminal.println(x[i][j] > TREE);
				if ( x[i][j] > TREE) {
					y[i][j] = 1;
				}
				else if (neighborIsOnFire(x, i, j) == true && x[i][j]==0){
					y[i][j] = 1;
				}
				else {
					y[i][j] = 0;
				}
			}
		}
		return y;
		
	}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_265,VName_265,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
		int[] queue = Terminal.askIntArray(""Queue:\n"");
		for(int i = 0; i < queue.length; i++) {
			int index = indexOfMax(queue);
			Terminal.println(queue[index]);
			queue[index] = -1;
		}
		
	}
	
	public static int indexOfMax(int[] que) {
		int indexOflargest = 0;
		if(que == null || que.length == 0) {
			return -1;
		}
		for(int i = 1; i < que.length; i++) {
			if(que[i] > que[indexOflargest]) {
				indexOflargest = i;
			}
		}
		return indexOflargest;
	}

            }","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        add(TREES, getUpdate(TREES), END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_270,VName_270,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[10][20];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_258,VName_258,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    public static void main(String[] args) {
    	int [] queue = Terminal.askIntArray(""Queue:\n""); 
    	int index = indexOfMax(queue);
    	while(index > -1) {
    		System.out.println(queue[index]);
    		queue[index] = Integer.MIN_VALUE;
    		index = indexOfMax(queue);
    	}
    }

    public static int indexOfMax(int[] arr) {
    	int maxElem = -1;
    	int maxElemIndex = -1;
    	for (int i = 0; i < arr.length; i++) {
    		if (arr[i] > maxElem) {
    			maxElem = arr[i];
    			maxElemIndex = i;
    		}
    	}
    	return maxElemIndex;
    }
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    	int [][] futureForest = new int[TREES.length][];
    	for (int i = 0; i < TREES.length; i++) {
    		futureForest[i] = new int[TREES[i].length];
    		for (int j = 0; j < TREES[i].length; j++) {
    			if (TREES[i][j] > 0) {
    				futureForest[i][j] = (TREES[i][j]+1)%7;
    			} else if(TREES[i][j] == TREE && neighborIsOnFire(TREES, i, j)) {
    				futureForest[i][j] = FIRE_START;
    			} else {
    				futureForest[i][j] = TREES[i][j];
    			}
    		}
    	}
    	TREES = futureForest;
    }  
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_246,VName_246,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
        int[] zahl = Terminal.askIntArray(""Queue:\n"");
        while (gleich(zahl)==false){
        int maxi = indexOfMax(zahl);
        Terminal.println(zahl[maxi]);
        zahl[maxi] =  Integer.MIN_VALUE;
        }
    }
    public static int indexOfMax(int[]array) {
        int index = 0;
        for(int i = 1; i < array.length; i++){
            if (array[i]>array[index]) index = i;
        } 
        if (gleich(array)==true) return -1;
        return index;
    }
    public static boolean gleich (int[]jo){
        for(int i = 1; i < jo.length; i++){
            if(jo[0] != jo[i]) return false;
        } 
        return true;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
   public static void step() {
int[][] tree = new int[TREES.length][TREES.length];
int positionswert;
for(int k = 0; k<TREES.length; k++){
for(int l = 0; l < TREES[k].length; l++){
positionswert = TREES[k][l];
if(positionswert < 0){
tree[k][l] = positionswert;
}
else{
if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l))) tree[k][l]=1;
if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l)==false)) tree[k][l]=0;
if (positionswert == 6) tree[k][l]=0;
if ((positionswert > 0) && (positionswert < 6)){
tree[k][l] = positionswert + 1;
}
}
}
}

TREES = tree;
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_46,VName_46,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
         char[][] array = new char[hoehe][breite];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_263,VName_263,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;

    public static void main(String[] args) {
            Framed.frame();
        }

    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A';
			    }
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args){
      
        Terminal.println(indexOfMax(Terminal.askIntArray(""Queue:\n"")));
    }
    public static int  indexOfMax(int arr []) {
        int index = 0;
        int max = arr [index];

        
        }
        return index;
    }

}","public class Forest {

    // Die Wald-Repraesentation

	public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;

    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {


			add(TREES);

    }

    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x) {
		int max = 6;
		int[][] y = getUpdate(x);
		for(int i = 0; i < x.length; i++) {
			for(int j = 0; j < x.length; j++) {
				x[i][j]=(x[i][j]+y[i][j])%(max+1);
				if(x[i][j] > END) x[i][j] = TREE;
			}
		}
		return x;
    }

    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return
     */
    public static int[][] getUpdate(int[][] x) {
		int a = x.length;
	int[][] y = new int[a][a];

		for(int i = 0; i < x.length; i++) {
			for(int j = 0; j < x.length; j++) {
				if(x[i][j] > TREE) y[i][j]=1;
					else if(x[i][j]== TREE && neighborIsOnFire(x, i, j)==true) {
						y[i][j]=1;
					}
					else y[i][j]=0;
			}
		}
		return y;
    }
	 /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }

    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }


}"
Name_271,VName_271,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    public static void main(String[] args){
		frame();
	}
    public static void frame() {
        char[][]array=new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
			//System.out.print(""i: ""+Integer.toString(i)+""\n"");
		    for(int j = 0; j <= (breite+1); j++) {
				//System.out.print(""j: ""+Integer.toString(j)+""\n"");
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args){
		int number[]= Terminal.askIntArray(""Queue:\n"");
		int[] numbertwo=number.clone();
		int imax = -99;
	
		for(int i = 0;i< number.length;i++){
			
			imax = indexOfMax(number);
			
			System.out.println(numbertwo[imax]);
			
		}
		
	}
    public static int indexOfMax(int[] tablica){
		
		int indeks = -1;
		int maxwartosc = 0;
		
		for (int i = 0; i < tablica.length; i++) 
		{
			if (maxwartosc < tablica[i]) 
			{
				maxwartosc = tablica[i];
				indeks = i;
			}
		}
		if(indeks>=0){
			tablica[indeks]= Integer.MIN_VALUE; 
		}
		return indeks;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_268,VName_268,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args){
        
        int temp;
        int[] num = Terminal.askIntArray(""Queue:\n"");
        int count = num.length;
        for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) 
            {
                if (num[i] < num[j]) 
                {
                    temp = num[i];
                    num[i] = num[j];
                    num[j] = temp;
                }
            }
        }
        
        for (int i = 0; i < count - 1; i++) 
        {
            Terminal.println(num[i]);
        }
        Terminal.println(num[count - 1]);
    }
    
    public static int indexOfMax(int[] num ){
        if ( num == null || num.length == 0 )
        return -1; 
        int Max = 0;
        for ( int i = 1; i < num.length; i++ ){
         if ( num[i] > num[Max] ) Max = i;
        }
        return Max; 
    }
}","public class Forest {
    public static int[][] TREES;
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    public static void step() {
               add(TREES,getUpdate(TREES),END);
    }  
    public static void add(int[][]x, int[][]y, int max){
         for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){ 
                    x[i][j] = (x[i][j] + y[i][j])%(max+1);
                 
            }
       
        }
    }
    public static int[][] getUpdate(int [][]x){
        int[][] y= new int[TREES.length][TREES.length];
        for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){
                if( x[i][j] > TREE || x[i][j] == TREE && neighborIsOnFire(TREES,i,j)){
                y[i][j]=1;
                }
                else{
                    y[i][j]=0;
                }
            } 
        }
        return y;
    }
    
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_281,VName_281,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {	
	
	public static void main(String[] args) {
		
		int[] inputArray = Terminal.askIntArray(""Queue:\n"");
		while (indexOfMax(inputArray)!= -1){
			System.out.println(inputArray[indexOfMax(inputArray)]);
			inputArray[indexOfMax(inputArray)]=Integer.MIN_VALUE; 
		}
	}
	
	public static int indexOfMax (int[] array){
		  int index = 0;
		  for (int i = 0; i < array.length; i++){
		      if (array[i] >= array[index]){
		    	  index=i;
		      }
		  }
		  if(array[index]!=Integer.MIN_VALUE){
			  return index;
		  }
		  else{
			  return -1;
		  }
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_49,VName_49,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue{
	public static void main(String[] args){
	
		int[] array=Terminal.askIntArray(""Queue:\n"");
  		sort(array);		
		for( int i= 0; i<array.length;i++){
		System.out.println(array[i]);
		}

	}
	public static int[] sort(int[]array){
		
		int temp=0;
		for (int i =0; i<array.length;i++){
			for (int j=1; j<array.length-i; j++){
				if(array[j]>array[j-1]){
					temp=array [j-1];
					array[j-1]=array[j];
					array[j]=temp;
				}
			}
		}
		return array;
	}
		public static int indexOfMax(int[]arr){
		
	
		int Max=0;	
		if (arr.length == 0 )
		return Max=-1;  
	 	
  		for ( int i = 1; i < arr.length; i++ ){
     		if ( arr[i] > arr[Max] ) Max = i;
  		}
  		return Max;
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_279,VName_279,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char array [][] = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

public static void main(String[] args) {
        int[] queue = Terminal.askIntArray(""Queue:\n"");
        for(int i = 0; i < queue.length; i++) {
            int index = indexOfMax(queue);
            Terminal.println(queue[index]);
            queue[index] = Integer.MIN_VALUE;
        }
        
    }
    
    public static int indexOfMax(int[] q) {
        int indexm = 0;
        if(q == null || q.length == 0) {
            return -1;
        }
        for(int i = 1; i < q.length; i++) {
            if(q[i] > q[indexm]) {
                indexm = i;
            }
        }
        return indexm;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_242,VName_242,"public class Framed {
    public static void main(String []args) {
        frame();}
    public static int breite = 6;
    public static int hoehe = 3;
    public static void frame() {
        int[][] array = new int[10][10];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
        int[] x = new int[n];
    }
    
    Terminal.askIntArray(""Queue:\n"");
    Terminal.println(""n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_275,VName_275,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
public static int[] array() {
	int[] intArray = Terminal.askIntArray(""Queue:\n"");
	return intArray;
}

public static int indexOfMax(int[] array) {
	int max = array[0];
	int index = 0;
	for (int i = 0; i < array.length; i++) {
	  if ( array[i] > max ) {
	      max = array[i];
	      index = i;
	   } 
	}
	return index; 
}

public static void main(String[] args) {
	int[] intArray = array();
	for(int i = 0; i < intArray.length; i++){
		int ind = indexOfMax(intArray);
		Terminal.println(intArray[ind]);
		intArray[ind] = Integer.MIN_VALUE;
		if (ind == -1) {
			break;
		}
	}
}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		int i = 0;
		int j = 0;
		do {
			if(TREES[i][j] >= 0 && TREES[i][j]!= 0) {
				TREES[i][j]++;
			}
			if (TREES[i][j] == 0 && neighborIsOnFire(TREES,i,j)) {
				TREES[i][j] ++;
			}
			if (TREES[i][j] >= 6 && TREES[i][j]!= 6) {
				TREES[i][j] = 0;
			}
		} while(add(getUpdate(TREES),TREES,i+j) <= END);
			
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for( i=0 ; i<x.length ; i++) {
		     if (max<x[i]) {
		            max = x[i] ;
				}
			x = (add(x,y))%(max+1);	
		}
    } //?????????????? 
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][] y = new int[x.length][x.length];
		int a = 0;
		int b = 0;
		if (x[a][b] >= TREE && x[a][b] != TREE || x[a][b] == TREE && neighborIsOnFire(TREES,a,b)){
			return y = add(x,y);
		}
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_259,VName_259,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {

    public static void main(String[] args) {
        int[] array = Terminal.askIntArray(""Queue:\n"");
        while (indexOfMax(array) > -1) {
            int arrayIndex = indexOfMax(array);
            System.out.println(array[arrayIndex]);
            array[arrayIndex] = Integer.MIN_VALUE;
        }
    }
    
    public static int indexOfMax(int[] array) {
        int maxIndex = 0;
        for (int i = 1; i < array.length; i++) {
            if (array[i] > array[maxIndex]) {
                maxIndex = i;
            }
        }
        if (array[maxIndex] == Integer.MIN_VALUE) {
            return -1;
        }
        return maxIndex;
    }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
        int[][] update = getUpdate(TREES);
        add(TREES, update, 6);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                TREES[i][j] = (x[i][j] + y[i][j]) % (max+1);
            }
        }
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
        int[][] update = new int[x.length][x[0].length];
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                if (x[i][j] > 0) {
                    update[i][j] = 1;
                } else if (x[i][j] == 0) {
                    if (neighborIsOnFire(x, i, j)) {
                        update[i][j] = 1;
                    } else {
                        update[i][j] = 0;
                    }
                } else {
                    update[i][j] = 0;
                }
            }
        }
        return update;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_267,VName_267,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
	
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    
    	
	
	public static void main(String[] args){
		int[] schlange = Terminal.askIntArray(""Queue:\n"");
		for(int i=0;i<schlange.length;i++) {
			int indexOfMax = indexOfMax(schlange);
			Terminal.println(schlange[indexOfMax]);
			schlange[indexOfMax] = Integer.MIN_VALUE;
		}
		
		
	}
	
	public static int indexOfMax (int [] schlange){
		int indexOfMax=0;
		boolean abgearbeitet = true;
			
			
		for(int i=1;i<schlange.length;i++) {
		
		if (schlange[i]>schlange[indexOfMax])
			{
				 indexOfMax = i;
				
			}		
			
		}
		
			
		for(int i=0;i<schlange.length;i++){
			
			
			if(schlange[i]!=Integer.MIN_VALUE){
				
				abgearbeitet=false;
				
		
				
			}
			
			
			
		}	
	
		if(abgearbeitet){
				
				return -1;
				
		}
		else
		{
		
		
		return indexOfMax;
		
		}
	}
	
	
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_284,VName_284,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
        int[] array= Terminal.askIntArray(""Queue:\n"");
        for (int i=0; i<array.length;i++) {
            int m=indexOfMax(array);
            Terminal.println(array[m]);
            array[m]=Integer.MIN_VALUE;
            
        }
    }
    public static int indexOfMax(int[] array) {
        int max = array[0];
        int x=0;
        for (int i=1; i<array.length;i++) {
            if (array[i]>max){
                max=array[i];
                x=i;
            }
        }
        return x;
    
    }
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_71,VName_71,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_266,VName_266,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
	
	

	public static void main(String[] args) {
		
		int[] reihe = Terminal.askIntArray(""Queue:\n"");
		
		int min = Integer.MIN_VALUE;
		
		for(int i = 0 ; i < reihe.length; i++) {
		
		Terminal.println(reihe[indexOfMax(reihe)]);
		reihe[indexOfMax(reihe)] = min;
		
		
		
		}
	}
	
	public static int indexOfMax(int[] reihe) {
		int index = 0;
		int max = reihe[index];
		for (int m = 0; m < reihe.length; m++) {
			if (reihe[m] > max) {
				max = reihe[m];
				index = m;
				
			}
			else if(index > m) return -1;
			
		}
		return index;
		
		
		
		
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    
	public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		
		 
			add(TREES);
		
    }
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x) {
		int max = 6;
		int[][] y = getUpdate(x);
		for(int index1 = 0; index1 < x.length; index1++) {
			for(int index2 = 0; index2 < x.length; index2++) {
				x[index1][index2]=(x[index1][index2]+y[index1][index2])%(max+1);
				if(x[index1][index2] > END) x[index1][index2] = TREE;
			}
		}
		return x;
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int m = x.length;
	int[][] y = new int[m][m];
		
		for(int index1 = 0; index1 < x.length; index1++) {
			for(int index2 = 0; index2 < x.length; index2++) {
				if(x[index1][index2] > TREE) y[index1][index2]=1;
					else if(x[index1][index2]== TREE && neighborIsOnFire(x, index1, index2)==true) {
						y[index1][index2]=1;
					}
					else y[index1][index2]=0;
			}
		}	
		return y;
    }
	 /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
    

}"
Name_283,VName_283,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2];
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String[] args) {
	int[] input;
    input=Terminal.askIntArray(""Queue:\n"");
	int stelle;
    for (int i=0; i<input.length; i++){
		stelle=indexOfMax(input);
		if (stelle == -1){
			break;
		}
		else{
			System.out.println(input[stelle]);
			input[stelle]=Integer.MIN_VALUE;
		}
	}
	}
	public static int indexOfMax(int[] a){
		int index = 0;
		int sum =0;
		for (int i=0; i<a.length; i++){
			sum+=a[i];
		}
		sum=sum/Integer.MIN_VALUE;	
		if (sum==a.length){
			return -1;
		}
		else{
			for (int i=1; i<a.length; i++){
				if (a[index]>a[i]){
				}
				else{
					index=i;
				}
			}
			return index;
		}
	}
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		add(TREES, getUpdate(TREES), END);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static void add(int[][] x, int[][] y, int max) {
		for(int i=0; i<x.length;i++){
			for(int j=0; j<x[i].length; j++){
				x[i][j]=(x[i][j]+y[i][j])%(max+1);
			}
		}
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int[][]y = new int[x.length][x.length];
		for(int i=0;i<x.length;i++){
			for(int j=0;j<x.length;j++){
				if(x[i][j]>0){
					y[i][j]=1;
				}
				else if(x[i][j]==0 & neighborIsOnFire(x,i,j)){
					y[i][j]=1;
				}
				else{
					y[i][j]=0;
				}
			}
		}
		return y;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_282,VName_282,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char[][] array = new char[breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
	public static void main(String [] args){
		
    int[] a = Terminal.askIntArray(""Queue:\n"");
    for (int i = 0;i<a.length;i++){
        int b = indexOfMax(a);
          if (b == -1){
            break;
          }
        System.out.println(a[b]);
        a[b]= Integer.MIN_VALUE;
    }
}
public static int indexOfMax(int[] b){ 
     boolean abgearbeitet = true; 
	 int indexOfMax = 0;
   for(int x = 0;x<b.length;x++){
     if (b[x]> Integer.MIN_VALUE){ 
         abgearbeitet = false;
     }
   }
   if (abgearbeitet){ 
       return (-1);
   }
   else{
	   int max=b[0];
    for(int i = 1;i < b.length;i++){
     if (b[i]>max){
         max = b[i];
     }
        
    }
    for(int i = 0;i <b.length;i++){ 
        if (b[i]==max){ 
          indexOfMax = i; 
        }
    }
return indexOfMax;
}
   }
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
	TREES = add(TREES, getUpdate(TREES), END); 
	}
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x, int[][] y, int max) {
		for (int i = 0; i < x.length; i++){
			for (int j = 0; j < x[i].length;j++){
			x[i][j] = (x[i][j]+y[i][j])%(max+1);
		}
    }  
	return x; 
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
	 int[][] y = new int[(x.length)][(x[0].length)];
	 for (int i = 0; i < x.length; i++){
			for (int j = 0; j < x[i].length;j++){
				switch (x[i][j]){
					case 0 : 
					if (neighborIsOnFire(x, i, j)){ 
					y[i][j] = 1; 
					}
					else{ y[i][j] = 0;
					}
					break; 
					case 1 : y[i][j] = 1;break;
					case 2 : y[i][j] = 1;break;
					case 3 : y[i][j] = 1;break;
					case 4 : y[i][j] = 1;break; 
					case 5 : y[i][j] = 1;break; 
					case 6 : y[i][j] = (-6);break; 
					default: y[i][j] = 0;break; 
			}
	 
		}	
    }
	return y; 
	}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_280,VName_280,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char [][] array = new char [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    public static void main(String [] args){
        
        int temp;
        int[] num = Terminal.askIntArray(""Queue:\n"");
        int count = num.length;
        for (int i = 0; i < count; i++) 
        {
            for (int j = i + 1; j < count; j++) 
            {
                if (num[i] < num[j]) 
                {
                    temp = num[i];
                    num[i] = num[j];
                    num[j] = temp;
                }
            }
        }
        
        for (int i = 0; i < count - 1; i++) 
        {
            Terminal.println(num[i]);
        }
        Terminal.println(num[count - 1]);
    }
    
    public static int indexOfMax(int[] num ){
        if ( num == null || num.length == 0 )
        return -1; 
        int Max = 0;
        for ( int i = 1; i < num.length; i++ ){
         if ( num[i] > num[Max] ) Max = i;
        }
        return Max; 
    }
}","public class Forest {
    public static int[][] TREES;
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    public static void step() {
               add(TREES,getUpdate(TREES),END);
    }  
    public static void add(int[][]x, int[][]y, int max){
         for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){ 
                    x[i][j] = (x[i][j] + y[i][j])%(max+1);
                 
            }
       
        }
    }
    public static int[][] getUpdate(int [][]x){
        int[][] y= new int[TREES.length][TREES.length];
        for(int i=0; i<x.length;i++){
            for(int j=0;j<x.length;j++){
                if( x[i][j] > TREE || x[i][j] == TREE && neighborIsOnFire(TREES,i,j)){
                y[i][j]=1;
                }
                else{
                    y[i][j]=0;
                }
            } 
        }
        return y;
    }
    
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_476,VName_476,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char[][] array = new char [100][100];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
Terminal.askIntArray ( ""Queue:\n"" );
    public class sortieren {

  public static void main( String[] args )  {

    System.out.println( ""Zahl1 eingeben und mit Return abschliessen:"" );
    int a = 0;
    System.out.println( ""Zahl2 eingeben und mit Return abschliessen:"" );
    int b = 0;
    System.out.println( ""Zahl3 eingeben und mit Return abschliessen:"" );
    int c = 0;

    try {
      BufferedReader in = new BufferedReader(
                          new InputStreamReader( System.in ) );
      	a = Integer.parseInt(in.readLine());
	b = Integer.parseInt(in.readLine());
	c = Integer.parseInt(in.readLine());


    } catch( Exception ex ) {
      System.out.println( ex.getMessage() );
    }
  
	if(a+b+c) ==0) {
	System.out.println(""0"");

	}		

	else {
	
		if(a>b) {
			
			if(b>c) {

				System.out.println(c);
				System.out.println(b);
				System.out.println(a);

				}
			else {
				System.out.println(b);
				System.out.println(c);
				System.out.println(a);
				}
			}
		else {
		
			if(a>c) {

				System.out.println(c);
				System.out.println(a);
				System.out.println(b);

				}

			else {

				System.out.println(a);
				System.out.println(c);
				System.out.println(b);

				}

			}
		}

  	}
   }

    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_290,VName_290,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        byte[] [] array = new byte[i] [j];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_286,VName_286,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        char[][] array = new char[breite+2][hoehe+2]  ;
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    //public static int[] Eingabe = Terminal.askIntArray(""Queue:\n"");
		
		public static void main(String[] args){
			int[] Eingabe = Terminal.askIntArray(""Queue:\n"");
			for(int i=0; i<Eingabe.length; i++){
				int maxindex = indexOfMax(Eingabe);
				if(maxindex == -1) {
					break;
				}
				System.out.println(Eingabe[maxindex]);
				Eingabe[maxindex] = Integer.MIN_VALUE;
			}
		}
		
		public static int indexOfMax(int[] Eingabe){
			int momentanMax = 0;
			int momentanInd = 0;
			int laenge = Eingabe.length;
				for(int c=0; c<Eingabe.length; c++){
					if(Eingabe[c] != Integer.MIN_VALUE){
					}
					else{
						if(c == laenge){
							return -1;
						}
					}
				}
				
			
				for(int j=0; j<Eingabe.length; j++){
					int blick = Eingabe[j];
					if(blick >= momentanMax){
					momentanMax = blick;
					momentanInd = j;
					} else{}
				}
			
				return momentanInd;
			
		}
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;

    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
		int h = TREES.length;
		int v = TREES[0].length;
		int[][] update = new int[h][v];
		update = getUpdate(TREES);
		TREES = add(TREES, update, 6);
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    public static int[][] add(int[][] x, int[][] y, int max) {
		int laenge = x.length;
		int breite = x[0].length;
		for(int h=0; h<laenge; h++){
			for(int v=0; v<breite; v++){
				x[h][v] = x[h][v] + y[h][v];
			}
		}
		return x;
    }
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    public static int[][] getUpdate(int[][] x) {
		int laenge = x.length;
		int breite = x[0].length;
		int[][] update = new int[laenge][breite];
		for(int h=0; h<laenge; h++){
			for(int v=0; v<breite; v++){
				if(x[h][v] == TREE && neighborIsOnFire(x, h, v)){
					update[h][v]++;
				}
				if(isOnFire(x[h][v])){
					update[h][v]++;
				}
				if(x[h][v] >= 4 && x[h][v] <=5){
					update[h][v]++;
				}
				if(x[h][v] == END){
					update[h][v] = -6;
				}
				
			}
		}
		return update;
    }
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_287,VName_287,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
        char [][] array= new char  [breite+2][hoehe+2];
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public static void step() {

int[][] tree = new int[TREES.length][TREES.length];
int positionswert; 
for(int k = 0; k<TREES.length; k++){
for(int l = 0; l < TREES[k].length; l++){
positionswert = TREES[k][l];
if(positionswert < 0){
tree[k][l] = positionswert;
}
else{
if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l))) tree[k][l]=1;
if ((positionswert == 0) && (neighborIsOnFire(TREES,k,l)==false)) tree[k][l]=0;
if (positionswert == 6) tree[k][l]=0;
if ((positionswert > 0) && (positionswert < 6)){
tree[k][l] = positionswert + 1;
}
}
}
}
TREES = tree;
    }"
Name_62,VName_62,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
Name_289,VName_289,"public class Framed {
    public static int breite = 6;
    public static int hoehe = 3;
    
    public static void frame() {
        //Hier soll das Array initialisiert werden!
	    for(int i = 0; i <= (hoehe+1); i++) {
		    for(int j = 0; j <= (breite+1); j++) {
			    if((i == 0 || j == 0) || ( i == (hoehe+1) || j == (breite+1))) {
				    System.out.print(""A"");
				    array[j][i] = 'A'; 
			    } 
				else {
				    System.out.print(""B"");
				    array[j][i] = 'B';
			    }
		    }
		    System.out.print(""\n"");
	    }

	    System.out.print(""\n---Und hier jetzt nochmal das Viereck aus dem Array---\n\n"");

	    for(int i = 0; i <= (hoehe+1); i++){
		    for(int j = 0; j <= (breite+1); j++){
                System.out.print(array[j][i]);
            }
		    System.out.print(""\n"");
	    }
    }
}","public class Queue {
    
    Terminal.askIntArray(""Queue:\n"");
    
}","public class Forest {
   
    // Die Wald-Repraesentation
    public static int[][] TREES;
    
    // Zustaende der Zellen
    public static final int TREE = 0, FIRE_START = 1, FIRE_END = 3, END = 6;
    
    /**
     * Diese Methode soll einen Zeitschritt simulieren und MUSS implementiert werden.
     * VORSCHLAG: Addiert (add) das Resultat von getUpdate zu TREES und 
     * laesst dabei nur Werte kleiner gleich END zu.
     */
    public static void step() {
    }  
    
    /**
     * VORSCHLAG: Addiert die Elemente von y zu den Elementen von x, wenn die
     * Summe kleiner gleich max ist. Dafuer bietet sich die Verwendung 
     * des Modulo-Operators (%) an.
     * Symbolisch ausgedrueckt: x = (x+y)%(max+1)
     * @param x Der erste Summand.
     * @param y Der zweite Summand.
     * @param max Der Maximalwert der Summe.
     */
    //public static void add(int[][] x, int[][] y, int max) {
    //}
    
    /**
     * VORSCHLAG: Berechnet den Summanden um den Wald zu aktualisieren.
     * Dafuer wird ein neues Array y der selben Groesse wie x erzeugt.
     * Wenn eine Zelle in x einen Wert echt groesser als TREE enthaelt oder
     * der Wert der Zelle gleich TREE ist und ein Nachbar der Zelle brennt
     * (neighborIsOnFire)
     * @param x
     * @return 
     */
    //public static int[][] getUpdate(int[][] x) {
    //}
    
    /**
     * Ueberprueft ob ein (Moore-)Nachbar der Zelle mit Index (i,j) im Array x
     * brennt.
     * @param x Das Array (der Wald/ die Baeume).
     * @param i Index der Zelle in der 1.Array-Dimension.
     * @param j Index der Zelle in der 2. Array-Dimension.
     * @return True, wenn eine der Nachbarzellen brennt, false, wenn keine der Nachbarzellen brennt.
     */
    public static boolean neighborIsOnFire(int[][] x, int i, int j) {
        for(int k = i-1; k <= i+1; k++) {
            for(int l = j-1; l <= j+1; l++) {
                if(indexInBounds(x,k,l) && isOnFire(x[k][l])) {
                    return true;
                }
            }
        }
        return false;
    }
    
    /**
     * Ueberprueft, ob der Statuswert x einen Brand repaesentiert.
     * @param x Der Wert einer Zelle (Zellstatus).
     * @return True, wenn der Wert einen Brand repraesentiert, sonst false.
     */
    public static boolean isOnFire(int x) {
        return x >= FIRE_START && x <= FIRE_END;
    }
    
    /**
     * Ueberprueft, ob der Index (i,j) im Array x liegt.
     * @param x Das Array.
     * @param i Index in der 1.Array-Dimension.
     * @param j Index in der 2.Array-Dimension.
     * @return True, wenn der Index im Array existiert, sonst false.
     */
    public static boolean indexInBounds(int[][] x, int i, int j) {
        return i >= 0 && j >= 0 && i < x.length && j < x[i].length;
    }
}"
