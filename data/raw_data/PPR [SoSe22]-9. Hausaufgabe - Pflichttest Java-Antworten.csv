Nachname,Vorname,Antwort 8,Antwort 9
Name_103,VName_103,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		if(denominator<0){
			this.denominator = denominator*-1;
			this.numerator *= -1;
		} else if(denominator==0){
			this.denominator = 1;
		} else {this.denominator = denominator;}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return((double)this.numerator/this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return(this.numerator+""/""+this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator/gcd;
		this.denominator = this.denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       //LCM und Erweiterungsfaktoren ermitteln
	   int lcm = LCM(this.denominator, f.getDenominator());
	   int factorA = lcm/this.denominator;
	   int factorB = lcm/f.getDenominator();
	   
	   //parallel erweitern und addieren
	   int newNumerator = (this.numerator*factorA) + (f.getNumerator()*factorB);
	   int newDenominator = this.denominator * factorA;
	   
	   Fraction result = new Fraction(newNumerator, newDenominator);
	   
	   return result;
	   
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
		Fraction result = new Fraction((this.numerator * f.getNumerator()),this.denominator * f.getDenominator());
		
		return result;
		
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
	   Fraction result;
	   
	   if(this.numerator!=0){
		   result = new Fraction(this.denominator, this.numerator);
		   return result;
	   } else{
		   result = new Fraction(this.numerator, this.denominator);
		   return result;
	   }
	   
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction f_rec = f.reciprocal();
	   Fraction result = f_rec.multiply(this);
	   return result;
    }
    
}"
Name_104,VName_104,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		
		if (this.denominator == 0) this.denominator = 1;
		if (this.denominator < 0){
			this.denominator = -this.denominator;
			this.numerator = -this.numerator;
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double d1 = numerator;
		double d2 = denominator;
		return d1/d2;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		return (numerator+""/""+denominator);
	}

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int faktor = GCD(numerator, denominator);
		denominator = denominator / faktor;
		numerator = numerator / faktor;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		Fraction a= new Fraction(numerator*f.denominator+denominator*f.numerator, denominator*f.denominator);
		return a;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction m = new Fraction(numerator * f.numerator, denominator * f.denominator);
		return m;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction r = new Fraction(numerator, denominator);
		if (r.numerator != 0){
			r.numerator = denominator;
			r.denominator = numerator;
			return r;
		}
		return r;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction d = new Fraction(numerator, denominator);
		d = d.multiply(f.reciprocal());
		return d;
    }
    
}"
Name_106,VName_106,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""(15)3"","""","""","""",""l"",""m"",""r""],[""(15)4"",""1"","""","""","""","""",""""],[""(15)5"","""","""",""0"","""","""",""""],[""(15)6"","""",""0"","""","""",""l"",""""],[""15"","""","""","""",""-"",""-"",""-""],[""16"","""","""","""","""","""",""""],[""(17)3"","""","""","""",""l"",""l"",""r""],[""(17)4"",""0"","""","""","""","""",""""],[""(17)5"","""","""","""","""","""",""""],[""(17)6"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction{

        private int numerator, denominator;

        /**
         * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
         */
        public static int GCD(int x, int y) {
            if (y == 0) return x;
            return GCD(y, x % y);
        }

        /**
         * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
         */
        public static int LCM(int x, int y) {
            return (x * y) / GCD(x, y);
        }
        //Beginn der Aufgabe
        /**
         * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
         * uebergeben bekommt und die entsprechenden Attribute setzt.
         * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
         * auftreten (nicht im ""denominator""-Attribut).
         * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
         * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
         * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
         * und der Wert des Bruchs (die Argumente) unverändert bleibt
         * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
         * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
         * auf Eins gesetzt.
         * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
         */
        public Fraction(int numerator, int denominator) {
            if (denominator<0){
                    this.numerator=-numerator;
                    this.denominator=-denominator;
                }
            else if (denominator==0){
                this.denominator=1;
                this.numerator=numerator;

                }
            else{
                this.numerator=numerator;
                this.denominator=denominator;
            }

            this.shorten();

        }

        /**
         * Gibt den Nenner zurueck.
         */
        public int getDenominator() {
            return this.denominator;
        }

        /**
         * Gibt den Zaehler zurueck.
         */
        public int getNumerator() {
            return this.numerator;
        }

        /**
         * Gibt den Bruch als Gleitkommazahl zurueck.
         */
        public double toDouble() {
            return (double)this.numerator/(double)this.denominator;
        }

        /**
         * Gibt einen String im Format
         * ""Zaehler/Nenner"" zurueck.
         */
        public String toString() {
            String Ausgabe=this.numerator+""/""+denominator;
            return Ausgabe;
        }

        /**
         * Kuerzt (vereinfacht) den Bruch.
         */
         public void shorten() {
            if (this.numerator<0){
                int GCD=GCD(-this.numerator,this.denominator);
                this.numerator=this.numerator/GCD;

                this.denominator=this.denominator/GCD;
            }
            else{
                int GCD=GCD(this.numerator,this.denominator);
                this.numerator=this.numerator/GCD;

                this.denominator=this.denominator/GCD;

            }
        }

        /**
         * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
         */
        public Fraction add(Fraction f) {
            int x=LCM(this.denominator,f.denominator);
            int Zähler=this.numerator*(x/this.denominator)+f.numerator*(x/f.denominator);
            int Nenner=x;
            Fraction Ausgabe=new Fraction(Zähler,Nenner);
            return Ausgabe;

        }

        /**
         * Multipliziert mit dem uebergebenen Bruch.
         */
        public Fraction multiply(Fraction f) {
            int Zähler=this.numerator*f.numerator;
            int Nenner=this.denominator*f.denominator;
            Fraction Ausgabe=new Fraction(Zähler,Nenner);
            return Ausgabe;

        }

        /**
         * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
         * Sonst wird der Bruch unveraendert zurueckgegeben.
         */
        public Fraction reciprocal() {
            int Zähler;
            int Nenner;
            if (this.numerator!=0){
                Zähler=this.denominator;
                 Nenner=this.numerator;
            }
            else{
                 Zähler=this.numerator;
                Nenner=this.denominator;
            }
        Fraction Ausgabe=new Fraction(Zähler,Nenner);
            return Ausgabe;
        }

        /**
         * Dividiert durch den uebergebenen Bruch
         * (unter Verwendung von Kehrwert und Multiplikation).
         */
        public Fraction divide(Fraction f) {
            return this.multiply(f.reciprocal());
        }

    }"
Name_111,VName_111,"[[""3"",""undef"","""",""undef"","""","""",""""],[""4"",""undef"","""","""","""","""",""""],[""5"","""",""undef"","""","""",""undef"",""""],[""6"","""","""","""","""","""",""""],["""","""","""","""","""","""",""undef""],[""11"","""","""","""","""","""",""undef""],[""12"","""","""","""",""undef"","""",""""],[""13"","""","""","""",""undef"","""",""""],[""14"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(denominator==0){
            denominator = 1;
        }

        if(denominator<0){

            this.numerator = numerator*-1;
            this.denominator = denominator*-1;

        }else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {

        this.shorten();
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {

        this.shorten();
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {

        return ((double) this.numerator)/(double)this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {

        return """"+this.numerator+""/""+this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {

        int gdc = GCD(this.numerator, this.denominator);

        if(gdc!=0){

            this.numerator = this.numerator/gdc;
            this.denominator = this.denominator/gdc;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {

        if(this.denominator!=f.getDenominator()){
            this.numerator = this.numerator*(LCM(this.denominator,f.denominator)/this.denominator);
            this.denominator = LCM(this.denominator,f.denominator);
            f.numerator = f.numerator*(LCM(this.denominator,f.denominator)/f.denominator);
            f.denominator = LCM(this.denominator,f.denominator);
        }

        Fraction addition = new Fraction(this.numerator + f.numerator, this.denominator);

        addition.shorten();

        return addition;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

        Fraction multiply = new Fraction(this.numerator*f.getNumerator(), this.denominator*f.getDenominator());

        multiply.shorten();

        return multiply;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {

        if(this.numerator==0){
            return new Fraction(this.numerator, this.denominator);
        }

        if(this.denominator==0){
            Fraction f = new Fraction(this.denominator, this.numerator);
            f.denominator = 0;
            return f;

        }

        return new Fraction(this.denominator, this.numerator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {

        Fraction divide = this.multiply(new Fraction(f.denominator, f.numerator));

        divide.shorten();

        return divide;
    }
}"
Name_110,VName_110,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""",""1"","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""1""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"","""",""-""]]","public class Fraction {

    public int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		
		this.numerator = numerator;
		this.denominator = denominator;
		
		if(denominator < 0) {
		   numerator = -numerator;
		   denominator = -denominator;
		}
	
		if(denominator == 0) {
		   denominator = 1;
		}
        
	    shorten();	

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		
		double fraction = (double)numerator / (double)denominator;
		
        return fraction;
    }

    
    

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
	
	   return numerator + ""/"" + denominator;    
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int x = GCD(numerator, denominator);
        numerator = numerator / x;
        denominator = denominator / x;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
	 


	 
    public Fraction add(Fraction f) {
	
		return new Fraction(f.denominator * numerator + f.numerator * denominator, f.denominator * denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */

	public Fraction multiply(Fraction f) {
		
		return new Fraction(f.numerator * numerator, f.denominator * denominator);  
    }


    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
	 

	public Fraction reciprocal() {
        
		if(numerator == 0) 
			
		return this;
		
        return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
	 

	public Fraction divide(Fraction f) {
		
        return new Fraction(f.denominator * numerator, f.numerator * denominator);
    }

}"
Name_128,VName_128,-,-
Name_131,VName_131,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""",""50"","""",""""],[""12"","""",""0"","""","""",""51"",""""],[""13"","""","""",""1"","""","""",""52""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""",""52"","""",""""],[""5(15)"","""","""",""0"","""","""",""51""],[""6(15)"","""",""0"","""","""",""51"",""""],[""7(15)"",""-"",""-"",""-"","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"",""1"",""0"",""0"","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""",""51"","""",""""],[""5(17)"","""","""",""0"","""","""",""51""],[""6(17)"","""",""1"","""","""",""52"",""""],[""7(17)"",""-"",""-"",""-"","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"",""0"",""1"",""0"","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
	private double bruch;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
 
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	 
    public Fraction(int numerator, int denominator) {
		
		if(denominator<0){
			denominator=0-denominator;
			numerator=0-numerator;
		}
		if(denominator==0){
			denominator=1;	
		}
		this.numerator=numerator;
		this.denominator=denominator;
		shorten();
        
		
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return this.numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double bruch=getNumerator()/(double)getDenominator();
		
        return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		String a=numerator+"""";
		String b=denominator+"""";
		//String toString=numerator+""/""+denominator;
     return  a+""/""+b;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
	   int i=GCD(numerator,denominator);
		numerator=numerator/i;
		denominator=denominator/i; 
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		
    int z1=this.numerator *f.denominator;
	int z2=this.denominator*f.numerator;
	
	int denominator1= this.denominator*f.denominator;
	return new Fraction(z1+z2,denominator1);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int a= this.numerator*f.numerator;
		int b= this.denominator*f.denominator;
     return new Fraction(a,b);   
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal(){
		int m =getNumerator();
		int n =getDenominator();
		
		if(numerator!=0){
			
		m =getNumerator();
		n =getDenominator();	
		return new Fraction(n,m);
		}
	return new Fraction(m,n);
	
	}
  
  
  
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		int h=this.numerator*f.denominator;
		int p=this.denominator*f.numerator;
		
      return new Fraction(h,p); 
    }
    
}"
Name_25,VName_25,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""1"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""",""0"","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe 
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
       
        if(denominator<0){
            this.numerator = -numerator;
            this.denominator = -denominator;
        }
        if(denominator == 0){
            this.denominator = 1;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double fraction = (double)numerator / denominator;
        return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String fraction = numerator + ""/"" + denominator;
        return fraction;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int factorC = GCD(numerator, denominator);
        numerator = numerator/factorC;
        denominator = denominator/factorC;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        return new Fraction(numerator * f.denominator + denominator * f.numerator, denominator * f.denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator * f.numerator, denominator * f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(numerator == 0) return this;

        return new Fraction(denominator,numerator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return multiply(f.reciprocal());
    }
}"
Name_48,VName_48,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""",""0"","""",""""],[""12"","""",""0"","""","""",""0"",""""],[""13"","""","""",""1"","""","""",""1""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""",""1"","""",""""],[""5(15)"","""","""",""0"","""","""",""0""],[""6(15)"","""",""1"","""","""",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""",""0"","""",""""],[""5(17)"","""","""",""1"","""","""",""1""],[""6(17)"","""",""0"","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    public int n = numerator;
	public int d = denominator;
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
        if(denominator == 0){
            this.denominator = 1;
        }
        if(denominator<0){
            this.numerator = -numerator;
            this.denominator = -denominator;
        }
    this.shorten(); 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double fraction = (double) numerator / (double) denominator;
        return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String fraction = numerator + ""/"" + denominator;
        return fraction;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int g = GCD(numerator, denominator);
        denominator = denominator/g;
        numerator = numerator/g;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int n = numerator * f.denominator + f.numerator * denominator;
        int d = denominator * f.denominator;
        Fraction sum = new Fraction(n, d);
        sum.shorten();
        return sum;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int n = numerator * f.numerator;
		int d = denominator * f.denominator;
        return new Fraction(n, d);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(n == 0) {
            return new Fraction(n, d);
        } else {
            return new Fraction(d, n);
        }
    }

   
    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        int n = numerator * f.denominator;
        int d = denominator * f.numerator;
        Fraction quotient = new Fraction(n, d);
        quotient.shorten();
        return quotient;
    }
   
}"
Name_32,VName_32,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""",""0"",""1 "",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"",""0"",""1"",""0"","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""1""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"",""0"",""0"",""1"","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {
  private int numerator, denominator;

  public static int GCD(int x, int y) {
    if(y == 0) return x;
    return GCD(y, x % y);
  }

  public static int LCM(int x, int y) {
    return (x * y) / GCD(x, y);
  }

  public Fraction(int numerator, int denominator) {
    if(denominator == 0) {
      this.numerator = numerator;
      this.denominator = 1;
    }
    else if(denominator < 0) {
      this.numerator = -numerator;
      this.denominator = -denominator;
    }
    else {
      this.numerator = numerator;
      this.denominator = denominator;
    }
    shorten();
  }

  public int getNumerator() {
    return numerator;
  }

  public int getDenominator() {
    return denominator;
  }

  public double toDouble() {
    return ((double) getNumerator()) / ((double) getDenominator());
  }

  public String toString() {
    return String.format(""%d/%d"", getNumerator(), getDenominator());
  }

  public void shorten() {
    int divisor = GCD(getNumerator(), getDenominator());
    if(getNumerator() < 0) {
      divisor = GCD(-getNumerator(), getDenominator());
    }
    numerator /= divisor;
    denominator /= divisor;
  }

  public Fraction add(Fraction f) {
    int x1 = getNumerator(), x2 = f.getNumerator();
    int y1 = getDenominator(), y2 = f.getDenominator();
    return new Fraction(((x1*y2)+(y1*x2)), (y1*y2));
  }

  public Fraction multiply(Fraction f) {
    int x = getNumerator() * f.getNumerator();
    int y = getDenominator() * f.getDenominator();
    return new Fraction(x, y);
  }

  public Fraction reciprocal() {
    int x = getNumerator();
    int y = getDenominator();
    if(getNumerator() != 0) {
      x = getDenominator();
      y = getNumerator();
    }
    return new Fraction(x, y);
  }

  public Fraction divide(Fraction f) {
    return multiply(f.reciprocal());
  }
}"
Name_109,VName_109,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(numerator >= 0 && denominator > 0 || numerator < 0 && denominator > 0) {
          this.numerator = numerator;
          this.denominator = denominator;

        } else if(numerator >= 0 && denominator < 0 || numerator < 0 && denominator < 0) {
          this.numerator = (-1)*numerator;
          this.denominator = (-1)*denominator;
        } else if (denominator == 0) {
          this.numerator = numerator;
          this.denominator = 1;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {

      return this.denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {

      return this.numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {

      return (double)this.numerator/(double)this.denominator;

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {

      return this.numerator + ""/"" + this.denominator;

    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {

      int i = GCD(this.numerator, this.denominator);
      this.numerator /= i;
      this.denominator /= i;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {

      int i = LCM(this.denominator, f.getDenominator());
      Fraction added_frac = new Fraction(i/this.denominator*this.numerator+i/f.denominator*f.numerator, i);
      added_frac.shorten();
      return added_frac;

     }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

      Fraction multiplied_frac = new Fraction(this.numerator*f.numerator, this.denominator*f.denominator);
      multiplied_frac.shorten();
      return multiplied_frac;

    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
     public Fraction reciprocal() {

       int num = this.getNumerator();
       int denom = this.getDenominator();
       Fraction reci_frac;
       if (num != 0) {
         reci_frac = new Fraction(denom, num);
       } else {
         reci_frac = new Fraction(num, denom);
       }
       reci_frac.shorten();
       return reci_frac;

     }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {

      f = f.reciprocal();
      Fraction div_frac = this.multiply(f);
      div_frac.shorten();
      return div_frac;



    }

}"
Name_43,VName_43,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""51""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_113,VName_113,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {
    private int numerator, denominator;
    
    public static int GCD(int x, int y) { // Gibt den größten gemeinsamen Teiler der beiden Argumente zurück.
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) { //Gibt das kleinste gemeinsame Vielfache der beiden Argumente zurück.
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if(numerator > 0 && denominator < 0){
				this.numerator = numerator * (-1);
		}else{
			this.numerator = numerator;
		}
		if(denominator < 0){
			this.denominator = denominator * (-1);
		}else if(denominator == 0){
			this.denominator = 1;
		}else{
			this.denominator = denominator;
		}
		shorten();
    }

    public int getDenominator() { // Gibt den Nenner zurueck
        return denominator;
    }

    public int getNumerator() { //Gibbt den Zaehler zurueck
        return numerator;
    }

    
    public double toDouble() { //gibt den Bruch als Gleitkommazahl zurueck
		double double1 = (double) numerator;
		double double2 = (double) denominator;
		double myDouble = double1/double2;
		return myDouble;
    }
	
    public String toString() { // Gibt einen String im Format ""Zaehler/Nenner"" zurueck.
        String x = (numerator + ""/"" + denominator);
		return x;
    }
   
	
    public void shorten() { // Kuerzt (verneinfacht) den Bruch.
		this.numerator = numerator/GCD(numerator, denominator);
		this.denominator = denominator/GCD(numerator,denominator);
    }

    /*
    public Fraction add(Fraction f) { // Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
       
    }

    public Fraction multiply(Fraction f) { // Multipliziert mit dem uebergebenen Bruch.
        
    }
	 
    public Fraction reciprocal() { // Bildet den Kehrwert, wenn der Zaehler ungleich Null ist. Sonst wird der Bruch unveraendert zurueckgegeben.
       int a = numerator;
	   numerator = denominator;
	   denominator = a;
	   toString();
	   return x;
	   
    }
    
    public Fraction divide(Fraction f) { // Dividiert durch den uebergebenen Bruch (unter Verwendung von Kehrwert und Multiplikation).
       
    }
	*/
    
}"
Name_117,VName_117,-,"public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_114,VName_114,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		if(denominator == 0) {
			this.denominator = 1;
		} else if(denominator < 0) {
			this.numerator *= (-1);
			this.denominator = (-1) * denominator;
		} else {
			this.denominator = denominator;
		}
		this.shorten();
    }

    public int getDenominator() {
        return this.denominator;
    }

    public int getNumerator() {
        return this.numerator;
    }

    public double toDouble() {
        return (double)((double)this.numerator / (double)this.denominator);
    }

    public String toString() {
        return new String(numerator+""/""+denominator);
    }

    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		this.numerator /= Math.abs(gcd);
		this.denominator /= Math.abs(gcd);
    }

    public Fraction add(Fraction f) {
		int denominatorF = f.getDenominator();
		int lcm = LCM(this.denominator, denominatorF);
		int newNumerator = this.numerator * (lcm / this.denominator) + f.getNumerator() * (lcm / denominatorF);
		return new Fraction(newNumerator, lcm);
    }

    public Fraction multiply(Fraction f) {
        return new Fraction((this.numerator * f.getNumerator()), (this.denominator * f.getDenominator()));
    }

    public Fraction reciprocal() {
       if (this.numerator == 0) {
		   return new Fraction(this.numerator, this.denominator);
	   } else {
		   return new Fraction(this.denominator, this.numerator);
	   }
    }
    
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }
}"
Name_127,VName_127,"[[""10"",""-"",""-"",""-"",""-"",""-"",""""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""1""],[""5(15)"","""","""","""","""",""0"",""0""],[""6(15)"","""","""","""",""0"",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {
  private int numerator, denominator;

  public static int GCD(int x, int y) {
    if(y == 0) return x;
    return GCD(y, x % y);
  }

  public static int LCM(int x, int y) {
    return (x * y) / GCD(x, y);
  }

  public Fraction(int numerator, int denominator) {
    if(denominator == 0) {
      this.numerator = numerator;
      this.denominator = 1;
    }
    else if(denominator < 0) {
      this.numerator = -numerator;
      this.denominator = -denominator;
    }
    else {
      this.numerator = numerator;
      this.denominator = denominator;
    }
    shorten();
  }

  public int getNumerator() {
    return numerator;
  }

  public int getDenominator() {
    return denominator;
  }

  public double toDouble() {
    return ((double) getNumerator()) / ((double) getDenominator());
  }

  public String toString() {
    return String.format(""%d/%d"", getNumerator(), getDenominator());
  }

  public void shorten() {
    int divisor = GCD(getNumerator(), getDenominator());
    if(getNumerator() < 0) {
      divisor = GCD(-getNumerator(), getDenominator());
    }
    numerator /= divisor;
    denominator /= divisor;
  }

  public Fraction add(Fraction f) {
    int x1 = getNumerator(), x2 = f.getNumerator();
    int y1 = getDenominator(), y2 = f.getDenominator();
    return new Fraction(((x1*y2)+(y1*x2)), (y1*y2));
  }

  public Fraction multiply(Fraction f) {
    int x = getNumerator() * f.getNumerator();
    int y = getDenominator() * f.getDenominator();
    return new Fraction(x, y);
  }

  public Fraction reciprocal() {
    int x = getNumerator();
    int y = getDenominator();
    if(getNumerator() != 0) {
      x = getDenominator();
      y = getNumerator();
    }
    return new Fraction(x, y);
  }

  public Fraction divide(Fraction f) {
    return multiply(f.reciprocal());
  }
}"
Name_130,VName_130,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"","""",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""",""0"",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {
    private int numerator, denominator;
    
     // Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

     // Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    
 //Beginn der Aufgabe  
    /*
 jeder Bruchch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    	if (denominator>0) {
    		this.denominator=denominator;
    		this.numerator=numerator;
    	}
    	if (denominator==0) {
    		this.denominator=0;
    		this.numerator=numerator;
    	}
    	if (denominator<0) {
    		this.denominator=(-1*denominator);
    		this.numerator=(-1*numerator);
    	}
    	shorten();
    	
    }

    //Holt sich den Nenner
    public int getDenominator() {
        return denominator;
    }

    //Holt sich den Zähler
    public int getNumerator() {
        return numerator;
    }

    //Konvertiert in einen Dezimalbruch
    public double toDouble() {
        return (double)numerator/(double)denominator;
    }
    
    //Erstellt nen String
    public String toString() {
        String a =(numerator+""/""+denominator);
        return a;
    }

    //Kürzt den Bruch
    public void shorten() {
    	int alt = numerator;
    	numerator=numerator/GCD(Math.abs(numerator),Math.abs(denominator));
    	denominator=denominator/GCD(Math.abs(alt),Math.abs(denominator));
    }
    
    //Addiert zwei Brüche
    public Fraction add(Fraction f) {
       Fraction res = new Fraction ((numerator*f.denominator)+(f.numerator*denominator),(denominator*f.denominator)); 
       res.shorten ();
       return res;
    }

    //Multipliziert zwei Brüche
    public Fraction multiply(Fraction f) {
    	Fraction res = new Fraction((numerator*f.numerator),(denominator*f.denominator));
    	res.shorten();
    	return res;
    }

    //Bildet den Kehrwert für Zähler ungleich 0
    public Fraction reciprocal() {
       if (numerator!=0) {
    	  Fraction res = new Fraction (denominator,numerator);
    	  return res;
       }else return this;   
    }
    
    //Dividiert durch den übergeben  Bruch
    public Fraction divide(Fraction f) {
       Fraction divi = f.reciprocal();
       Fraction res = this.multiply(divi);
    	return res;
    } 
}"
Name_139,VName_139,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        	this.numerator = numerator;
        	this.denominator = denominator;
        	if(numerator<0) {
        		this.numerator = -numerator;
        		this.denominator = -denominator;
        		shorten();
        	}
        	if(denominator == 0) {
        		denominator += 1;
        	}
        	else {
        		this.numerator = numerator;
        		this.denominator = denominator;
        		shorten();
        	}
    }
    
    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        	if (denominator == 0){
        		denominator = 1;
        	}
        	return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        	return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(int numerator, int denominator) {
        	numerator = this.numerator;
       	denominator = this.denominator;
        	double fraction = (double)numerator/denominator;
        	return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        	return (numerator+""/""+denominator+""\n"");
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        	int shortFraction = GCD(numerator, denominator);
        	this.numerator = numerator/shortFraction;
        	this.denominator = denominator/shortFraction;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       		int n_numerator = this.numerator;
       		int n_denominator = this.denominator;
       	n_numerator = n_numerator * f.denominator + f.numerator * n_denominator;
        	n_denominator = n_denominator * f.denominator;
        	Fraction n = new Fraction (n_numerator, n_denominator);
       	n.shorten();
       		return n;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    		int n_numerator = this.numerator;
       		int n_denominator = this.denominator;
        	n_numerator = n_numerator * f.numerator;
        	n_denominator = n_denominator * f.denominator;
        	Fraction n = new Fraction (n_numerator, n_denominator);
        	n.shorten();
        	return n;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        	int n_numerator = this.numerator;
       		int n_denominator = this.denominator;
        	if(n_numerator != 0){
           	 	int neuNumerator = n_denominator;
            		int neuDenominator = n_numerator;
            	Fraction r = new Fraction (neuNumerator, neuDenominator);
            	r.shorten();
            		return r;
    		}
    		else {
    			Fraction r = new Fraction (n_numerator, n_denominator);
    			return r;
    		}
    	}
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       		int d_numerator = this.numerator;
       		int d_denominator = this.denominator;
       	d_numerator = d_numerator * f.denominator;
        	d_denominator = d_denominator * f.numerator;
        	Fraction d = new Fraction (d_numerator, d_denominator);
        	d.shorten();
        	return d;
    }
    
}"
Name_122,VName_122,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""",""0"",""0"",""1""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_118,VName_118,"[[""10"",""-"",""-"",""-"","""","""",""""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""1""],[""5(15)"","""","""","""","""",""0"",""0""],[""6(15)"","""","""","""","""",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17"","""","""","""",""0"","""",""0""],[""5(17)"","""","""","""","""",""1"",""1""],[""6(17)"","""","""","""","""",""1"",""""],[""7"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int zNumerator, int zDenominator) {

        if(pDenominator<0){
            numerator = -zNumerator;
            denominator = -zDenominator;
        }
        if(pDenominator == 0){
            denominator = 1;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return denominator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(int numerator, int denominator) {
        double fraction = numerator / denominator;
        return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator + "" = "" + fraction;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int factorC = GCD(numerator, denominator);
        numerator = numerator/factorC;
        denominator = denominator/factorC;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       numerator = numerator * f.denominator + f.numerator * denominator;
        denominator = denominator * f.denominator;
        cancel();
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        numerator = numerator * f.numerator;
        denominator = denominator * f.denominator;
        cancel();
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(denominator<0){
            numerator = -numerator;
            denominator = -denominator;
		}
		if(denominator != 0){
            int newNumerator = numerator;
            int newDenominator = denominator;
            numerator = newDenominator;
            denominator = newNumerator;
			cancel();
		}
		
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        numerator = numerator * f.denominator;
        denominator = denominator * f.numerator;
        cancel();
    }
    

}"
Name_108,VName_108,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"","""",""""],[""4(15)"","""","""","""","""",""51"",""""],[""5(15)"","""","""","""","""","""",""52""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"","""",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"","""",""""],[""4(17)"","""","""","""","""",""51"",""""],[""5(17)"","""","""","""","""","""",""52""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            this.numerator = (numerator * (-1));
            this.denominator = denominator * (-1);
        } else if (denominator == 0) {
            this.numerator = numerator;
            this.denominator = 1;
        } else {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return numerator * 1.0 / denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return(Integer.toString(numerator) + ""/"" + Integer.toString(denominator));
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int numer = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
        int denr = denominator * f.getDenominator();
        return new Fraction(numer, denr);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = numerator * f.numerator;
        int newDenominator = denominator * f.denominator;
        return new Fraction(newNumerator, newDenominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0) {
            int kehr = numerator;
            numerator = denominator;
            denominator = kehr;
            return new Fraction(numerator, kehr);
        } else {
            return new Fraction(numerator, denominator);
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        /*Fraction reciprocal = reciprocal();
        Fraction newNumerator = reciprocal.multiply(f); */
        int newNumerator = numerator * f.getDenominator();
        int newDenominator = denominator * f.numerator;
        return new Fraction(newNumerator, newDenominator);
    }
    /*public static void main(String[] args) {
        Fraction f = new Fraction(2,0);
        System.out.println(f.getNumerator()+""/""+f.getDenominator());
    }*/
}"
Name_134,VName_134,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        

        if(denominator == 0){
            this.numerator = numerator;
            this.denominator = 1;
            
        }
        else if(numerator == 0){
            this.numerator = 0;
            this.denominator = 1;
        }

        else if(denominator < 0){
            this.numerator = -1 * numerator;
            this.denominator = -1 * denominator;
            shorten();
            
        
        }else{
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(int numerator, int denominator) {

        double ausgabe = (double)(numerator/denominator);
        return ausgabe;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return getNumerator() + ""/"" + getDenominator();
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/ggt;
        this.denominator = this.denominator/ggt;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    /*public Fraction add(Fraction f) {
        /*Fraction a = new Fraction(numerator * (LCM(numerator, denominator)), denominator);
        Fraction b = new Fraction(f.numerator * (LCM(f.numerator, f.denominator)), f.denominator);
       return (a + b);*/

       /*Fraction c = new Fraction((f.denominator * numerator)/LCM(numerator, denominator), (denominator * f.numerator)/LCM(f.numerator, f.denominator));
       return c;*/

        //Fraction add = new Fraction(((LCM(thi, getDenominator())) * f.getDenominator() * getNumerator()) + ((LCM(f.getNumerator(), f.getDenominator())) * f.getNumerator() * getDenominator()), (LCM(getNumerator(), getDenominator())) * (LCM(f.getNumerator(), f.getDenominator())));
        //return add;
        //Fraction addi = new Fraction((f.getDenominator() * this.numerator + f.getNumerator() * this.denominator)/(LCM(this.denominator, f.getDenominator() )));
        //return addi;


   // }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction multi = new Fraction(f.getNumerator() * this.numerator, f.getDenominator() * this.denominator);
        return multi;

    }
    
    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    /*public Fraction reciprocal() {
        if(numerator != 0){
           Fraction rec = new Fraction(denominator, numerator);
           return rec;

        }else{
            Fraction norec = new Fraction(numerator, denominator);
            return norec;
        }

       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    /*public Fraction divide(Fraction f) {
        Fraction div = new Fraction(reciprocal.multiply(numerator, denominator));
        return div;
    }*/
}"
Name_107,VName_107,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""17\n17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"",""-"",""-"",""-"",""-"",""-"",""-""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator<1) denominator * (-1);
		if (denominator == 0) denominator = 1;
		this.numerator = numerator;
		this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double Bruch = numerator/denominator;
        return Bruch;
		
		
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		
		String r = numerator/denominator;
		return r;
		
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int x = GCD(denominator, numerator)
		denominator = denominator/x;
		numerator = numerator/x;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		
		
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_133,VName_133,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"","""",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        	if(denominator<=0) {
        		if(denominator==0) denominator=1;
        		if(denominator<0) {
        			denominator *= -1;
        			numerator *= -1;
        		}
        	}
        	 this.numerator = numerator;
             this.denominator = denominator;
             shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/(double)denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (numerator +""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(numerator, denominator);
        numerator /= teiler;
        denominator /= teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    	Fraction b= new Fraction(f.numerator*denominator+numerator*f.denominator, f.denominator*denominator);
    	b.shorten();
    	return b;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    	Fraction b= new Fraction(f.numerator,f.denominator);
    	b.numerator *= numerator;
    	b.denominator *= denominator;
    	b.shorten();
        return b;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	if(numerator != 0) {
    		int newnum = denominator;
    		int newdenom = numerator;
    		Fraction f = new Fraction(newnum, newdenom);
    		return f;
    	}
    	return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	Fraction c= new Fraction(f.numerator,f.denominator);
    	Fraction b= new Fraction(numerator,denominator);
    	b.numerator *= c.denominator;
    	b.denominator *= c.numerator;
    	b.shorten();  	
    	return b;
    }
    
}"
Name_121,VName_121,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""",""1"","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if(denominator <= 0) {
          if (denominator == 0) {
            this.denominator = 1;
          } else {
            this.denominator = -denominator;
            this.numerator = -numerator;
          }
        } else {
          this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
      return (double) this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
      String geteilt = ""/"";
      return this.numerator + geteilt + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
      int ggT = GCD(numerator, denominator);
      this.numerator = numerator/ggT;
      this.denominator = denominator/ggT;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
      int a = LCM(this.denominator, f.denominator);
      int b = a/this.denominator * this.numerator;
      int c = a/f.denominator * f.numerator;
      Fraction added = new Fraction(b + c, a);
      return added;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
      Fraction mul = new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
      shorten();
      return mul;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
      Fraction diese = new Fraction(this.numerator, this.denominator);
      if (this.numerator != 0) {
        Fraction kw = new Fraction(this.denominator, this.numerator);
        return kw;
      }
      return diese;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
      Fraction div = multiply(f.reciprocal());
      return div;
    }

}"
Name_124,VName_124,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
    	this.denominator = denominator;
    	
    	if(this.denominator == 0) {
        	this.denominator = 1;
        }
    	
    	shorten();
    	
    	if(this.denominator < 0) {
        	this.denominator = this.denominator*(-1);
        	this.numerator = this.numerator*(-1);
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = this.numerator +""/""+ this.denominator;
        return str;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/gcd;
        this.denominator = this.denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
       int newDenom = lcm;
       int newNum = (this.numerator*(lcm/this.denominator)) + (f.numerator*(lcm/f.denominator));
       Fraction fadd = new Fraction(newNum, newDenom);
       return fadd;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    	int newNum = this.numerator * f.numerator;
    	int newDenom = this.denominator * f.denominator;
    	Fraction fmul = new Fraction(newNum, newDenom);
        return fmul;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	int newNum = this.numerator;
    	int newDenom = this.denominator;
        if(this.numerator > 0) {
     	   newNum = this.denominator;
     	   newDenom = this.numerator;
        }else if(this.numerator < 0) {
        	newNum = this.denominator*(-1);
      	   newDenom = this.numerator*(-1);
        }
        Fraction rec = new Fraction(newNum, newDenom);
        return rec;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    }
    
}"
Name_46,VName_46,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""0"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""7"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_144,VName_144,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator > 0) {
            this.numerator = numerator;
            this.denominator = denominator;
        } else if (denominator == 0) {
            this.numerator = numerator;
            this.denominator = 1;
        } else if (denominator < 0) {
            this.numerator = -1 * numerator;
            this.denominator = -1 * denominator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator / denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """" + numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = Math.abs(Fraction.GCD(this.getNumerator(), this.getDenominator()));
        this.numerator = (int) (numerator / gcd);
        this.denominator = (int) (denominator / gcd);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = Math.abs(Fraction.LCM(this.getDenominator(), f.getDenominator()));
        int n = this.getNumerator() * (lcm / this.getDenominator()) + f.getNumerator() * (lcm / f.getDenominator());
        return new Fraction(n, lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
       return new Fraction(this.getNumerator() * f.getNumerator(), this.getDenominator() * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.getNumerator() == 0) return new Fraction(this.getNumerator(), this.getDenominator());
       else return new Fraction(this.getDenominator(), this.getNumerator());
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }
    
}"
Name_126,VName_126,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
        if (this.denominator == 0) {
			this.denominator = 1;
		}else if (this.denominator < 0){
			this.numerator=-this.numerator;
			this.denominator = Math.abs(this.denominator);
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double i = ((double) getNumerator())/((double) getDenominator());
		return i;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String ausgabe = (getNumerator()+""/""+getDenominator());
		return ausgabe;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int g = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator/g;
		this.denominator = this.denominator/g;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       	Fraction t = new Fraction (getNumerator(), getDenominator());
		Fraction r = new Fraction (1, 1);
		r.numerator = f.numerator*t.denominator+t.numerator*f.denominator;
		r.denominator = f.denominator*t.denominator;
		r.shorten();
		return r;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction t = new Fraction (getNumerator(), getDenominator());
        t.numerator = t.numerator*f.numerator;
		t.denominator = t.denominator*f.denominator;
		t.shorten();
		return t;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction t = new Fraction (getNumerator(), getDenominator());
		if (numerator != 0){
			int n = t.numerator;
			int d = t.denominator;
		   if (numerator > 0) {
				t.numerator = d;
				t.denominator = n;
		   }else{
				t.numerator = -Math.abs(d);
				t.denominator = Math.abs(n);
		   }
		}
		t.shorten();
	  return t;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction t = new Fraction (getNumerator(), getDenominator());
        t.numerator = t.numerator*f.denominator;
		t.denominator = t.denominator*f.numerator;
		t.shorten();
		return t;
    }
    
}"
Name_62,VName_62,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""50"","""",""""],[""5(15)"","""","""","""","""",""51"",""""],[""6(15)"","""","""","""","""","""",""52""],[""7(15)"",""-"",""-"",""-"",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""50"","""",""""],[""5(17)"","""","""","""","""",""51"",""""],[""6(17)"","""","""","""","""","""",""52""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""1"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) denominator = 1;
        else if (denominator < 0) {
            numerator = -numerator;
            denominator = -denominator;
        }
        
        this.numerator= numerator;
        this.denominator= denominator;
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / (double) this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int greatestCommonDivider = GCD(this.numerator, this.denominator);
        this.numerator /= greatestCommonDivider;
        this.denominator /= greatestCommonDivider;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        // gleichnamiger Nenner durch Multiplikation beider Nenner
        // dann Zähler vervielfachen, damit sie auf den neuen Nenner passen

        int newDenominator = f.denominator * this.denominator;
        int newNumerator = f.numerator * (newDenominator / f.denominator) +
                           this.numerator * (newDenominator / this.denominator);
        return new Fraction(newNumerator, newDenominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0) return new Fraction(this.numerator, this.denominator);
       else return new Fraction(this.denominator, this.numerator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f = f.reciprocal();
        return this.multiply(f);
    }
    
}"
Name_112,VName_112,"[[""1"",""-"",""-"",""-"",""-"",""-"",""-""],[""2"","""","""","""","""","""",""""],[""3"","""","""","""",""undef"",""undef"",""undef""],[""4"",""undef"","""",""undef"","""","""",""""],[""5"","""",""undef"","""","""","""",""""],[""6"","""","""","""","""","""",""""],[""7"","""","""","""","""","""",""""],[""8"","""","""","""","""","""",""""],[""9"","""","""","""","""","""",""""],[""10"","""","""","""","""","""",""""],[""11"","""","""","""",""0"","""",""""],[""12"","""","""","""","""",""0"",""""],[""13"","""","""","""","""","""",""1""],[""14"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe

    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = Math.abs(denominator);
        if (denominator < 0) {
            this.numerator = -this.numerator;
        }
        if (denominator == 0) {
            this.denominator = 1;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double wk = ((double) numerator / (double) denominator);
        return wk;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch = String.valueOf(numerator) + ""/"" + String.valueOf(denominator);
        return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = Math.abs(GCD(numerator, denominator));
        numerator = numerator / gcd;
        denominator = denominator / gcd;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(denominator, f.getDenominator());
        if (denominator == f.getDenominator()) {
            Fraction s = new Fraction(f.getNumerator() + numerator, denominator);
            return s;
        }
        int n = numerator*(lcm/denominator);
        int m = f.getNumerator()*(lcm/f.getDenominator());
        Fraction e = new Fraction(n+m,lcm);
        return e;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction w = new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
        return w;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0) {
            Fraction n = new Fraction(denominator, numerator);
            return n;
        } else {
            return this;
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction u = new Fraction(numerator * f.reciprocal().getNumerator(), this.denominator * f.reciprocal().getDenominator());
        return u;
    }
}"
Name_141,VName_141,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""50"","""","""","""","""",""""],[""12"","""",""51"","""","""","""",""""],[""13"","""","""",""52"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (numerator < 0 && denominator < 0) {
			this.numerator = numerator*(-1);
			this.denominator = denominator*(-1);
		} else if (numerator >= 0 && denominator < 0) {
			this.numerator = numerator*(-1);
			this.denominator = denominator*(-1);
		} else if (denominator == 0) {
			this.numerator = numerator;
			this.denominator = 1;
		} else {
			this.numerator = numerator;
			this.denominator = denominator;
		}	
		shorten();	
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double x = numerator;
		double y = denominator;
        return (x/y);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (numerator+""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int kürzen = GCD(numerator, denominator);
		this.numerator = numerator/kürzen;
		this.denominator = denominator/kürzen;
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int erweitern = LCM(denominator, f.getDenominator());
	   Fraction g = new Fraction(1, 1);
	   g.numerator = (numerator*(erweitern/denominator))+(f.getNumerator()*(erweitern/f.getDenominator()));
	   g.denominator = (erweitern);
	   g.shorten();
	   return g;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction h = new Fraction(1, 1);
        h.numerator = numerator*f.getNumerator();
		h.denominator = denominator*f.getDenominator();
		h.shorten();
		return h;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction i = new Fraction(1, 1);
		if(numerator != 0) {
			int zwischenzaehler = numerator;
			i.numerator = denominator;
			i.denominator = zwischenzaehler;
		} else {
			i.numerator = numerator;
			i.denominator = denominator;
		}
		
       return i;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction q = new Fraction(1, 1);
	   q = f.reciprocal();
	   Fraction j = new Fraction(1, 1);
	   j = multiply(q);
	   j.shorten();
	   return j;
    }
	
}"
Name_119,VName_119,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""",""1"","""","""",""50"",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""50"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""1"","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""",""0"","""","""",""1"",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor, der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * 
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
         if(denominator<0){
            Terminal.println(""Unerlaubte Zahl"");
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_140,VName_140,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""",""0"",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"",""0"",""1"",""0"","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""1""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"",""0"",""0"",""1"","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		if(denominator == 0)
		{
			this.denominator = 1;
		}
		else if(denominator < 0){
			this.numerator = numerator * (-1); 
			this.denominator = denominator * (-1);
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return this.numerator;  
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double e = (double) this.numerator / this.denominator;
		return e;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String zaehler = Integer.toString(this.numerator);
		String nenner = Integer.toString(this.denominator);
		return zaehler+""/""+nenner;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int d = GCD (this.numerator, this.denominator);
		if (d < 0){
			d *= -1;
		}
		this.numerator = numerator / d;
		this.denominator = denominator / d;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int k = LCM (this.denominator, f.getDenominator());
	   int a = k / this.denominator;
	   int b = k / f.getDenominator();
	   Fraction addi = new Fraction((this.numerator * a) + (f.numerator * b), k);
	   return addi;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int n = this.numerator * f.getNumerator();
		int d = this.denominator * f.getDenominator();
		Fraction mult = new Fraction(n, d);
		return mult; 
	}
    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {		
	if (this.numerator != 0){
		int nd = this.numerator; 
		int nn = this.denominator; 
		Fraction k = new Fraction(nn, nd);
		return k;
	}
	Fraction n = new Fraction(this.numerator, this.denominator);
	return n;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction q = this.multiply(f.reciprocal());
		return q;
    }
    
}"
Name_132,VName_132,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0){
            this.numerator = -numerator;
            this.denominator = -denominator;
        } else {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        if (denominator == 0){
            this.denominator = 1;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) ((double)this.numerator / (double)this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
        this.numerator /= gcd;
        this.denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.getDenominator());
       int f_n = f.getNumerator() * (lcm / f.getDenominator());
       int t_n = this.getNumerator() * (lcm / this.getDenominator());
       int d = lcm;
       Fraction fnew = new Fraction((f_n + t_n), d);
       return fnew;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction((f.getNumerator() * this.numerator), (f.getDenominator() * this.denominator));
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0){
        return new Fraction(this.numerator, this.denominator);
       } else {
        return new Fraction(this.denominator, this.numerator);
       } 
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction fre = f.reciprocal();
        Fraction mul = fre.multiply(this);
        return mul;
    }
    
}"
Name_129,VName_129,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""1"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""--"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_105,VName_105,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""Adresse 50"",""Adresse 51"",""Adresse 52""],[""4(15)"",""0"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""Adresse 50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""Adresse 50"",""Adresse 51"",""Adresse 52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""Adresse 50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if (denominator > 0) {
            this.denominator = denominator;
        } else if(denominator == 0) {
            this.denominator = 1;
        } else {
            this.denominator = -denominator;
            this.numerator = -numerator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.getNumerator()/this.getDenominator();
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """" + this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggT = GCD(this.numerator, this.denominator);
        this.numerator /= ggT;
        this.denominator /= ggT;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int kgV = LCM(this.getDenominator(), f.getDenominator());
        int multi_this = kgV/this.getDenominator();
        int multi_f = kgV/f.getDenominator();
        int new_den = this.getDenominator() * multi_this;
        int new_num = this.getNumerator() * multi_this;
        new_num += f.getNumerator() * multi_f;
        Fraction result = new Fraction(new_num, new_den);
        result.shorten();
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.getNumerator() * f.getNumerator(), this.getDenominator() * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.getNumerator() == 0){
            return new Fraction(this.getNumerator(), this.getDenominator());
        }
        return new Fraction(this.getDenominator(), this.getNumerator());
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }

}"
Name_115,VName_115,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0){
            this.numerator = -numerator;
        }
        if(denominator==0){
            denominator = 1;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();


    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double gk = (double) numerator/denominator;
        return gk;

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;


    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd;
        do {
            gcd = GCD(numerator, denominator);
            numerator = numerator / gcd;
            denominator = denominator / gcd;
        }while(gcd > 1);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int den = LCM(f.denominator,denominator);
        int num = (den/f.denominator)*f.numerator+(den/denominator)*numerator;
        return new Fraction(num,den);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction frac = new Fraction (numerator*f.numerator,denominator*f.denominator);
        return frac;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        int num = numerator;
        int den = denominator;
        if(numerator!=0){
            num = denominator;
            den = numerator;
        }
        return new Fraction(num, den);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction frac = new Fraction (f.numerator, f.denominator);
        Fraction recipResult = frac.reciprocal();
        Fraction multipResult = multiply(recipResult);
        return multipResult;
    }

}"
Name_143,VName_143,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator < 0){
            this.denominator = denominator * (-1);
            this.numerator = numerator * (-1);
        }else if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        }else{
            this.denominator = denominator;
            this.numerator = numerator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double a = 0;
        a = ((double)numerator / (double)denominator);
        return a;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String a = """";
        a += numerator + ""/"" + denominator;
        return a;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a = GCD(numerator, denominator);
        this.numerator = numerator / a;
        this.denominator = denominator / a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int a = LCM(denominator, f.getDenominator());
       int b = (a / this.denominator)*(this.numerator);
       int c = (a / f.getDenominator())*(f.getNumerator());
       int d = b + c;
       Fraction result = new Fraction(d , a);
       return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int a = this.numerator * f.getNumerator();
        int b = this.denominator * f.getDenominator();
        Fraction result = new Fraction(a , b);
        result.shorten();
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(this.numerator == 0){
        Fraction result = new Fraction(this.numerator, this.denominator);
        return result;
       }else{
        int a = this.numerator;
        int b = this.denominator;
        Fraction result = new Fraction(b, a);
        return result;
       }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction a = f.reciprocal();
       Fraction b = new Fraction(this.numerator, this.denominator);
       Fraction result = b.multiply(a);
       return result;
    }
    
}"
Name_146,VName_146,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""50(11)"",""0"","""","""","""","""",""""],[""11"","""","""","""","""","""",""""],[""51(12)"","""",""0"","""","""","""",""""],[""12"","""","""","""","""","""",""""],[""52(13)"","""","""",""1"","""","""",""""],[""13"","""","""","""","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		
		if (denominator == 0) {
			this.denominator = 1;
		}
		if (denominator < 0 && numerator < 0) {
			this.denominator = Math.abs(denominator);
			this.numerator = Math.abs(numerator);
		}
		if (this.denominator < 0) {
			this.denominator = Math.abs(denominator);
			this.numerator = (~(Math.abs(numerator) - 1));
		}
		shorten();

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		/*
        this.numerator = this.numerator;
		this.denominator = this.denominator;
		return (double) (this.numerator / this.denominator);
		*/
		
		double a = this.numerator;
		double b = this.denominator;
		double numerator = a;
		double denominator = b;
		return numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String f;
		f = this.numerator + ""/"" + this.denominator;
		return f;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int gcd = GCD(this.numerator, this.denominator);
		int a = this.numerator;
		int b = this.denominator;
		a = a / gcd;
		b = b / gcd;
		this.numerator = a;
		this.denominator = b;	
		/*
		System.out.println(this.numerator);
		System.out.println(this.denominator);
		System.out.println(GCD(this.numerator, this.denominator));
        this.numerator = (int) this.numerator / (int) GCD(this.numerator, this.denominator);
		this.denominator = (int) this.denominator / (int) GCD(this.numerator, this.denominator);
		System.out.println(this.numerator);
		System.out.println(this.denominator);
		*/
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
	   int a;
	   int b;
	   int c;
	   this.numerator = this.numerator * (int) (lcm / this.denominator);
	   f.numerator = f.numerator * (int) (lcm / f.denominator);
	   a = this.numerator;
	   b = f.numerator;
	   c = a + b;
	   Fraction k = new Fraction(c, lcm);
	   return k;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int num = this.numerator * f.numerator;
		int denom = this.denominator * f.denominator;
		Fraction k = new Fraction(num, denom);
		k.shorten();
		return k;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		int num;
		int denom;
		Fraction k;
       if (this.numerator != 0) {
		   denom = this.numerator;
		   num = this.denominator;
		   k = new Fraction(num, denom);
		   return k;
	   } else {
		   k = new Fraction(this.numerator, this.denominator);
		   return k;
	   }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction j;
		j = this.multiply(f.reciprocal());
       return j;
    }
    
}"
Name_120,VName_120,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""2(15)"","""","""","""",""0"",""0"",""1""],[""3(15)"","""","""","""",""1"","""",""""],[""4(15)"","""","""","""","""","""",""0""],[""5(15)"","""","""","""","""",""0"",""""],[""6(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""2(17)"","""","""","""",""1"",""0"",""0""],[""3(17)"","""","""","""",""0"","""",""""],[""4(17)"","""","""","""","""",""0"",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""","""",""""],[""17"",""0"",""0"",""0"",""-"",""-"",""-""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_145,VName_145,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0){
			this.denominator = 0-denominator;
			this.numerator = 0-numerator;
		}
		else if(denominator == 0){
			this.denominator =1;
			this.numerator = numerator;
		}
		else{
			this.denominator = denominator;
			this.numerator = numerator;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        shorten();
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        shorten();
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double a,b;
		a = (double)numerator;
		b = (double)denominator;
        return a/b;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a = GCD(numerator,denominator);
		numerator = numerator/a;
		denominator=denominator/a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction r = new Fraction(0,0);
	   r.numerator = numerator*f.denominator + f.numerator*denominator;
	   r.denominator = denominator * f.denominator;
	   r.shorten();
	   return r;
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction r = new Fraction(0,0);
		r.numerator = numerator*f.numerator;
		r.denominator = denominator * f.denominator;
		r.shorten();
		return r;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       Fraction r=new Fraction(0,0);
	   if(numerator!=0){
		   r.denominator=numerator;
		   r.numerator = denominator;
	   }
	   else{
		   r.denominator=denominator;
		   r.numerator =numerator;
	   }
	   return r;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction r = new Fraction(0,0);
	    r.numerator = numerator*f.denominator;
		r.denominator = denominator * f.numerator;
		r.shorten();
		return r;
    }
    
}"
Name_136,VName_136,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"","""",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"","""",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }

    public Fraction(int numerator, int denominator) {
      if (denominator<0){
        denominator*=(-1);
        numerator*=(-1);
      }
      if (denominator==0){
        this.denominator=1;
        this.numerator=numerator;
      }
      else{
        this.denominator=denominator;
        this.numerator=numerator;
      }
      shorten();

    }

    public int getDenominator() {
      return this.denominator;
    }

    public int getNumerator() {
      return this.numerator;
    }

    public double toDouble() {
      double d=(double)numerator/denominator;
      return d;
    }

    public String toString() {
      String str=(numerator+""/""+denominator);
      return str;

    }

    public void shorten() {
      int gcd =GCD(numerator, denominator);
      numerator /= gcd;
      denominator /= gcd;
    }

    public Fraction add(Fraction f) {
      Fraction summe=new Fraction((numerator*f.getDenominator())+(f.getNumerator()*denominator), denominator*f.getDenominator());
      return summe;
    }

    public Fraction multiply(Fraction f) {
      Fraction produkt=new Fraction(f.getNumerator()*numerator, f.getDenominator()*denominator);
      return produkt;
    }


    public Fraction reciprocal() {
      if (numerator==0){
        Fraction gehtnicht=new Fraction(numerator, denominator);
        return gehtnicht;
      }
      else{
        Fraction rezip=new Fraction(denominator, numerator);
        return rezip;
      }
    }

    public Fraction divide(Fraction f) {
      Fraction div=new Fraction(numerator*f.getDenominator(), denominator*f.getNumerator());
      return div;
    }

}"
Name_147,VName_147,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""0"","""",""""],[""5(15)"","""","""","""","""",""0"",""""],[""6(15)"","""","""","""","""","""",""1""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""1"","""",""""],[""5(17)"","""","""","""","""",""0"",""""],[""6(17)"","""","""","""","""","""",""0""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if(denominator < 0) {
            this.denominator = -denominator;
            this.numerator = -numerator;
        } else if(denominator == 0) {
            this.denominator = 1;
        } else {
            this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() { 
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator; 
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        return new Fraction((numerator*(LCM(denominator, f.denominator)/denominator)+f.numerator*(LCM(denominator, f.denominator)/f.denominator)), LCM(denominator, f.denominator));
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.numerator, denominator*f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(numerator != 0) {
            int x = numerator;
            numerator = denominator;
            denominator = x;
            return new Fraction(numerator, denominator);
        } else {
            return new Fraction(numerator, denominator);
        } 
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return new Fraction(numerator*f.denominator, denominator*f.numerator);
    } 
}"
Name_142,VName_142,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        System.out.println(""+numerator+""+""/""+""+denominator+"");
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator(int numerator, int denominator) {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator(int numerator, int denominator) {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble(int numerator, int denominator) {
        return float n = numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString(int numerator, int denominator) {
        System.out.println(""+numerator+""+""/""+""+denominator+"");
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten(int numerator, int denominator) {
        return (""+numerator+""+""/""+""+denominator+"")
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}"
Name_125,VName_125,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""",""0"","""",""0"",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if (denominator == 0) {
            throw new IllegalArgumentException(""The denominator is zero."");
        }
        if(numerator==0){
            this.numerator = 0;
            this.denominator = 1;
        }
        else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
        if(denominator<0){
            this.numerator = -1*this.numerator;
            this.denominator = -1*this.denominator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return this.numerator / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        if(denominator!=1)
            return numerator+""/""+denominator;
        else
            return numerator+"""";
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator,denominator);
        numerator = numerator/gcd;
        denominator = denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        return new Fraction(f.numerator*this.denominator+this.numerator*f.denominator,f.denominator*this.denominator);
}

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(f.numerator*this.numerator,f.denominator*this.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(this.numerator != 0){
            
            return new Fraction(getDenominator(),getNumerator())
        }
        return this;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return new Fraction(f.numerator*this.denominator,f.denominator*this.numerator);
    }
}"
