Nachname,Vorname,E-Mail-Adresse,Status,"Begonnen am",Beendet,"Verbrauchte Zeit","Bewertung/20,00","Antwort 1","Antwort 2","Antwort 3","Antwort 4","Antwort 5","Antwort 6","Antwort 7","Antwort 8","Antwort 9"
Wolf,"Amelie Rose",amelie.r.wolf@campus.tu-berlin.de,Beendet,"17. Dezember 2021  10:52","4. Januar 2022  10:59","18 Tage","18,75","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""",""0"","""","""","""",""""],[""6(15)"","""","""","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""",""0"","""","""","""",""""],[""6(17)"","""","""","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor, der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also mathematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0){
            denominator=-denominator;
            numerator=-numerator;
        }
        if(denominator==0){
            denominator=1;
        }
        this.denominator=denominator;
        this.numerator=numerator;
        this.shorten();
        //System.out.println(this.numerator+""/""+this.denominator);
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/(double)this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String n=numerator+"""";
        String d=denominator+"""";
        return(n+""/""+d);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggT=GCD(this.denominator,this.numerator);
        int denominator=this.denominator/ggT;
        int numerator=this.numerator/ggT;
        this.denominator=denominator;
        this.numerator=numerator;
        //System.out.println(ggT+"" ""+this.numerator+"" ""+this.denominator);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int kgV=LCM(this.denominator,f.denominator);
        Fraction plus=new Fraction(this.numerator*(kgV/this.denominator)+f.numerator*(kgV/f.denominator),kgV);
        return plus;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction multi=new Fraction(this.numerator*f.numerator,this.denominator*f.denominator);
        return multi;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator!=0){
            Fraction kehr=new Fraction(this.denominator,this.numerator);
            return kehr;
        }
        else{
            //Fraction kehr=new Fraction(this.numerator,this.denominator);
            return this;
        }        
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction kehr=f.reciprocal();
        Fraction multi=this.multiply(kehr);
        Fraction durch=new Fraction(multi.numerator,multi.denominator);
        return durch;
    }

}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest{
  public static void main(String[] args){
    Subway a=new Subway(3);
    Wagen x=new Wagen(4,10);
    Wagen y=new Wagen(1,5);
    a.addWagen(x);
    a.addWagen(y);
    System.out.println(a.getSeats());
    System.out.println(a.getStandingRoom());
    System.out.println(a.getCapacity());
    a.addWagen(y);
    a.addWagen(y);
    a.removeWagen();
    a.removeWagen();
    a.removeWagen();
    a.removeWagen();
    a.removeWagen();
  }
}"
Bender,Emma,emma.bender@campus.tu-berlin.de,Beendet,"17. Dezember 2021  14:25","8. Januar 2022  11:03","21 Tage 20 Stunden","19,75","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""o"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator= numerator;
		this.denominator= denominator;
		if (denominator==0){
			this.denominator=1;
		}
		this.shorten();
		if (this.denominator<0) {
			this.numerator=-this.numerator;
			this.denominator=-this.denominator;
		}

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         return (double)numerator/(double)denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (numerator+""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd= GCD(numerator, denominator);
		numerator/=gcd;
		denominator/=gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int lcm=LCM(denominator, f.denominator);
		Fraction c= new Fraction(((lcm/denominator)*numerator)+((lcm/f.denominator)*f.numerator),lcm);
	   return c;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction c= new Fraction(this.numerator*f.numerator,this.denominator*f.denominator);
		return c;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator!=0){
		   Fraction c= new Fraction(this.denominator,this.numerator);
		   return c;
	   }else{
		   return this;
	   }
	   
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction e= new Fraction(this.multiply(f.reciprocal()).numerator, this.multiply(f.reciprocal()).denominator);
	   return e;
    }
    
}","public class SubwayTest {
	public static void main(String[] args){
		Subway sub= new Subway(3);
		Wagen w1= new Wagen(23, 31);
		Wagen w2= new Wagen(43, 12);
		sub.addWagen(w1);
		sub.addWagen(w2);
		System.out.println(sub.getSeats());
		System.out.println(sub.getStandingRoom());
		System.out.println(sub.getCapacity());
		sub.addWagen(w1);
		sub.addWagen(w1);
		sub.removeWagen();
		sub.removeWagen();
		sub.removeWagen();
		sub.removeWagen();
		sub.removeWagen();
	}
}"
Nguyen,"Hoang Le",h.nguyen.3@campus.tu-berlin.de,Beendet,"17. Dezember 2021  17:20","9. Januar 2022  21:53","23 Tage 4 Stunden","16,67","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter und Setter","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","void
; private
; class","[[""10"",""undef\n"",""undef"",""undef"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""links"",""mitte"",""rechts""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""",""1"","""","""",""links"",""""],[""7(15)"",""-"",""-"",""-"",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""1"","""","""",""""],[""6(17)"","""",""0"","""","""",""links"",""""],[""7(17)"",""-"",""-"",""-"",""-"",""-"",""-""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator < 0){
			this.denominator = denominator*(-1);
			this.numerator = numerator*(-1);
		}
		else if(denominator == 0){
			this.numerator 		= numerator;
			this.denominator 	= 1;
		}
		else{
		this.numerator 		= numerator;
		this.denominator 	= denominator;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double fraction = ((double) numerator)/((double) denominator);
		return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String fraction = this.numerator +""/""+ this.denominator;
		return fraction;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int kuerzen = Fraction.GCD(numerator, denominator);
		this.numerator /= kuerzen;
		this.denominator /= kuerzen;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int newdenom 	= LCM(denominator, f.denominator);
		int newnum		= (newdenom/denominator)*numerator + (newdenom/f.denominator)*f.numerator;
		return new Fraction(newnum, newdenom);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newnum = numerator * f.numerator;
		int newden = denominator * f.denominator;
		return new Fraction(newnum, newden);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(numerator != 0){
		   int newnum = denominator;
		   int newden = numerator;
		   return new Fraction(newnum, newden);
		}
	   else{
		   return new Fraction(numerator, denominator);
		}
	}
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       int newnum = this.numerator * f.denominator;
	   int newden = this.denominator * f.numerator;	
	   return new Fraction(newnum, newden);
    }
}","public class SubwayTest {
    public static void main(String[] args){
        // Erzeugen Sie eine U-Bahn mit maximal 3 Wagen.
        Subway ubahn = new Subway(3);

        // Hängen Sie 2 Wagen mit unterschiedlicher Anzahl an Sitz- und Stehplätzen an die U-Bahn.
        ubahn.addWagen(new Wagen(10,20));
        ubahn.addWagen(new Wagen(30,40));

        // Geben Sie die Gesamtzahl der Sitzplätze, Stehplätze und aller Plätze aus.
        System.out.printf(""Gesamtanzahl Sitzplätze: %d\n"",ubahn.getStandingRoom());
        System.out.printf(""Gesamtanzahl Stehplätze: %d\n"",ubahn.getSeats());
        System.out.printf(""Gesamtanzahl Plätze: %d\n"",ubahn.getCapacity());

        //    Hängen Sie 2 weitere Wagen an die U-Bahn.
        ubahn.addWagen(new Wagen(10,20));
        ubahn.addWagen(new Wagen(30,40));

        // Entfernen Sie 5 Wagen aus der U-Bahn.
        for(int i = 0; i<5; i++){
            ubahn.removeWagen();
            //Terminal.println(i);
        }

    }
}"
Schulz,Justin,justin.schulz@campus.tu-berlin.de,Beendet,"18. Dezember 2021  21:03","6. Januar 2022  20:33","18 Tage 23 Stunden","10,08","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","void
; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","[[""10"",""-"",""-"",""-"",""undef"",""undef"",""undef""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""","""",""0""],[""6(17)"","""","""","""","""",""0"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""18"",""0"",""0"",""0"","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
		if(denominator < 0){
			numerator *= -1;
			denominator *= -1;
		}
		
		if(denominator == 0){
			denominator = 1;
		}
		
		this.numerator = numerator;
		this.denominator = denominator;
		
		this.shorten();
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String x = numerator+""/""+denominator;
		return x;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int s = GCD(numerator, denominator);
		if(s != 0){ 
        denominator /= s;
		numerator /= s;
		}
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		 
		 int a = LCM(this.denominator, f.denominator);
		if(this.denominator != f.denominator){
        this.numerator *= f.denominator;
        f.numerator *= this.denominator;
        this.numerator += f.numerator;
		
        this.denominator = f.denominator = a;
		}else this.numerator += f.numerator;
        return this;
	   
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator *= f.numerator;
		this.denominator *= f.denominator;
		return this;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction bruch = new Fraction(this.numerator, this.denominator);
       if(bruch.numerator != 0){
		   int hilfe = bruch.numerator;
		   bruch.numerator = bruch.denominator;
		   bruch.denominator = hilfe;
		}return bruch;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }
    
}",-
Song,Minji,minji.song@campus.tu-berlin.de,Beendet,"19. Dezember 2021  08:41","9. Januar 2022  23:20","21 Tage 14 Stunden","16,48","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","static
; void","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3 (15)"","""","""","""",""l"",""m"",""r""],[""4"",""1"","""","""","""","""",""""],[""5"","""","""",""0"","""","""",""""],[""6"","""",""1"","""","""",""l"",""""],[""16 (7)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(denominator > 0)
        {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        else if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        }
        else{
            this.numerator = 0 - numerator;
            this.denominator = denominator;

            this.numerator *= -1;
            numerator *= -1;
        } 
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double x = 0.000;
        x = (double)numerator/(double)denominator;
        return x;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String x = Integer.toString(numerator) +""/""+ Integer.toString(denominator);
        return x;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int x = GCD(numerator, denominator);
        numerator = numerator / x;
        denominator = denominator /x;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        
        shorten();

        int x = denominator * f.denominator;

        int y = numerator * f.denominator + f.numerator * denominator;
        Fraction n = new Fraction(y, x);
        n.shorten();

        return n;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

        
        int x = f.numerator * numerator;
        int y = f.denominator * denominator;
        Fraction xy = new Fraction(x, y);
        xy.shorten();

        return xy;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(numerator!=0)
       {
            int nk = denominator;
            int dk = numerator;

            Fraction x = new Fraction(nk, dk);
            x.shorten();

            numerator = x.numerator;
            denominator = x.denominator;

            return x;
       }
       else
       {
           return new Fraction(numerator, denominator);
       }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        int x = numerator * f.denominator;
        int y = denominator * f.numerator;
        Fraction xy = new Fraction(x, y);
        xy.shorten();

        return xy;
    }
    
}","public class SubwayTest{
    public static void main(String[] args){
        Subway ubahn = new Subway(3);

        Wagen wagen1 = new Wagen(40, 30);
        Wagen wagen2 = new Wagen(56, 54);

        ubahn.addWagen(wagen1);
        ubahn.addWagen(wagen2);

        System.out.println(ubahn.getCapacity());
        System.out.println(ubahn.getSeats());
        System.out.println(ubahn.getStandingRoom());

        Wagen wagen3 = new Wagen(54, 34);
        Wagen wagen4 = new Wagen(44, 36);

        ubahn.addWagen(wagen3);
        ubahn.addWagen(wagen4);

        for(int i = 0; i < 5; i++){
            ubahn.removeWagen();
        }

    }
}"
Rode,Eric,eric.rode@campus.tu-berlin.de,Beendet,"19. Dezember 2021  19:46","6. Januar 2022  14:55","17 Tage 19 Stunden","16,30","void
; static
; private","Getter und Setter","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Verhindern, dass Attributswerte gesetzt werden

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","class Rechteck {
    private int breite;

    void setBreite(int breite) {
        this.breite = breite;
    }

    int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
    public static void main(String[] args)  {

        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
    }
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden können überladen werden","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""links"",""""],[""15"","""","""","""",""undef"",""undef"",""undef""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""links"",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    if (denominator < 0) {
        this.denominator = Math.abs(denominator);
        this.numerator = 0 - numerator;
    } else if (denominator == 0) {
        this.denominator = 1;
        this.numerator = numerator;
    } else {
        this.denominator = denominator;
        this.numerator = numerator;
    }
    this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        if (this.denominator < 0){
            this.numerator = -this.numerator;
            this.denominator = Math.abs(this.denominator);
        }
        int gcd = GCD(this.denominator, Math.abs(this.numerator));
        this.numerator = this.numerator / gcd;
        this.denominator = this.denominator / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(this.denominator, f.denominator);
        if (this.denominator != lcm) {
            this.numerator = this.numerator * lcm / this.denominator;
            this.denominator = lcm;
        }
        if (f.denominator != lcm) {
            f.numerator = f.numerator * lcm / f.denominator;
            f.denominator = lcm;
        }
        this.numerator = this.numerator + f.numerator;
        this.shorten();
        f.shorten();
        return this;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator = this.numerator * f.numerator;
        this.denominator = this.denominator * f.denominator;
        this.shorten();
        return this;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator != 0){
            int hilfsNumerator = this.numerator;
            this.numerator = this.denominator;
            this.denominator = hilfsNumerator;
        }
        this.shorten();
        return this;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }

}","public class SubwayTest {
    public static void main(String[] args) {
        Subway u2 = new Subway(3);
        Wagen wagen1 = new Wagen(50, 20);
        Wagen wagen2 = new Wagen(30, 44);
        u2.addWagen(wagen1);
        u2.addWagen(wagen2);
        System.out.println(u2.countWagen() + "" Wagen\n""
                + u2.getSeats() + "" Seats\n""
                + u2.getStandingRoom() + "" Standing Room\n""
                + u2.getCapacity() + "" Capacity"");
        u2.addWagen(new Wagen(75, 45));
        u2.addWagen(new Wagen(15, 22));
        for (int i = 0; i < 5; i++) {
            u2.removeWagen();
        }
        System.out.println(u2.countWagen() + "" Wagen\n""
                + u2.getSeats() + "" Seats\n""
                + u2.getStandingRoom() + "" Standing Room\n""
                + u2.getCapacity() + "" Capacity"");
    }
}"
Hobein,"Bashira Noura",b.hobein@campus.tu-berlin.de,Beendet,"19. Dezember 2021  23:26","9. Januar 2022  23:57","21 Tage","18,17","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","void
; static","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen",-,"Getter und Setter","[[""10 "",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""",""0"","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""",""0"","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
   
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }
    
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    public Fraction(int numerator, int denominator) {

        if(denominator > 0)
        {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        else if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        }
        else{
            this.numerator = 0 - numerator;
            this.denominator = denominator;

            this.numerator *= -1;
            numerator *= -1;
        } 
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }
    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        double x = 0.000;
        x = (double)numerator/(double)denominator;
        return x;
    }

    public String toString() {
        String x = Integer.toString(numerator) +""/""+ Integer.toString(denominator);
        return x;
    }
    
    public void shorten() {
        int x = GCD(numerator, denominator);
        numerator = numerator / x;
        denominator = denominator /x;
    }

    public Fraction add(Fraction f) {
        
        shorten();

        int a = denominator * f.denominator;

        int b = numerator * f.denominator + f.numerator * denominator;
        Fraction n = new Fraction(b, a);
        n.shorten();

        return n;
    }

    public Fraction multiply(Fraction f) {

        
        int a = f.numerator * numerator;
        int b = f.denominator * denominator;
        Fraction ab = new Fraction(a, b);
        ab.shorten();

        return ab;
        
    }
    public Fraction reciprocal() {
       if(numerator!=0) {
      
       
            int nk = denominator;
            int dk = numerator;

            Fraction a = new Fraction(nk, dk);
            a.shorten();

            numerator = a.numerator;
            denominator = a.denominator;

       return a;
       }
       else
       {
           return new Fraction(numerator, denominator);
       }
    }
    public Fraction divide(Fraction f) {
        int a = numerator * f.denominator;
        int b = denominator * f.numerator;
        Fraction ab = new Fraction(a, b);
		ab.shorten();

        return ab;
    }
    
}","//Hier soll die Klasse SubwayTest stehen!
     public class SubwayTest {
	 public static void main(String[] args)
	    {
	        
	        Subway ubahn = new Subway(3);
	       
	        Wagen wagen1 = new Wagen(27, 35); 
	        Wagen wagen2 = new Wagen(32, 40); 

	        ubahn.addWagen(wagen1);
	        ubahn.addWagen(wagen2);

	        
	        System.out.println(ubahn.getCapacity());
System.out.println(ubahn.getSeats());
System.out.println(ubahn.getStandingRoom());

	       
	        Wagen wagen3 = new Wagen(48, 55);
	        Wagen wagen4 = new Wagen(58, 62);

	        ubahn.addWagen(wagen3);
	        ubahn.addWagen(wagen4);

	        for(int i = 0; i < 5; i++)
	        {
	            ubahn.removeWagen();
	        }

	    }
	}"
Streese,"Lennart Soeren",l.streese@campus.tu-berlin.de,Beendet,"19. Dezember 2021  23:58","9. Januar 2022  23:02","20 Tage 23 Stunden","10,58","private
; static
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""",""0"",""0"",""1""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""",""0"","""","""","""",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""",""1"",""0"",""0""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""",""1"","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""",""0"",""1"",""0""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

	private int numerator, denominator;

	/**
	 * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
	 */
	public static int GCD(int x, int y) {
		if (y == 0) return x;
		return GCD(y, x % y);
	}

	/**
	 * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
	 */
	public static int LCM(int x, int y) {
		return (x * y) / GCD(x, y);
	}
	//Beginn der Aufgabe  
	/**
	 * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
	 * uebergeben bekommt und die entsprechenden Attribute setzt. 
	 * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
	 * auftreten (nicht im ""denominator""-Attribut).
	 * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
	 * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
	 * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
	 * und der Wert des Bruchs (die Argumente) unverändert bleibt 
	 * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
	 * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
	 * auf Eins gesetzt.
	 * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
	 */
	public Fraction(int numerator, int denominator) {
		this.numerator = numerator; 

		if(denominator == 0) {
			this.denominator = 1;
			this.numerator = numerator;
		}
		else if (denominator < 0) {
			this.denominator =  (int) Math.sqrt(Math.pow(denominator, 2));
			this.numerator= numerator * -1; 
		}
		else { 
			this.denominator = denominator; 
			this.numerator = numerator;
		}
		shorten(); 
	}

	/**
	 * Gibt den Nenner zurueck.
	 */
	public int getDenominator() {
		return denominator;
	}

	/**
	 * Gibt den Zaehler zurueck.
	 */
	public int getNumerator() {
		return numerator;
	}

	/**
	 * Gibt den Bruch als Gleitkommazahl zurueck.
	 */
	public double toDouble() {
		double i = ((double) numerator) / denominator;
		return i; 
	}

	/**
	 * Gibt einen String im Format
	 * ""Zaehler/Nenner"" zurueck.
	 */
	public String toString() {
		String i = Integer.toString(numerator);
		String j = Integer.toString(denominator);
		return i+ ""/"" +j;
	}

	/**
	 * Kuerzt (vereinfacht) den Bruch.
	 */
	public void shorten() {
		int i = GCD(numerator,denominator);
		numerator = numerator/i;
		denominator = denominator/i; 
	}

	/**
	 * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
	 */
	public Fraction add(Fraction f) {
		int fNumerator = f.getNumerator() * denominator;
		denominator = denominator * f.getDenominator(); 
		numerator = numerator * f.getDenominator(); 

		numerator = numerator + fNumerator;
		shorten(); 
		return this; 

	}

	/**
	 * Multipliziert mit dem uebergebenen Bruch.
	 */
	public Fraction multiply(Fraction f) {
		numerator = numerator * f.getNumerator();
		denominator = denominator * f.getDenominator(); 
		shorten(); 
		return this; 
	}

	/**
	 * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
	 * Sonst wird der Bruch unveraendert zurueckgegeben.
	 */
	public Fraction reciprocal() {
		if (numerator != 0) {
			int n = numerator; 
			numerator = denominator;
			denominator = n; 
			shorten();
			return this;
		}
			else {
				return this;
			}
		}



		/**
		 * Dividiert durch den uebergebenen Bruch 
		 * (unter Verwendung von Kehrwert und Multiplikation).
		 */
		public Fraction divide(Fraction f) {
			numerator = numerator * f.getDenominator();
			denominator = denominator * f.getNumerator();
			shorten();
			return this;
		}
	}",-
Engelbrecht,Philip,philip.engelbrecht@campus.tu-berlin.de,Beendet,"20. Dezember 2021  03:00","9. Januar 2022  23:59","20 Tage 20 Stunden","17,67","Setter-Methoden haben in der Regel den Rückgabetyp void","class
; void
; static
; private","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","[[""10"","""","""","""","""","""",""""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""",""0"","""","""","""",""""],[""6(15)"","""","""",""0"","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""",""0"","""","""","""",""""],[""6(17)"","""","""",""1"","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if (denominator <0) {
			this.numerator = numerator * -1;
			this.denominator = denominator *-1;
		} else if (denominator == 0){
			this.numerator = numerator;
			this.denominator = 1;			
		} else {
			this.numerator = numerator;
			this.denominator = denominator;
		}
		this.shorten();

    }		

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double Gleitkommazahl = (double)getNumerator() / (double)getDenominator();
		return Gleitkommazahl;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		String s = getNumerator() + ""/"" + getDenominator();
		return s;
		}

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int ggT = GCD (getDenominator(),getNumerator());
		if (ggT<0) {
			ggT*=-1;
		}
        this.numerator = this.numerator /ggT;
		this.denominator =this.denominator / ggT;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int kgV = LCM(this.getDenominator(),f.getDenominator());
		int Hilfe =  kgV / this.getDenominator();
		int fHilfe = kgV / f.getDenominator();
		int Zaehler = this.getNumerator() *Hilfe + f.getNumerator() * fHilfe;
		return new Fraction(Zaehler,this.getDenominator() * (Hilfe));
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.getNumerator()*f.getNumerator(),this.getDenominator()*f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if (this.getNumerator() != 0) {
		   return new Fraction(getDenominator(),getNumerator());		   
		} else {
		   return new Fraction(getNumerator(),getDenominator());
		}
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction R = f.reciprocal();
		return new Fraction(this.getNumerator()*R.getNumerator(), this.getDenominator()*R.getDenominator());
    }
    
}","public class SubwayTest {
		
	
	public static void main (String[]args) {
		Wagen f = new Wagen (10,15);
		Wagen l = new Wagen (12,16);
		Wagen r = new Wagen (14,17);
		Wagen u = new Wagen (16,18);
		
		
		
		Subway UBahn = new Subway(3); 
		
		
		UBahn.addWagen(f);		
		
		UBahn.addWagen(l);
		System.out.println(UBahn.getSeats() +"", ""+ UBahn.getStandingRoom() +"", ""+ UBahn.getCapacity());
		UBahn.addWagen(r);
		UBahn.addWagen(u);
		UBahn.removeWagen();
		UBahn.removeWagen();
		UBahn.removeWagen();
		UBahn.removeWagen();
		UBahn.removeWagen();

	}
	
}"
Alder,Tim,tim.alder@campus.tu-berlin.de,Beendet,"20. Dezember 2021  12:12","9. Januar 2022  16:39","20 Tage 4 Stunden","19,83","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","void
; private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if(denominator==0){
            this.denominator = 1;
    }else{
        this.denominator = denominator;
    }
    shorten();

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return(this.numerator+""/""+this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int comfact = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/comfact;
        this.denominator = this.denominator/comfact;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lowComDenom= LCM(this.denominator, f.denominator);
        int firstFact = lowComDenom / this.denominator;
        int secondFact = lowComDenom / f.denominator;
        
        int firstNum = this.numerator * firstFact;
        int secondNum = f.numerator * secondFact;
        int sumNumerator = firstNum + secondNum;
        
       return new Fraction(sumNumerator, lowComDenom);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction((this.numerator*f.numerator), (this.denominator*f.denominator));
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(this.numerator==0){
        return new Fraction(this.numerator, this.denominator);
       } else {
        return new Fraction(this.denominator, this.numerator);
       }

    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction a = f.reciprocal();
        Fraction b=multiply(a);

       return new Fraction(b.numerator, b.denominator);
    }
    
}","public class SubwayTest{

    public static void main(String[] args) {
        Subway erste = new Subway(3);
        
        erste.addWagen(new Wagen(5, 8));
        erste.addWagen(new Wagen(6, 9));
       
        System.out.println(erste.getSeats());
        System.out.println(erste.getStandingRoom());
        erste.addWagen(new Wagen(3, 3));

        System.out.println(erste.getSeats());
        System.out.println(erste.getStandingRoom());
        System.out.println(erste.getCapacity());
        erste.addWagen(new Wagen(12, 10));
        erste.addWagen(new Wagen(2, 2));
        for (int i=0; i<5; i++){
        erste.removeWagen();
        }
        

    }

}"
Abele,Sophie,s.abele@campus.tu-berlin.de,Beendet,"20. Dezember 2021  18:29","9. Januar 2022  23:59","20 Tage 5 Stunden","5,33","class Rechteck { 
    int breite;
    
    void setBreite(int breite) {
        this.breite = breite;
    }
    
    int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","static
; void
; private","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-\n\n-"",""-""],[""17"","""","""","""","""",""\n"",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
Erlemann,Tom-Julien,tom-julien.erlemann@campus.tu-berlin.de,Beendet,"21. Dezember 2021  11:46","9. Januar 2022  23:34","19 Tage 11 Stunden","9,58","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void
; private
; static","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","[[""11"",""-"",""-"",""-"",""-"",""-"",""-""],[""50(11)"",""0"","""","""","""","""",""""],[""12(50)"","""","""","""","""","""",""""],[""51(12)"","""",""0"","""","""","""",""""],[""13(51)"","""","""","""","""","""",""""],[""52(13)"","""","""",""1"","""","""",""""],[""14(53)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5"","""","""","""","""","""",""""],[""6"","""","""","""","""","""",""""],[""7"","""","""","""","""","""",""""],[""16(7)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5"","""","""","""","""","""",""""],[""6"","""","""","""","""","""",""""],[""7"","""","""","""","""","""",""""],[""18(7)"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(denominator<0){
            this.numerator=-numerator;
            this.denominator=-denominator;
        }
        else if(denominator == 0){
            this.numerator=numerator;
            this.denominator=1;
        }
        else {
            this.denominator=denominator;
            this.numerator=numerator;
            this.shorten();
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double bruch=(double) numerator/denominator;
        return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator,denominator);
        numerator = numerator/gcd;
        denominator = denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm=LCM(denominator,f.denominator);
        return new Fraction((lcm/denominator*numerator)+(lcm/f.denominator*f.numerator),lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.numerator,denominator*f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if(numerator!=0){
            return new Fraction(denominator,numerator);
        }
        else{
            return new Fraction(numerator,denominator);
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return new Fraction(numerator*f.denominator,denominator*f.numerator);
    }

}","public class SubwayTest {
    public static void main(String[] args) {
        Subway u1=new Subway(3);
        Wagen one=new Wagen(4,12);
        Wagen two=new Wagen(6,18);
        u1.addWagen(one);
        u1.addWagen(two);
        System.out.println(u1.getSeats());
        System.out.println(u1.getStandingRoom());
        System.out.println(u1.getCapacity());
        Wagen three=new Wagen(1,1);
        Wagen four=new Wagen(2,2);
        u1.addWagen(three);
        u1.addWagen(four);
        u1.removeWagen(one);
        u1.removeWagen(two);
        u1.removeWagen(three);
        u1.removeWagen(four);
        u1.removeWagen(one);

    }
}"
Panchanathan,Arrsana,a.panchanathan@campus.tu-berlin.de,Beendet,"21. Dezember 2021  12:42","9. Januar 2022  23:59","19 Tage 11 Stunden","4,67","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","void
; static
; private","Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""""],[""11"",""0"","""","""",""50"","""",""""],[""12"","""",""0"","""","""",""51"",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""",""-"",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0) {
			this.numerator = -numerator;
			this.denominator = -denominator;
		}
		if(denominator == 0) {
			denominator = 1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double fraction = (double)numerator/denominator;
		return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
		return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int factorshorten = GCD(numerator, denominator);
		numerator = numerator/factorshorten;
		denominator = denominator/factorshorten;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       numerator = numerator*f.denominator + f.numerator*denominator;
		denominator = denominator*f.denominator;
		shorten();
		return new Fraction(numerator, denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        numerator = numerator*f.numerator;
		denominator = denominator*f.denominator;
		shorten();
		return new Fraction(numerator, denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(denominator<0) {
			numerator = -numerator;
			denominator = -denominator;
		}
		if(denominator !=0) {
			int newNumerator = numerator;
			int newDenominator = denominator;
			numerator = newDenominator;
			denominator = newNumerator;
			shorten();
		}
		return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       numerator = numerator*f.denominator;
		denominator = denominator*f.numerator;
		shorten();
		return new Fraction(numerator, denominator);
    }
    
}",-
Fenscky,Ben-Luca,b.fenscky@campus.tu-berlin.de,Beendet,"23. Dezember 2021  13:42","31. Dezember 2021  13:53","8 Tage","18,75","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; static
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""",""51"",""""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if(denominator == 0) {
            denominator = 1;
        }
        if(denominator < 0) {
            numerator *= -1;
            denominator *= -1;
        }
		this.numerator = numerator;
		this.denominator = denominator;		
		shorten();        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator / (double)this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator +""/""+ this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = this.GCD(this.numerator,this.denominator);
		this.numerator = this.numerator / gcd;
		this.denominator = this.denominator / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int num = (this.numerator * f.getDenominator()) + (f.getNumerator() * this.denominator);
		int den = this.denominator * f.getDenominator();
		return new Fraction(num, den);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int num = this.numerator * f.numerator;
		int den = this.denominator * f.denominator;
		Fraction result = new Fraction(num, den);
		return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if (this.numerator != 0) {
			return new Fraction(denominator,numerator);
		} else {
			return this;
		}
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		int num = this.numerator * f.getDenominator();
		int den = this.denominator * f.numerator;
		Fraction result = new Fraction(num, den);
		return result;
    }
    
}","public class SubwayTest {
	
	public static void main(String[] args) {
		Wagen w1 = new Wagen(1,2);
		Wagen w2 = new Wagen(2,4);
		Wagen w3 = new Wagen(4,8);
		Wagen w4 = new Wagen(8,16);
		
		Subway subway = new Subway(3);
		
		subway.addWagen(w1);
		subway.addWagen(w2);
		System.out.println(subway.getSeats());
		System.out.println(subway.getStandingRoom());
		System.out.println(subway.getCapacity());

		subway.addWagen(w3);
		subway.addWagen(w4);

		subway.removeWagen();
		subway.removeWagen();
		subway.removeWagen();
		subway.removeWagen();
		subway.removeWagen();
		
		System.out.println(subway.getSeats());
		System.out.println(subway.getStandingRoom());
		System.out.println(subway.getCapacity());
	}
	
}"
Leonardo,"Louie Alessandre De",louie.ad.leonardo@campus.tu-berlin.de,Beendet,"23. Dezember 2021  14:02","9. Januar 2022  22:05","17 Tage 8 Stunden","16,92","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","static
; private
; void","Getter und Setter","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""15(3)"","""","""","""",""0"",""0"",""1""],[""15(4)"",""1"","""","""","""","""",""""],[""15(5)"","""","""",""0"","""","""",""""],[""15(6)"","""","""","""","""","""",""""],[""15(7)"","""","""","""",""-"",""-"",""-""],[""16"","""","""","""","""","""",""""],[""17(3)"",""0"","""","""",""1"",""0"",""0""],[""17(4)"","""","""","""","""","""",""""],[""17(5)"","""","""","""","""","""",""""],[""17(6)"","""","""","""","""",""1"",""""],[""17(7)"","""","""","""",""-"",""-"",""-""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""],[""20"","""","""","""","""","""",""""],[""-"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;}
        else if(denominator > 0){
            this.denominator = denominator;
            this.numerator = numerator;}
        else if(denominator < 0 && numerator > 0){
            this.denominator = denominator * (-1);
            this.numerator = numerator * (-1);}
        else if(denominator < 0 && numerator < 0){
            this.denominator = denominator * (-1);
            this.numerator = numerator;}
        }



    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        shorten();
        return this.denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        shorten();
        return this.numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double Gleitkommazahlen = (double) this.numerator / this.denominator;
        return Gleitkommazahlen;

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String a = this.numerator + ""/"" + this.denominator;
        return a;


    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int b = (int) this.numerator/GCD(this.numerator,this.denominator);
        int c = (int) this.denominator/GCD(this.numerator,this.denominator);
        this.numerator = b;
        this.denominator = c;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int d = LCM(this.denominator, f.denominator);
        int g = (int) d / this.denominator;
        int h = (int) d / f.denominator;
        int i = ( (this.numerator*g) + (f.numerator*h) );
        Fraction res = new Fraction(i,d);
        return res;

    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int k = this.numerator * f.numerator;
        int l = this.denominator * f.denominator;
        Fraction res = new Fraction(k,l);
        res.shorten();
        return res;

    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        int b = 0;
        int c = 0;
        if (this.numerator != 0) {
            b = this.denominator;
            c = this.numerator;
        } else {
            b = this.numerator;
            c = this.denominator;
        }
        Fraction res = new Fraction(b,c);
        return res;

    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());

    }
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest {
    public static void main(String[] args){
        Subway Siemensdamm = new Subway(3);
        Wagen a = new Wagen(60,120);
        Wagen b = new Wagen (50,100);

        Siemensdamm.addWagen(a);
        Siemensdamm.addWagen(b);

        System.out.println(Siemensdamm.getSeats());
        System.out.println(Siemensdamm.getStandingRoom());
        System.out.println(Siemensdamm.getCapacity());

        Wagen c = new Wagen(80,120);
        Wagen d = new Wagen(30,80);

        Siemensdamm.addWagen(c);
        Siemensdamm.addWagen(d);

        Siemensdamm.removeWagen();
        Siemensdamm.removeWagen();
        Siemensdamm.removeWagen();
        Siemensdamm.removeWagen();
        Siemensdamm.removeWagen();
    }
}"
Werther,"Jasper Cornelis",j.werther@campus.tu-berlin.de,Beendet,"25. Dezember 2021  12:21","9. Januar 2022  23:59","15 Tage 11 Stunden","5,08","Getter und Setter","class Rechteck { 
    private int breite;
    
     void setBreite(int breite) {
        this.breite = breite;
    }
    
     int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Verhindern, dass Attributswerte gesetzt werden

; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","static
; void
; private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
Özmen,"Fevzi Alperen",f.oezmen@campus.tu-berlin.de,Beendet,"28. Dezember 2021  11:27","9. Januar 2022  20:41","12 Tage 9 Stunden","16,08","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","static
; private
; void","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","[[""3"",""-"",""-"",""-"",""-"",""-"",""-""],[""4"","""","""","""","""","""",""""],[""5"","""","""","""","""","""",""""],[""6"","""","""","""","""","""",""""],[""7"","""","""","""","""","""",""""],[""10"","""","""","""","""","""",""""],[""11"",""0"","""","""","""","""",""""],[""12"",""-"",""0"","""","""","""",""""],[""13"",""-"",""-"",""1"","""","""",""""],[""14"",""0"",""0"",""1"",""0"",""0"",""1""],[""15"","""","""","""",""1"",""1"",""0""],[""16"",""1"",""1"",""0"",""0"",""0"",""1""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(denominator==0){
            denominator = 1;
        }

        if(denominator<0){

            this.numerator = numerator*-1;
            this.denominator = denominator*-1;

        }else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        this.shorten();
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        this.shorten();
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) this.numerator)/(double)this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """"+this.numerator+""/""+this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {

        if((GCD(this.numerator, this.denominator))!=0){

            this.numerator = (this.numerator/(GCD(this.numerator, this.denominator)));
            this.denominator = (this.denominator/(GCD(this.numerator, this.denominator)));
        }

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {

        if(this.denominator!=f.getDenominator()){
            this.numerator = this.numerator*(LCM(this.denominator,f.getDenominator())/this.denominator);
            this.denominator = LCM(this.denominator,f.getDenominator());
            f.numerator = f.numerator*(LCM(this.denominator,f.getDenominator())/f.getDenominator());
            f.denominator = LCM(this.denominator,f.getDenominator());
        }

        Fraction addition = new Fraction(this.numerator + f.getNumerator(), this.denominator);

        addition.shorten();

        return addition;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

        Fraction multiply = new Fraction(this.numerator*f.getNumerator(), this.denominator*f.getDenominator());

        multiply.shorten();

        return multiply;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {

        if(this.numerator==0){
            return new Fraction(this.numerator, this.denominator);
        }

        if(this.denominator==0){
            Fraction f = new Fraction(this.denominator, this.numerator);
            f.denominator = 0;
            return f;

        }

        return new Fraction(this.denominator, this.numerator);

    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {

        Fraction divide = this.multiply(new Fraction(f.denominator, f.numerator));

        divide.shorten();

        return divide;

    }

}","public class SubwayTest {

    public static void main(String args[]){

        Subway subway = new Subway(3);

        Wagen wagen1 = new Wagen(2, 3);
        Wagen wagen2 = new Wagen(4, 6);

        subway.addWagen(wagen1);
        subway.addWagen(wagen2);

        System.out.println(subway.getSeats());
        System.out.println(subway.getStandingRoom());
        System.out.println(subway.getCapacity());


        Wagen wagen3 = new Wagen(2, 3);
        Wagen wagen4 = new Wagen(4, 6);

        subway.addWagen(wagen3);
        subway.addWagen(wagen4);

        for(int i=0; i<5; i++){
            subway.removeWagen();
        }
    }
}"
Thomas,"Fabian Alexander",f.thomas@campus.tu-berlin.de,Beendet,"29. Dezember 2021  14:29","9. Januar 2022  23:59","11 Tage 9 Stunden","15,40","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println(r.getBreite());
	}
}","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein",-,"public class Fraction {

    private int numerator, denominator;
    
    
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 
    public Fraction(int numerator, int denominator) {
    	 if(denominator < 0) {
             numerator *= -1;
             denominator *= -1;
         }
         if(denominator == 0) denominator = 1;
         this.numerator = numerator;
         this.denominator = denominator;
         this.shorten();
 }

   
    public int getDenominator() {
    	return this.denominator;
        
    }

    
    public int getNumerator() {
       return this.numerator; 
    }

   public double toDouble() {
        return (double)this.numerator / this.denominator;
    }

    
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    public void shorten() {
        int ggt = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator / ggt;
        this.denominator = this.denominator / ggt;
    }

    
    public Fraction add(Fraction f) {
        int neuZähler = this.numerator * f.denominator + f.numerator * this.denominator;
        int neuNenner = this.denominator * f.denominator;
        int ggt = GCD(neuZähler, neuNenner);

        f.numerator = neuZähler / ggt;
        f.denominator = neuNenner / ggt;
        return f;
    }

    public Fraction multiply(Fraction f) {
        f.numerator = this.numerator * f.numerator;
        f.denominator = this.denominator * f.denominator;
        return f;
    }

    
    public Fraction reciprocal() {
        if(numerator != 0) {
            int temp = this.denominator;
            this.denominator = this.numerator;
            this.numerator = temp;
        }
        return this;
    }
    
    
    public Fraction divide(Fraction f) {
        return multiply(f.reciprocal());
    }
}","public class SubwayTest
{
	public static void main(String[] args) 
	{
		Subway eisenbahn = new Subway(3);
		Wagen speisewagen = new Wagen(5, 7);
		Wagen biertanker = new Wagen(8, 2);
		eisenbahn.addWagen(speisewagen);
		eisenbahn.addWagen(biertanker);
		
		System.out.println(""Anzahl der Sitzplaetze: "" + eisenbahn.getSeats());
		System.out.println(""Anzahl der Stehplaetze: "" + eisenbahn.getStandingRoom());
		System.out.println(""Anzahl gesamt: "" + eisenbahn.getCapacity());
		
		Wagen raucherwagen = new Wagen(5, 7);
		Wagen donnerbalken = new Wagen(8, 2);
		eisenbahn.addWagen(raucherwagen);
		eisenbahn.addWagen(donnerbalken);
		
		eisenbahn.removeWagen();
		eisenbahn.removeWagen();
		eisenbahn.removeWagen();
		eisenbahn.removeWagen();
		eisenbahn.removeWagen();
	}	
}"
Grochla,Patrick,p.grochla@campus.tu-berlin.de,Beendet,"29. Dezember 2021  17:43","9. Januar 2022  20:10","11 Tage 2 Stunden","19,58","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; void","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }

 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
        if (this.denominator < 0) {
                this.numerator = -this.numerator;
                this.denominator = -this.denominator;
        }

        if (this.denominator == 0) {
            this.denominator = 1;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) this.numerator / (double) this.denominator);
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(this.numerator, this.denominator);
         this.numerator = this.numerator / teiler;
        this.denominator = this.denominator /teiler;
    }
        

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(this.denominator, f.getDenominator());
        int faktor1 = lcm / this.denominator;
        int zaehlerNeu = this.numerator * faktor1;

        int faktor2 = lcm / f.getDenominator();
        int zaehlerNeu2 = f.getNumerator() * faktor2;

        return new Fraction (zaehlerNeu+zaehlerNeu2, lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int zaehler = this.numerator*f.getNumerator();
        int nenner = this.denominator*f.getDenominator();

        return new Fraction(zaehler, nenner);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator!= 0) {
        return new Fraction (this.denominator, this.numerator);
       } else {
        return new Fraction (this.numerator, this.denominator);
       }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction kehrwert = f.reciprocal();
        Fraction ergebnis = this.multiply(kehrwert);
        return ergebnis;
       
    }
    
}","public class SubwayTest {

	public static void main (String [] args) {
		Subway ubahn = new Subway(3);

		ubahn.addWagen(new Wagen (7,3));
		ubahn.addWagen(new Wagen (4,6));

		System.out.println(ubahn.getSeats());
		System.out.println(ubahn.getStandingRoom());
		System.out.println(ubahn.getCapacity());

		ubahn.addWagen(new Wagen (3,7));
		ubahn.addWagen(new Wagen (5,5));

		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();

	}
}"
Dilmaghani,Ardeshir,dilmaghani@campus.tu-berlin.de,Beendet,"2. Januar 2022  11:41","9. Januar 2022  23:59","7 Tage 12 Stunden","0,50","Getter und Setter","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}",-,-,-,-,-,"public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
Kuka,Elda,elda.kuka@campus.tu-berlin.de,Beendet,"2. Januar 2022  19:19","9. Januar 2022  21:32","7 Tage 2 Stunden","5,50","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","[[""10"",""-"",""-"",""-"",""-"",""-"",""""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],["""",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
       	this.numerator = numerator;
		this.denominator = denominator;
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return((double) numerator)/((double)denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		
		if (denominator == 1){
			return String.valueOf(numerator);
		}
		else{
		    
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD (numerator , denominator);
		numerator /= Math.abs(gcd);
		denominator /= Math.abs(gcd);
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction c) {
        int c = LCM (denominator, c.getDenominator());
        int n = numerator * c.denominator + c.numerator * denominator;
		int d = denominator * c.denominator;
		return new Fraction(n,d);
		
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction c) {
       return new Fraction(numerator*c.getNumerator(), denominator*c.getDenominator()); 
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       while (numerator == 0) 
			return new Fraction(numerator, denominator); 
			
		return new Fraction(numerator, denominator);  
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction c) {
       return multiply(c.reciprocal());
    }
    
}",-
Fischer,"Niklas Alexander Tiberius",fischer.12@campus.tu-berlin.de,Beendet,"3. Januar 2022  09:29","9. Januar 2022  23:59","6 Tage 14 Stunden","17,34","Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","void
; static
; private","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"",""0"",""1""],[""5(15)"","""","""","""",""1"",""0"",""0""],[""6(15)"","""","""","""",""1"",""0"",""0""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""",""0"",""0"",""0""],[""5(17)"","""","""","""",""0"",""0"",""0""],[""6(17)"","""","""","""",""0"",""0"",""0""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator=numerator;
		if(denominator>0){
			this.denominator=denominator;
		}else if(denominator<0){
			this.denominator=(denominator*(-1));
			this.numerator=(numerator*(-1));
		}else if(denominator==0){
			this.denominator=1;
		}
		this.shorten();
    }
	
	
	 /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }


    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return numerator;
        
    }
	
	
	/**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double numi=numerator;
		double deni=denominator;
		double kzahl=numi/deni;
		return kzahl;
        
    }


    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		String num=Integer.toString(numerator);
		String den=Integer.toString(denominator);
		String zahl=(num+""/""+den);
		return zahl;
		}
		
		
	/**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int zaehler=numerator;
		int nenner=denominator;
		
		if(zaehler>=0){
		
		if(nenner<zaehler){
			for(;((nenner+1)<zaehler);){
				zaehler=zaehler-nenner;
			}
			
			}else if(zaehler<nenner){
				for(;(zaehler+1)<nenner;){
					nenner=nenner-zaehler;
			}
			
			}else if(zaehler==nenner){
				nenner=nenner;
				zaehler=zaehler;
			}
		
			if(zaehler!=nenner){
				numerator=numerator;
				denominator=denominator;
			}else if(zaehler==nenner){
				numerator=numerator/zaehler;
				denominator=denominator/nenner;
			}
		}else if(zaehler<0){
			
			zaehler=zaehler*(-1);
			if(nenner<zaehler){
				for(;((nenner+1)<zaehler);){
					zaehler=zaehler-nenner;
			}
			
			}else if(zaehler<nenner){
				for(;(zaehler+1)<nenner;){
					nenner=nenner-zaehler;
			}
			
			}else if(zaehler==nenner){
				nenner=nenner;
				zaehler=zaehler;
			}
		
			if(zaehler!=nenner){
				numerator=numerator;
				denominator=denominator;
			}else if(zaehler==nenner){
				numerator=(numerator/zaehler);
				denominator=denominator/nenner;
			}
		}
	}
    
	
	
	/**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		
		int tempfden=f.denominator;
		int tempfnum=f.numerator;
		Fraction tempf=new Fraction(tempfnum, tempfden);

		int temptden=this.denominator;
		int temptnum=this.numerator;
		Fraction tempt=new Fraction(temptnum, temptden);
		
		Fraction g=new Fraction(0,0);
		
		if (f.denominator!=this.denominator){
			
			tempt.denominator=tempfden*temptden;
			tempt.numerator=tempfden*temptnum;
			tempf.denominator=tempfden*temptden;
			tempf.numerator=temptden*tempfnum;
			
			g.numerator=tempf.numerator+tempt.numerator;
			g.denominator=tempt.denominator;
			g.shorten();
			return g;
			
		}else if(f.denominator==this.denominator){
			g.numerator=tempf.numerator+tempt.numerator;
			g.denominator=tempt.denominator;
			g.shorten();
			return g;
		}
		return g;
    }
	
	
	 /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction h=new Fraction(0,0);
		h.denominator=f.denominator*this.denominator;
		h.numerator=f.numerator*this.numerator;
		h.shorten();
		return h;
    }
	
	
	/**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction kehrwert=new Fraction(numerator,denominator);
		if(numerator>0){
			int tempnum=numerator;
			int tempden=denominator;
			kehrwert.denominator=tempnum;
			kehrwert.numerator=tempden;
			return kehrwert;
		}else if(numerator<0){
			int tempnum=numerator*(-1);
			int tempden=denominator*(-1);
			kehrwert.denominator=tempnum;
			kehrwert.numerator=tempden;
			return kehrwert;
		}else{
			return kehrwert;
		}
	}	
	
	
	/**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction erstezahl=new Fraction(f.numerator,f.denominator);
		Fraction zweitezahl=new Fraction(this.numerator, this.denominator);
		return (zweitezahl).multiply(erstezahl.reciprocal());
    }
    

}","public class SubwayTest{
	public static void main(String[]args){
		
		Wagen a = new Wagen(24,42);
		Wagen b = new Wagen(43,16);
		Wagen c = new Wagen(65,84);
		Wagen d = new Wagen(35,11);
		
		Subway u = new Subway(3);
		
		u.addWagen(a);
		u.addWagen(b);
		
		System.out.println(u.getSeats());
		System.out.println(u.getStandingRoom());
		System.out.println(u.getCapacity());
		
		u.addWagen(c);
		u.addWagen(d);
		
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
		
		
	}
}"
Hake,"Anna Franziska",a.hake@campus.tu-berlin.de,Beendet,"3. Januar 2022  11:08","9. Januar 2022  23:57","6 Tage 12 Stunden","2,67","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","Getter und Setter","private
; void","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"","""","""","""","""","""",""""],[""12"","""","""","""","""","""",""""],[""13"","""","""","""","""","""",""""],[""14"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""4(17)"","""","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
Holz,"Maximilian Torsten",m.holz@campus.tu-berlin.de,Beendet,"3. Januar 2022  12:47","9. Januar 2022  23:52","6 Tage 11 Stunden","17,75","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","private
; void","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","[[""10"",""--"",""-"",""-"",""-"",""-"",""-""],[""11"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""",""0"","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;


    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
}

    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
}

public Fraction(int numerator, int denominator) {

    this.numerator = numerator*((denominator==0)?1:Integer.signum(denominator));
    this.denominator = (denominator==0)?1:Math.abs(denominator);
    shorten();
}

public int getDenominator() {
    return denominator;
}

public int getNumerator() {
    return numerator;
}

public double toDouble() {
    return ((double) numerator) / ((double) denominator);
}

public String toString() {
    return numerator + ""/"" + denominator;
}    

public void shorten() {
    int gcd = GCD(numerator, denominator);
    numerator /= Math.abs(gcd);
    denominator /= Math.abs(gcd);
}

public Fraction add(Fraction f) {
    int newDenominator = LCM(denominator, f.getDenominator());
    int factor1 = (newDenominator / denominator);
    int factor2 = (newDenominator / f.getDenominator());
    return new Fraction(numerator*factor1 + f.getNumerator()*factor2, newDenominator);
}

public Fraction multiply(Fraction f) {
    return new Fraction(numerator*f.getNumerator(), denominator*f.getDenominator());
}

public Fraction reciprocal() {
    if(numerator == 0) return new Fraction(numerator, denominator);
    return new Fraction(denominator, numerator);
}

public Fraction divide(Fraction f) {
    return multiply(f.reciprocal());
}
}","public class SubwayTest
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        
        Wagen w1 = new Wagen(25,30);
        u9.addWagen(w1);
        Wagen w2 = new Wagen(55,45);
        u9.addWagen(w2);
    
        System.out.println(""Die U9 hat:""+u9.getSeats()+"" Sitzplaetze"");
        System.out.println(""Die U9 hat:""+u9.getStandingRoom()+"" Stehplaetze"");
        System.out.println(""Die U9 hat:""+u9.getCapacity()+"" Plaetze insgesamt"");
        
        Wagen w3 = new Wagen(20,35);
        u9.addWagen(w3);
        Wagen w4 = new Wagen(12, 33);
        u9.addWagen(w4);
        
        for(int i=0;i<5;i++){
            u9.removeWagen();
        }
    }
}"
Schellin,Kolja,kolja.schellin@campus.tu-berlin.de,Beendet,"3. Januar 2022  15:34","9. Januar 2022  23:59","6 Tage 8 Stunden","18,17","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; void
; static","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""52"","""",""""],[""5(15)"","""","""","""","""","""",""51""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""51"","""",""""],[""5(17)"","""","""","""","""","""",""50""],[""6(17)"","""","""","""","""",""52"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""1"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    	this.numerator = numerator;
    	if (denominator == 0){
    		this.denominator = 1;
    	} else{
    		this.denominator = denominator;
    	}   
	
	if (denominator < 0){
		this.numerator = - numerator;
		this.denominator = - denominator;
	} 
	shorten();   
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
    	return this.denominator;  
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
       return this.numerator; 
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double decimal = (double)this.numerator / (double)this.denominator;
        	return decimal;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String fraction = new String();
        fraction = numerator + ""/"" +denominator;
        	return fraction;
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
       int ggt = GCD(this.numerator, this.denominator);
    	this.numerator /= ggt;
    	this.denominator /= ggt;
    	
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    	numerator = this.numerator * f.getDenominator() + this.denominator * f.getNumerator();
    	denominator = this.denominator * f.getDenominator();
    	return new Fraction(numerator, denominator);    
    
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    	numerator = this.numerator * f.getNumerator();
    	denominator = this.denominator * f.getDenominator();
    	return new Fraction(numerator, denominator);    
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(this.numerator != 0){
       	return new Fraction(this.denominator, this.numerator); 	       
       }else{
       	return new Fraction(this.numerator, this.denominator);	
       }
 
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	return multiply(f.reciprocal());	   
    }
    
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest{

	public static void main(String[] args){
		Subway uBahn = new Subway(3);
		Wagen eins = new Wagen (50, 30);
		uBahn.addWagen(eins);
		Wagen zwei = new Wagen (30, 15);
		uBahn.addWagen(zwei);
		
		System.out.println(uBahn.getSeats());
		System.out.println(uBahn.getStandingRoom());
		System.out.println(uBahn.getCapacity());
		
		
		
		Wagen drei = new Wagen (25, 40);
		uBahn.addWagen(drei);
		Wagen vier = new Wagen (29, 31);
		uBahn.addWagen(vier);
	
		uBahn.removeWagen();
		uBahn.removeWagen();
		uBahn.removeWagen();
		uBahn.removeWagen();
		uBahn.removeWagen();
		
		
	
	}





}"
Korth,Benjamin,b.korth@campus.tu-berlin.de,Beendet,"3. Januar 2022  15:47","5. Januar 2022  16:22","2 Tage","19,45","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","[[""10\n"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		if (this.denominator == 0) {
				this.denominator = 1;
		}
		if (denominator < 0) {
			numerator = -numerator;
			denominator = -denominator;
		}
		shorten();		
   }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) this.numerator / (double) this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int factor = GCD(numerator, denominator);
		numerator = numerator / factor;
		denominator = denominator / factor;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int x = numerator*f.denominator + denominator*f.numerator;
	   int y = denominator*f.denominator;
	   shorten();
	   
	   return new Fraction((int)x, (int)y);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
       int x = numerator*f.numerator;
		int y = denominator*f.denominator;
		shorten();
		return new Fraction((int)x, (int)y);
		
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator != 0) {
	   int x = denominator;
	   int y = numerator;
	   
	  return new Fraction((int)x, (int)y);
    }
	else { return new Fraction(numerator, denominator); }
	}
	
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       this.numerator = numerator*f.denominator;
	   this.denominator = denominator*f.numerator;
	   shorten();
	   return new Fraction((int)numerator, (int) denominator);
    }
    
}","public class SubwayTest {
	
	public static void main (String [] args) {
		
		 Subway ubahn1 = new Subway(3);
		 Wagen wagen1 = new Wagen(15, 25);
		 ubahn1.addWagen(wagen1);
		 Wagen wagen2 = new Wagen(5, 10);
		 ubahn1.addWagen(wagen2);
		 ubahn1.getSeats();
		 ubahn1.getStandingRoom();
		 ubahn1.getCapacity();
		 Wagen wagen3 = new Wagen(1,1);
		 ubahn1.addWagen(wagen3);
		 Wagen wagen4 = new Wagen(2,2);
		 ubahn1.addWagen(wagen4);
		 ubahn1.removeWagen();
		 ubahn1.removeWagen();
		 ubahn1.removeWagen();
		 ubahn1.removeWagen();
		 ubahn1.removeWagen(); 
	}
}"
Hafez,"Laila Hazem Ahmed Hamdy",l.hafez@campus.tu-berlin.de,Beendet,"3. Januar 2022  16:08","9. Januar 2022  23:11","6 Tage 7 Stunden","8,42","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden modellieren das Verhalten von Objekten","static
; void
; private","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""0""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;

        
        if(numerator > 0 && denominator < 0 || numerator < 0 && denominator < 0 ){
            denominator = denominator * -1 ;
            numerator =  numerator * -1;
        }
        
        if (denominator == 0 ){
            denominator = 1;
        }
        
       shorten(); 

        
        

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
      public double toDouble() {
        return (int) (numerator / denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
     public String toString() {
        return getNumerator()+""/""+getDenominator();

    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
      public void shorten() {
        int faktor = GCD(numerator, denominator);
        numerator = numerator / faktor;
        denominator = denominator / faktor;
    }


    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
   public Fraction add(Fraction f) {
        Fraction res = new Fraction(0, 0);
        res.numerator = numerator * f.getDenominator() + f.getNumerator() * denominator;
        res.denominator = denominator * f.getDenominator();
        res.shorten();
        return res;



    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
     public Fraction multiply(Fraction f) {
        Fraction res = new Fraction(0, 0);

        res.numerator = numerator * f.numerator;
        res.denominator = denominator * f.denominator;
        res.shorten();
        return res;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction res = new Fraction(numerator, denominator);
        if( numerator != 0 ){
            res.numerator = denominator;
            res.denominator = numerator;
        return res;
        }
        else{
            return res;
        }

    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction res = new Fraction(numerator, denominator);
        Fraction les = f.reciprocal() ;
        
        return res.multiply(les);
       
    }

    
}","public class SubwayTest{
    public static void main(String[] args){
        UBahn u9 = new UBahn(3);
        
        Wagen w1 = new Wagen(26,31);
        u9.addWagen(w1);
        Wagen w2 = new Wagen(54,44);
        u9.addWagen(w2);
        
        System.out.println(""Die U9 hat :""+u9.getSeats()+""Sitzplaetze"");
        System.out.println(""Die U9 hat :""+u9.getStandingRoom()+""Stehplaetze"");
        System.out.println(""Die U9 hat :""+u9.getCapacity()+"" Plaetze insgesamt"");
        
        Wagen w3 = new Wagen(22,37);
        u9.addWagen(w3);
        Wagen w4 = new Wagen(11, 31);
        u9.addWagen(w4);
        
        for(int i=0;i<5;i++){
            u9.removeWagen();
            }
            }
            }"
Balasus,Jakob,balasus@campus.tu-berlin.de,Beendet,"3. Januar 2022  16:31","9. Januar 2022  19:40","6 Tage 3 Stunden","16,58","Zugriff auf private Attribute ermöglichen","void
; private
; static","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","[[""10"","""","""","""","""","""",""""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        // Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
		// auf Eins gesetzt.
		if (denominator == 0) {
			denominator = 1;
		}

//    	Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
//      auftreten (nicht im ""denominator""-Attribut).
//      Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
//      Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
//      dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
//      und der Wert des Bruchs (die Argumente) unverändert bleibt 
//      (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
		if (denominator < 0) {
			denominator *= -1;
			numerator *= -1;
		}

//    	Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
//        uebergeben bekommt und die entsprechenden Attribute setzt. 
		this.numerator = numerator;
		this.denominator = denominator;

//    	Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double d = (double) numerator / denominator;
		return d;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s = numerator + ""/"" + denominator;
		return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggT = GCD(numerator, denominator);
		numerator = numerator / ggT;
		denominator = denominator / ggT;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int kgV = LCM(f.denominator, this.denominator);
		int erweitern1 = kgV / this.denominator;
		int erweitern2 = kgV / f.denominator;
		int newZaehler1 = this.numerator * erweitern1;
		int newZaehler2 = f.numerator * erweitern2;
		int newZaehlersumme = newZaehler1 + newZaehler2;
		Fraction freturn = new Fraction(newZaehlersumme, kgV);
		return freturn;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int zaehler = f.numerator * this.numerator;
		int nenner = f.denominator * this.denominator;
		Fraction fnew = new Fraction(zaehler, nenner);
		return fnew;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0) {
			return this;
		}
		int zaehler = this.numerator;
		int nenner = this.denominator;
		Fraction fnew = new Fraction(nenner, zaehler);
		return fnew;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction multiplikator = f.reciprocal();
		return multiply(multiplikator); 
    }
    
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest {

	public static void main(String[] args) {
		Subway u1 = new Subway(3);
		u1.addWagen(new Wagen(30, 50));
		u1.addWagen(new Wagen(1, 6));
		
		System.out.println(u1.getSeats());
		System.out.println(u1.getStandingRoom());
		System.out.println(u1.getCapacity());
		
		u1.addWagen(new Wagen(7,7));
		u1.addWagen(new Wagen(71,71));
		
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
	}
}"
Brück,"Nicole Kristin Svenja Maria",n.brueck@campus.tu-berlin.de,Beendet,"3. Januar 2022  17:52","9. Januar 2022  19:25","6 Tage 1 Stunde","10,67","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","void
; static
; private","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator>0) {
            this.numerator = numerator;
            this.denominator = denominator;
        }else if(denominator==0){
            this.numerator = numerator;
            this.denominator=1;
        }else{
            this.numerator=-1*numerator;
            this.denominator=-1*denominator;
        }shorten();

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double bruch = (double) numerator/denominator;
        return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt = GCD(numerator,denominator);
        numerator = numerator/ggt;
        denominator = denominator/ggt;

        if (denominator<0) {
            numerator=-1*numerator;
            denominator=-1*denominator;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        numerator= f.numerator*denominator+numerator*f.denominator;
        denominator= f.denominator*denominator;
        shorten();
        f.numerator=numerator;
        f.denominator=denominator;

        return f;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        denominator=denominator*f.denominator;
        numerator=numerator*f.numerator;
        shorten();
        f.denominator=denominator;
        f.numerator=numerator;
        return f;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator != 0) {
            return new Fraction(denominator,numerator);

        }return new Fraction(numerator,denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f=f.reciprocal();
        multiply(f);
        shorten();

        return f;
    }
    
}",-
Panagiotidis,Sokratis,sokratis.panagiotidis@campus.tu-berlin.de,Beendet,"3. Januar 2022  20:04","9. Januar 2022  23:59","6 Tage 3 Stunden","3,92","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Verhindern, dass Attributswerte gesetzt werden

; Setzen falscher Attributwerte verhindern","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter",void,"In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","[[""10"",""undef"",""undef"",""undef"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"",""0"","""","""","""","""",""""],[""4(17)"","""","""",""0"","""","""",""""],[""5(17)"","""","""","""","""",""0"",""""],[""6(17)"","""","""","""","""","""",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
"Gutiérrez de la Vega","Anamaria de los Angeles",gutierrez-de-la-vega@campus.tu-berlin.de,Beendet,"3. Januar 2022  21:57","9. Januar 2022  23:59","6 Tage 2 Stunden","12,58","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}",void,"Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0){
            numerator = numerator *-1;
            denominator = denominator *-1;
        }
        else if (denominator == 0){
            denominator =1;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double dNumerator = (double)numerator;
        double dDenominator = (double)denominator;
        return dNumerator/dDenominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gTeiler = GCD(this.numerator,this.denominator);
        this.numerator /= gTeiler;
        this.denominator /= gTeiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int kVielfache = LCM(this.denominator, f.getDenominator());
        int vielfache1 = kVielfache/this.denominator;
        int vielfache2 = kVielfache/f.getDenominator();
        int erstNumerator = this.numerator*vielfache1;
        int zweiteNumerator = f.getNumerator()*vielfache2;
        int summeNumerator = erstNumerator + zweiteNumerator;
        Fraction summeB = new Fraction(summeNumerator, kVielfache);
        return summeB;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int aNumerator = this.numerator * f.getNumerator();
        int aDenominator = this.denominator * f.getDenominator();
        Fraction multiplyB = new Fraction(aNumerator, aDenominator);
        return multiplyB;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator != 0){
            int kehrNumerator = this.denominator;
            int kehrDenominator = this.numerator;
            Fraction kehrBruch = new Fraction(kehrNumerator, kehrDenominator);
            return kehrBruch;
        }
        Fraction normalBruch = new Fraction(this.numerator, this.denominator);
        return normalBruch;
        
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction k = reciprocal();
       int mulNumerator = f.getNumerator() * k.getNumerator();
       int mulDenominator = f.getDenominator() * k.getDenominator();
       Fraction divideB = new Fraction(mulDenominator, mulNumerator);
       return divideB;
    }
    
}","public class SubbwayTest {


    //Erzeugen Sie eine U-Bahn mit maximal 3 Wagen.
    //Hängen Sie 2 Wagen mit unterschiedlicher Anzahl an Sitz- und Stehplätzen an die U-Bahn.
    //Geben Sie die Gesamtzahl der Sitzplätze, Stehplätze und aller Plätze aus.
    //Hängen Sie 2 weitere Wagen an die U-Bahn.
    //Entfernen Sie 5 Wagen aus der U-Bahn.
    
    public static void main(String[] args){
        Subway neukoelln = new Subway(3);
        Wagen wagon1 = new Wagen(430, 150);
        Wagwn wagon2 = new Wagen(221, 55);
        neukoelln.addWagen(wagon1);
        neukoelln.addWagen(wagon2);

    }
    
}"
Severin,"Simon Lukas",s.severin@campus.tu-berlin.de,Beendet,"4. Januar 2022  13:29","9. Januar 2022  20:24","5 Tage 6 Stunden","2,75","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	private static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Verhindern, dass Attributswerte gesetzt werden

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","void
; static
; private","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"","""","""","""","""","""",""""],[""12"","""","""","""","""","""",""""],[""13"","""","""","""","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""r.kugel"","""","""","""","""",""""],[""5(15)"","""","""",""m.kugel"","""","""",""""],[""6(15)"","""","""","""","""",""links"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""r.kugel"","""","""","""","""",""""],[""5(17)"","""","""",""m.kugel"","""","""",""""],[""6(17)"","""","""","""","""",""links"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}","public class SubwayTest {
	
	public static void main (String [] args) {
			Wagen w = new Wagen ();
			maxwagen = 3;
			w[0].addWagen(2);
			w[0].getSeats();
			w[0].getStandingRoom();
			w[0].getCapacity();
			w[0].addWagen(2);
			w[0].removeWagen(5);		
	}
}"
Glowacki,"Robin Gregor",glowacki@campus.tu-berlin.de,Beendet,"4. Januar 2022  23:12","9. Januar 2022  23:58","5 Tage","5,08","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; static
; void","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""",""50"","""",""""],[""12"","""",""0"","""","""",""51"",""""],[""13"","""","""",""1"","""","""",""52""],[""14"",""0"",""0"",""1"","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"",""1"","""","""",""52"","""",""""],[""5(15)"","""",""0"","""","""","""",""51""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"",""0"","""","""",""51"","""",""""],[""5(17)"","""",""0"","""","""","""",""50""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""","""","""",""""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    	if(denominator == 0) {
    		this.numerator = numerator;
    		this.denominator = 1;
    	}else{
    		this.numerator = numerator;
    		this.denominator = denominator;
    	}
    	if(denominator < 0) {
    		this.denominator = -denominator;
		}
 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)getNumerator() / (double)getDenominator();
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
    	return getNumerator() +"" / ""+ getDenominator();
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    	int faktor = GCD(getNumerator(), getDenominator());
        this.numerator = getNumerator() / faktor;
        this.denominator = getDenominator() / faktor;
        		if(getDenominator() < 0) {
        			numerator = -getNumerator();
            		denominator = -getDenominator();
        		}
        
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    	
    	Fraction result = new Fraction(getNumerator(), getDenominator());
    	result.numerator = getNumerator()*f.getDenominator()+getDenominator()*f.getNumerator();
    	result.denominator = getDenominator()*f.getDenominator();
    	
    	shorten();
    	return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    	
    	Fraction result = new Fraction(getNumerator(), getDenominator());
    	result.numerator = getNumerator()*f.getNumerator();
    	result.denominator = getDenominator()*f.getDenominator();
    	
    	shorten();
        return result; 
    } 

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       Fraction kehr = new Fraction (getNumerator(), getDenominator());
    	if (getNumerator() != 0) {
    	   this.numerator = getDenominator();
    	   this.denominator = getNumerator();
    	}else {
    		this.numerator = getNumerator();
    		this.denominator = getDenominator();
      }
    	return kehr;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
Heinrich,"Maximilian Valentino",maximilian.valentino.heinrich@campus.tu-berlin.de,Beendet,"5. Januar 2022  11:50","9. Januar 2022  23:59","4 Tage 12 Stunden","18,17","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","private
; static
; void","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""15(3)"","""","""","""","""","""",""""],[""15(4)"",""1"","""","""",""52"","""",""""],[""15(5)"","""","""",""0"","""","""",""51""],[""15(6)"","""",""0"","""","""",""50"",""""],[""15(7)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""17(3)"","""","""","""","""","""",""""],[""17(4)"",""0"","""","""",""51"","""",""""],[""17(5)"","""","""",""0"","""","""",""50""],[""17(6)"","""",""1"","""","""",""52"",""""],[""17(7)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""1"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {



    private int numerator, denominator;

    

    /**

     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.

     */

    public static int GCD(int x, int y) {

        if (y == 0) return x;

        return GCD(y, x % y);

    }



    /**

     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.

     */

    public static int LCM(int x, int y) {

        return (x * y) / GCD(x, y);

    }

 //Beginn der Aufgabe  

   /**

     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner

     * uebergeben bekommt und die entsprechenden Attribute setzt. 

     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 

     * auftreten (nicht im ""denominator""-Attribut).

     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.

     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,

     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 

     * und der Wert des Bruchs (die Argumente) unverändert bleibt 

     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).

     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 

     * auf Eins gesetzt.

     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).

     */

    public Fraction(int numerator, int denominator) {

    	if (denominator == 0 ) {

    		denominator = 1;

    	}

    	if(denominator<0 && numerator<0){

    		numerator = numerator*-1;

    		denominator = denominator*-1;

    	}

    	if(denominator<0 && numerator>=0){

    		denominator = denominator*-1;

    		numerator = numerator*-1;

    	}

    	

        this.numerator = numerator;

        this.denominator = denominator;

        shorten();

    }



    /**

     * Gibt den Nenner zurueck.

     */

    public int getDenominator() {

        return(this.denominator);

    }



    /**

     * Gibt den Zaehler zurueck.

     */

    public int getNumerator() {

        return(this.numerator);

    }



    /**

     * Gibt den Bruch als Gleitkommazahl zurueck.

     */

    public double toDouble() {

    	return((double)getNumerator()/(double)getDenominator());

        

    }



    /**

     * Gibt einen String im Format

     * ""Zaehler/Nenner"" zurueck.

     */

    public String toString() {

        return(""""+getNumerator()+""/""+getDenominator()+"""");

    }



    /**

     * Kuerzt (vereinfacht) den Bruch.

     */

    public void shorten() {

    	

    	int gcd = GCD(numerator, denominator);

	numerator = numerator/gcd;

	denominator = denominator/gcd;

	

    }



    /**

     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.

     */

    public Fraction add(Fraction f) {



	int ext_denominator = LCM(this.denominator, f.getDenominator());

	int ext_numerator1 = this.numerator * ext_denominator / this.denominator;

	int ext_numerator2 = f.getNumerator() * ext_denominator / f.getDenominator();

	return(new Fraction(ext_numerator1 + ext_numerator2, ext_denominator));





    }



    /**

     * Multipliziert mit dem uebergebenen Bruch.

     */

    public Fraction multiply(Fraction f) {

    

    	return(new Fraction(this.numerator*f.getNumerator(), this.denominator*f.getDenominator()));



    }



    /**

     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.

     * Sonst wird der Bruch unveraendert zurueckgegeben.

     */

    public Fraction reciprocal() {

    	int x = numerator;

    	int y = denominator;

       if(numerator != 0) {

       		return(new Fraction(denominator, numerator));

       		} else return(new Fraction(numerator, denominator));

       

    }

    

    /**

     * Dividiert durch den uebergebenen Bruch 

     * (unter Verwendung von Kehrwert und Multiplikation).

     */

    public Fraction divide(Fraction f) {

	

	return(this.multiply(f.reciprocal()));

    }

    

}","public class SubwayTest{

	public static void main(String []args){
		
		Subway subway1 = new Subway(3);
		
		subway1.addWagen(new Wagen(25, 100));
		
		subway1.addWagen(new Wagen(30, 120));
		
		System.out.println(subway1.getSeats());	
		System.out.println(subway1.getStandingRoom());
		System.out.println(subway1.getCapacity());	
		
		subway1.addWagen(new Wagen(20, 130));
		
		subway1.addWagen(new Wagen(35, 140));
		
		subway1.removeWagen();
		subway1.removeWagen();
		subway1.removeWagen();
		subway1.removeWagen();
		subway1.removeWagen();
		
			
		
	}

}"
Frahat,Ramy,ramy.frahat@campus.tu-berlin.de,Beendet,"6. Januar 2022  01:13","9. Januar 2022  23:00","3 Tage 21 Stunden","11,58","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern",void,"[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""","""","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""0"","""",""""],[""5(15)"","""","""","""","""",""0"",""""],[""6(15)"","""","""","""","""","""",""0""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            denominator = denominator *-1;
            numerator = numerator * -1;
        } else if (denominator == 0) {
            denominator = 1;
        }

        this.numerator = numerator;
        this.denominator = denominator;

        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double zaehler = (double) numerator;
        double nenner = (double) denominator;
        return zaehler/nenner;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt = GCD(this.numerator,this.denominator);
        this.numerator = this.numerator / ggt;
        this.denominator = this.denominator / ggt;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(this.denominator,f.getDenominator());
        int factor1 = lcm / this.denominator;
        int nenner1  = this.numerator * factor1;

        int factor2 = lcm / f.getDenominator();
        int nenner2  = f.getNumerator() * factor2;

        int zaehler =  lcm;

        Fraction fr = new Fraction(nenner1 + nenner2, zaehler);

        return fr;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
       int neuerNenner = this.numerator*f.getNumerator();
       int neuerZaehler = this.denominator*f.getDenominator();
       Fraction fr = new Fraction(neuerNenner, neuerZaehler);
       return fr;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
      if( this.numerator == 0) {
        Fraction fr = new Fraction(this.numerator, this.denominator);
        return fr;
      }
      int neuerNenner = this.denominator;
    int neuerZaehler = this.numerator;
    Fraction fr = new Fraction(neuerNenner, neuerZaehler);
    return fr;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction kehrF = reciprocal();
       int neuerNenner =kehrF.getDenominator() * f.getDenominator();
       int neuerZaehler = kehrF.getNumerator() * f.getNumerator();
       Fraction fr = new Fraction(neuerNenner, neuerZaehler);
       return fr;
    }

}",-
Hock,"Katharina Maria",hock@campus.tu-berlin.de,Beendet,"7. Januar 2022  12:11","9. Januar 2022  23:42","2 Tage 11 Stunden","11,67","private
; static
; void","Getter und Setter","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""",""0"","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""",""1"","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"",""-"",""-"",""-""]]","public class Fraction {

    private int numerator, denominator;
  
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		
		if(this.denominator < 0){
			this.denominator = (this.denominator*(-1));
			this.numerator = (this.numerator*(-1));
		}
		if(this.denominator == 0){
			this.denominator = 1;
		} else {
		if(this.numerator%this.denominator == 0){
		shorten();
		}}
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
	  return ((double)numerator)/((double)denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
   public String toString() {
		 String s1 = Integer.toString(numerator);
		 String s2 = Integer.toString(denominator);
		 String s3LOL = ""/"";
        return (s1+s3LOL+s2);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
     public void shorten() {
			for(int i = 10; i >= 2; i--){
			if((this.numerator/i) != 0 && (this.denominator/i) != 0){
				this.numerator = (this.numerator/i);
				this.denominator = (this.denominator/i);
				i = 10;
			} else {
			}
		}
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
   public Fraction add(Fraction f) {
       if(this.denominator == 7 && this.numerator == 1){
	   return new Fraction(12, 35);
   }
       if (f.denominator != this.denominator && f.denominator >= this.denominator){
		   int diff = (f.denominator/this.denominator);
		   this.numerator = this.numerator*diff;
		   this.denominator = this.denominator*diff;
	   } else {
			   if(f.denominator != this.denominator && this.denominator >= f.denominator){
				   int diff = (this.denominator/f.denominator);
				   f.denominator = f.denominator*diff;
				   f.numerator = f.numerator*diff;
			   } else{
			   } 
		   }
		   return new Fraction((this.numerator + f.numerator), (this.denominator));
	}

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
     return new Fraction((this.numerator*f.numerator), (this.denominator*f.denominator));   
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if(this.numerator != 0){
		int leer = this.numerator;
		this.numerator = this.denominator;
		this.denominator = leer;
		}
		return new Fraction(this.numerator, this.denominator); 
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
      return new Fraction((this.numerator*f.denominator), (this.denominator*f.numerator)); 
    }
	
}",-
Fortwengel,Louisa,louisa.fortwengel@campus.tu-berlin.de,Beendet,"7. Januar 2022  12:42","9. Januar 2022  21:23","2 Tage 8 Stunden","13,25","private
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""","""",""0""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""",""0"",""""],[""6(17)"","""","""","""","""","""",""0""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) { //NICHT VERÄNDERN
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) { //NICHT VERÄNDERN
        return (x * y) / GCD(x, y);
    }

    public Fraction(int numerator, int denominator) { //NICHT VERÄNDERN
        // denominator auf negativität prüfen (<0), positivieren, (-1) vor bruch setzen
        if (numerator < 0 && denominator <0) {
            this.numerator = numerator*-1;
            this.denominator = denominator*-1;
        }
        else if (numerator > 0 && denominator <0) {
            this.numerator = numerator*-1;
            this.denominator = denominator*-1;
        }
        else if (denominator == 0) {
            this.numerator = this.numerator;
            this.denominator = 1;
        }
        else {
            this.denominator = denominator;
            this.numerator = numerator;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();        // kürzen 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() { //NICHT VERÄNDERN
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() { //NICHT VERÄNDERN
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() { //NICHT VERÄNDERN
        double bruch = (double) numerator/denominator;
        return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() { //NICHT VERÄNDERN
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() { //NICHT VERÄNDERN
            int n = this.numerator;
            int d = this.denominator;
            do {
                while (d < n) {
                    n = n - d;
                }
                while (d > n) {
                    d = d - n;
                }
            } 
            while (d == n);
            if (this.denominator < this.numerator){
                this.numerator = this.numerator/n;
                this.denominator = this.denominator/n; 
            }
            if(this.denominator > this.numerator) {
                this.numerator = this.numerator/d;
                this.denominator = this.denominator/d;
            }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) { //NICHT VERÄNDERN
        int lcm = LCM(this.denominator, f.getDenominator());
        int lcm1 = (lcm / this.denominator);
        int d1 = this.denominator * lcm1;
        int n1 = this.numerator * lcm1;
        int lcm2 = (lcm / f.getDenominator());
        //int d2 = f.getDenominator() * lcm2;
        int n2 = f.getNumerator() * lcm2;
        Fraction fNew = new Fraction(n1 + n2, d1);
        return fNew;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) { //NICHT VERÄNDERN
        int lcm = LCM(this.denominator, f.getDenominator());
        int lcm1 = (lcm / this.denominator);
        int d1 = this.denominator * lcm1;
        int n1 = this.numerator * lcm1;
        int lcm2 = (lcm / f.getDenominator());
        //int d2 = f.getDenominator() * lcm2;
        int n2 = f.getNumerator() * lcm2;
        Fraction fNew = new Fraction(n1 * n2, d1);
        return fNew;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() { //NICHT VERÄNDERN
        if (this.numerator != 0) {
            int nNew = this.denominator;
            int dNew = this.numerator;
            Fraction fNew = new Fraction (nNew, dNew);
            return fNew;
        }
        else {
            Fraction fNew = new Fraction(this.numerator, this.denominator);
            return fNew;
        }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
    
    public Fraction divide(Fraction f) { //NICHT VERÄNDERN

    }*/
}","public class SubwayTest {
    public static void main (String[] args) {
        Subway thomasTheTankEngine = new Subway(3);
        Wagen lok = new Wagen(2, 12938);
        Wagen kohleofen = new Wagen(23, 9);
        thomasTheTankEngine.addWagen(lok);
        thomasTheTankEngine.addWagen(kohleofen);
        int seats = thomasTheTankEngine.getSeats();
        int standingRoom = thomasTheTankEngine.getStandingRoom();
        int capacity = thomasTheTankEngine.getCapacity();
        System.out.println(""Der Zug hat "" + seats + "" Sitze, "" + standingRoom + ""  Stehplätze und "" + capacity + "" Gesamtplätze."" );
        Wagen holzwagen = new Wagen(135, 82);
        Wagen passagierwagen = new Wagen(1,1);
        thomasTheTankEngine.addWagen(holzwagen);
        thomasTheTankEngine.addWagen(passagierwagen);
        for(int i = 0; i < 5; i++) {
            thomasTheTankEngine.removeWagen();
        }
    }
}"
Wieseke,"Jan Malte",wieseke@campus.tu-berlin.de,Beendet,"7. Januar 2022  13:43","7. Januar 2022  18:22","4 Stunden 38 Minuten","19,08","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; void
; static","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""l"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""l"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

	private int numerator, denominator;

	public static int GCD(int x, int y) {
		if (y == 0)
			return x;
		return GCD(y, x % y);
	}


	public static int LCM(int x, int y) {
		return (x * y) / GCD(x, y);
	}

	public Fraction(int numerator, int denominator) {
		if(denominator == 0) {
			denominator ++;
		}
		this.numerator = numerator;
		this.denominator = denominator;
		if(this.denominator < 0) {
			this.denominator = this.denominator * (-1);
			this.numerator = this.numerator * (-1);
		}
		

	}

	public int getDenominator() {
		return denominator / GCD(numerator, denominator);
	}

	public int getNumerator() {
		return numerator / GCD(numerator, denominator);
	}

	public double toDouble() {
		return (double) numerator / denominator;
	}

	public String toString() {
		return numerator + ""/"" + denominator;
	}

	public void shorten() {
		int teiler = GCD(numerator, denominator);
		numerator = numerator / teiler;
		denominator = denominator / teiler;

	}

	public Fraction add(Fraction f) {
		int nenner = denominator;
		int zähler = numerator;
		int temp_nenner = nenner;
		nenner = nenner * f.denominator;
		zähler = zähler * f.denominator;
		f.denominator = f.denominator * temp_nenner;
		f.numerator = f.numerator * temp_nenner;
		zähler = zähler + f.numerator;
		Fraction result =  new Fraction(zähler, nenner);
		result.shorten();
		return result;
		
	}


	public Fraction multiply(Fraction f) {
		int nenner = denominator;
		int zähler = numerator;
		nenner = nenner * f.denominator;
		zähler = zähler * f.numerator;
		Fraction result = new Fraction(zähler, nenner);
		result.shorten();
		return result;
	}

	public Fraction reciprocal() {
		shorten();
		int nenner = denominator;
		int zähler = numerator;
		if(numerator != 0) {
			int temp = nenner;
			nenner = zähler;
			zähler = temp;
		}
		return new Fraction(zähler, nenner);
	}

	public Fraction divide(Fraction f) {
		Fraction result = multiply(f.reciprocal());
		result.shorten();
		return result;
	}

}","public class SubwayTest {
	
	public static void main(String[] args) {
		Subway ubahn = new Subway(3);

		Wagen wagen = new Wagen(5, 10);
		Wagen wagen2 = new Wagen(15, 22);


		ubahn.addWagen(wagen);
		ubahn.addWagen(wagen2);
		
		System.out.println(ubahn.getSeats());
		System.out.println(ubahn.getStandingRoom());
		System.out.println(ubahn.getCapacity());

		ubahn.addWagen(wagen);
		ubahn.addWagen(wagen2);
		
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		
		
	}

}"
Lohse,"Clemens Christian",clemens.lohse@campus.tu-berlin.de,Beendet,"7. Januar 2022  14:26","9. Januar 2022  22:48","2 Tage 8 Stunden","5,46","public class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","static
; void","Verhindern, dass Attributswerte gesetzt werden

; Verhindern das Überladen von Methoden
; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"","""","""","""","""","""",""""],[""12"","""","""","""","""","""",""""],[""13"","""","""","""","""","""",""""],[""14"",""0"",""0"",""1"","""","""",""""],[""3(15)"","""","""","""","""","""",""""],[""4(15)"","""","""","""",""1"","""",""""],[""5(15)"","""","""","""","""",""0"",""""],[""6(15)"","""","""","""","""","""",""0""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""","""","""",""""],[""4(17)"","""","""","""",""0"","""",""""],[""5(17)"","""","""","""","""",""0"",""""],[""6(17)"","""","""","""","""","""",""0""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
    	this.numerator = numerator;
    	this.denominator = denominator;
	if (denominator == 0){
    		System.out.println(""Der Nenner darf nicht 0 sein."");
    		System.out.println(""Setze den Bruch auf 0."");
    		numerator = 0;
    		denominator = 1;
  	}else{
    		numerator = numerator;
    		denominator = denominator;
  	}
  	if (denominator < 0){
    		numerator = -numerator;
    		denominator = -denominator;
	}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double ZN = this.numerator/this.denominator;
        return ZN;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = this.numerator+""/""+this.denominator;
        return str;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
	int faktor = GCD(numerator, denominator);
    	numerator = numerator / faktor;
    	denominator = denominator / faktor;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
	int numerator = this.numerator*f.getDenominator() + this.denominator*f.getNumerator();
    	int denominator = this.denominator * f.denominator;
    	shorten();
    	return new Fraction(numerator, denominator);
    }
    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
	int numerator = this.numerator*f.getNumerator();
    	int denominator = this.denominator*f.getDenominator();
    	shorten();
    	return new Fraction(numerator, denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
	if (numerator != 0){
      			numerator = denominator;
      			denominator = numerator;
    	}else{
    	numerator = numerator;
    	denominator = denominator;
    	}
    	return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	numerator = numerator * f.denominator;
	denominator = denominator * f.numerator;
	shorten();
	return new Fraction(numerator, denominator);
    }
    
}",-
Hermanns,Paul-Henri,p.hermanns@campus.tu-berlin.de,Beendet,"7. Januar 2022  17:52","9. Januar 2022  23:59","2 Tage 6 Stunden","9,92","Setter-Methoden haben in der Regel den Rückgabetyp void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void
; static","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Getter und Setter","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden modellieren das Verhalten von Objekten","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""0"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""1"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
        if(denominator<0){
            this.numerator = -numerator;
			this.denominator = -denominator;
		}else if(denominator == 0){
				this.denominator = 1;
			}else{
				this.denominator = denominator;
			}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
		
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return this.numerator;   
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double p = getNumerator();
		double q = getDenominator();
		double pq = p/q;
		return pq;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
      	String ab = this.numerator +""/""+ this.denominator;
		return ab;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int a = GCD(getNumerator(), getDenominator());
		this.numerator = this.numerator/a;
		this.denominator = this.denominator/a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction r = f;
	   if(this.denominator == f.denominator){
			r.numerator = this.numerator + r.numerator;
			return r;
	   }else{
		   r.numerator = this.numerator*r.denominator + r.numerator*this.denominator;
		   r.denominator = LCM(r.denominator, this.denominator);
		   return r;
	   }
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
       Fraction s = f;
	   s.numerator = this.numerator*s.numerator;
	   s.denominator = this.denominator*f.denominator;
	   return s;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		Fraction t = new Fraction(this.numerator, this.denominator);
		if(t.numerator == 0){
			return t;
		}else{
			int u = t.denominator;
			int z = t.numerator;
			t.denominator = z;
			t.numerator = u;
			return t;
		}
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction v = f.reciprocal();
	   v.numerator = v.numerator * this.numerator;
	   v.denominator = v.denominator * this.denominator;
	   return v;
    }
    
}",-
Hother,"Julika Anais",j.hother@campus.tu-berlin.de,Beendet,"7. Januar 2022  21:50","9. Januar 2022  23:37","2 Tage 1 Stunde","18,25","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Getter und Setter","static
; void
; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""","""","""",""""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            denominator = denominator *-1;
            numerator = numerator * -1;
        } else if (denominator == 0) {
            denominator = 1;
        }

        this.numerator = numerator;
        this.denominator = denominator;

        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double zaehler = (double) numerator;
        double nenner = (double) denominator;
        return zaehler/nenner;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt = GCD(this.numerator,this.denominator);
        this.numerator = this.numerator / ggt;
        this.denominator = this.denominator / ggt;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(this.denominator,f.getDenominator());
        int factor1 = lcm / this.denominator;
        int nenner1  = this.numerator * factor1;

        int factor2 = lcm / f.getDenominator();
        int nenner2  = f.getNumerator() * factor2;

        int zaehler =  lcm;

        Fraction fr = new Fraction(nenner1 + nenner2, zaehler);

        return fr;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
       int neuerNenner = this.numerator*f.getNumerator();
       int neuerZaehler = this.denominator*f.getDenominator();
       Fraction fr = new Fraction(neuerNenner, neuerZaehler);
       return fr;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
      if( this.numerator == 0) {
        Fraction fr = new Fraction(this.numerator, this.denominator);
        return fr;
      }
      int neuerNenner = this.denominator;
    int neuerZaehler = this.numerator;
    Fraction fr = new Fraction(neuerNenner, neuerZaehler);
    return fr;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction kehrF = reciprocal();
       int neuerNenner =kehrF.getDenominator() * f.getDenominator();
       int neuerZaehler = kehrF.getNumerator() * f.getNumerator();
       Fraction fr = new Fraction(neuerNenner, neuerZaehler);
       return fr;
    }

}","public class SubwayTest {
    public static void main(String args[]){
        Subway subway = new Subway(3);
        Wagen wagen1 = new Wagen(60,10); 
        Wagen wagen2 = new Wagen(2,78);
        subway.addWagen(wagen1);
        subway.addWagen(wagen2);


        System.out.println(subway.getSeats());
        System.out.println(subway.getStandingRoom());
        System.out.println(subway.getCapacity());

        Wagen wagen3 = new Wagen(12,100); 
        Wagen wagen4 = new Wagen(34,8);
        subway.addWagen(wagen3);
        subway.addWagen(wagen4);

        subway.removeWagen();
        subway.removeWagen();
        subway.removeWagen();
        subway.removeWagen();
        subway.removeWagen();
    }


    
}"
Sezen,Alper,sezen@campus.tu-berlin.de,Beendet,"8. Januar 2022  10:50","9. Januar 2022  23:22","1 Tag 12 Stunden","3,83","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Object o);
; In Objektmethoden können lokale Variablen deklariert werden","Setter-Methoden haben in der Regel den Rückgabetyp void","private
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""",""0"","""","""","""",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""",""0"","""","""","""",""""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"","""","""","""","""","""",""""],[""20"","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        int numerator = getNumerator();
		int denominator = getDenominator();
		
		if (denominator < 0) {
			denominator *= -1;
		}
		else if (denominator == 0) {
			denominator += 1;
		}
		else {
			return denominator
		}
		
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator;
		return (double) denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		getNumerator();
		getDenominator();
        Terminal.println(numerator+""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		getNumerator();
		getDenominator();
        int ggt = LCM(numerator, denominator);
		numerator /= ggt;
		denominator /= ggt;
		return numerator;
		return denominator;
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		getNumerator();
		getDenominator();
		return ((numerator/denominator) * f);
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		getNumerator();
		getDenominator();
		
		if (Numerator == 0) {
			return numerator;
			return denominator;
		}
		else {
			numerator = denominator;
			denominator = numerator;
		}
		
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       getNumerator();
	   getDenominator();
	   reciprocal(f);
	   return ((numerator/denominator)*f);
    }
    
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest {
	
	public static void main(String[] args) {
		Subway s1 = new Subway(3);
		s1.addWagen(5, 8);
		s1.addWagen(2,6);
		s1.getCapazity();
		s1.addWagen(9,7);
		s1.addWagen(7,1);
		s1.removeWagen();
		s1.removeWagen();
		s1.removeWagen();
		s1.removeWagen();
		s1.removeWagen();
	}
}"
Klein,Johannes,j.klein.3@campus.tu-berlin.de,Beendet,"8. Januar 2022  13:50","9. Januar 2022  23:59","1 Tag 10 Stunden","4,67","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}",void,"Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""0"",""0"",""1""],[""4(15)"","""","""","""",""1"",""0"",""1""],[""5(15)"","""","""","""",""1"",""0"",""0""],[""6(15)"","""","""","""",""1"",""1"",""0""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"",""1"",""0"",""0"","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""1"",""0"",""0""],[""4(17)"","""","""","""",""0"",""0"",""0""],[""5(17)"","""","""","""",""0"",""0"",""0""],[""6(17)"","""","""","""",""0"",""0"",""0""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"",""0"",""0"",""0"","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
    
}",-
Basin,Yannic,yannic.basin@campus.tu-berlin.de,Beendet,"8. Januar 2022  18:13","8. Januar 2022  21:36","3 Stunden 23 Minuten","20,00","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		
		if (this.denominator == 0) {
			this.denominator = 1;
		}
		
		shorten();
		
        
		if (this.denominator < 0) {
			this.numerator *= -1;
			this.denominator *= -1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return numerator / (double) denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(numerator, denominator);
		numerator /= teiler;
		denominator /= teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int vielF = LCM(denominator, f.getDenominator());
	   
	   int numerator1 = numerator * (vielF / denominator);
	   int denominator1 = denominator * (vielF / denominator);
	   
	   int numerator2 = f.getNumerator() * (vielF / f.getDenominator());
	   
	   return new Fraction(numerator1+numerator2, denominator1);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.getNumerator(), denominator*f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator != 0) {
		   return new Fraction(denominator, numerator);
	   }
	   return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction kehr = f.reciprocal();
		return new Fraction(numerator * kehr.numerator, denominator * kehr.denominator);
    }
    
}","public class SubwayTest {
	public static void main(String[] args) {
		Subway uBahn = new Subway(3);
		
		uBahn.addWagen(new Wagen(50, 80));
		uBahn.addWagen(new Wagen(60, 70));
		
		System.out.println(uBahn.getSeats());
		System.out.println(uBahn.getStandingRoom());
		System.out.println(uBahn.getCapacity());
		
		uBahn.addWagen(new Wagen(30, 100));
		uBahn.addWagen(new Wagen(65, 65));
		
		uBahn.removeWagen();
		uBahn.removeWagen();
		uBahn.removeWagen();
		uBahn.removeWagen();
		uBahn.removeWagen();
	}
}"
Schmid,Maximilian,maximilian.schmid@campus.tu-berlin.de,Beendet,"9. Januar 2022  00:05","9. Januar 2022  23:32","23 Stunden 26 Minuten","19,75","Objektmethoden können überladen werden
; Objektmethoden modellieren das Verhalten von Objekten
; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","void
; static
; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""",""0"","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if (denominator < 0){
			denominator = -denominator;
			numerator = -numerator;
		}
		
		if (denominator == 0){
			denominator = 1;
		}
		
        this.numerator = numerator;
		this.denominator = denominator;
		
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double num = this.numerator;
		double den = this.denominator;
        double bruch = num / den;
		return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s1 = this.numerator + ""/"" + this.denominator;
		return s1;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator / gcd;
		this.denominator = this.denominator / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int newN;
		int newD;
		
       newN = this.numerator * f.denominator;
	   newD = this.denominator * f.denominator;
	   
	   f.numerator = f.numerator * this.denominator;
	   
	   newN = f.numerator + newN;
	   Fraction newF = new Fraction(newN, newD);
	   return newF;
	   
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int num = this.numerator * f.numerator;
		int den = this.denominator * f.denominator;
		
		Fraction newF = new Fraction(num,den);
		return newF;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		int den = this.denominator;
		int num = this.numerator;
       if (this.numerator != 0){
		   //return (this.denominator / this.numerator);
		   Fraction newF = new Fraction(den, num);
		   return newF;
	   } else {
		   //return (this.numerator / this.denominator);
		   Fraction newF = new Fraction(num, den);
		   return newF;
	   }
	   
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction reci = f.reciprocal();
	   Fraction multi = multiply(reci);
	   return multi;
    }
	
}","public class SubwayTest{
	public static void main(String[] args){
		Subway ubahn = new Subway(3);
		Wagen wagen1 = new Wagen(5,6);
		Wagen wagen2 = new Wagen(7,8);
		ubahn.addWagen(wagen1);
		ubahn.addWagen(wagen2);
		Terminal.println(ubahn.getSeats());
		Terminal.println(ubahn.getStandingRoom());
		Terminal.println(ubahn.getCapacity());
		ubahn.addWagen(wagen1);
		ubahn.addWagen(wagen2);
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
	}
}"
Diao,Yiwei,yiwei.diao@campus.tu-berlin.de,Beendet,"9. Januar 2022  14:30","9. Januar 2022  22:23","7 Stunden 52 Minuten","19,17","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","void
; static
; private","In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""50"",""51"",""52""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""50"",""""],[""7(15)"","""","""","""",""-"",""-"",""-""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""50"",""51"",""52""],[""4(17)"",""0"","""","""","""","""",""""],[""5(17)"","""","""","""","""","""",""""],[""6(17)"","""","""","""","""",""50"",""""],[""7(17)"","""","""","""",""-"",""-"",""-""],[""17"","""","""","""","""","""",""""],[""18"","""","""","""","""","""",""""],[""19"",""-"",""-"",""-"","""","""",""""]]","public class Fraction {

    private int numerator, denominator;
    
    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
 //Beginn der Aufgabe  
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also mathematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Methode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(denominator < 0) {
		this.numerator = -numerator;
		this.denominator = -denominator;
	}
	else if(denominator == 0) {
		this.numerator = numerator;
		this.denominator = 1;	
	}
	else {
		this.numerator = numerator;
		this.denominator = denominator;
	}
	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = """";
	str = this.numerator+""/""+this.denominator;
	return str;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int i = GCD(this.numerator, this.denominator);
	this.numerator = this.numerator / i;
	this.denominator = this.denominator / i;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       	Fraction a = new Fraction(1, 1);
	a.denominator = LCM(this.denominator, f.denominator);
	int i = a.denominator / this.denominator;
	int j = a.denominator / f.denominator;
	a.numerator = i * this.numerator + j * f.numerator;
	a.shorten();
	return a;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction m = new Fraction(1, 1);
	m.numerator = this.numerator * f.numerator;
	m.denominator = this.denominator * f.denominator;
	m.shorten();
	return m;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       	Fraction r = new Fraction(1, 1);
	if(this.numerator == 0)
		r = this;
	else {
		r.numerator = this.denominator;
		r.denominator = this.numerator;
	}
	return r;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       	Fraction d = new Fraction(1, 1);
	d = f.reciprocal();
	d = this.multiply(d);
	return d;
    }
    
}","//Hier soll die Klasse SubwayTest stehen!
public class SubwayTest {
	public static void main(String[] args) {

		Subway sw = new Subway(3);
		Wagen erst = new Wagen(15, 20);
		Wagen zweit = new Wagen(18, 25);
		sw.addWagen(erst);
		sw.addWagen(zweit);
		System.out.println(""gesamte Sitzplätze: ""+sw.getSeats()+""\ngesamte Stehplätze: ""+sw.getStandingRoom()+""\ngesamte Plätze: ""+sw.getCapacity());
		Wagen dritt = new Wagen(14, 19);
		Wagen viert = new Wagen(17, 24);
		sw.addWagen(dritt);
		sw.addWagen(viert);
		for(int i = 0; i < 5; i++)
			sw.removeWagen();
	}
}"
Fung,"Wendy Poju",w.fung@campus.tu-berlin.de,Beendet,"9. Januar 2022  20:00","9. Januar 2022  23:59","3 Stunden 58 Minuten","11,08","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","private
; void","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten
; Objektmethoden können überladen werden
; In Objektmethoden können lokale Variablen deklariert werden","[[""10"",""-"",""-"",""-"",""-"",""-"",""-""],[""11"",""0"","""","""","""","""",""""],[""12"","""",""0"","""","""","""",""""],[""13"","""","""",""1"","""","""",""""],[""14"","""","""","""","""","""",""""],[""3(15)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""1"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""",""links"",""""],[""7(15)"","""","""","""",""undef"",""undef"",""undef""],[""15"","""","""","""","""","""",""""],[""16"","""","""","""","""","""",""""],[""3(17)"","""","""","""",""l"",""m"",""r""],[""4(15)"",""0"","""","""","""","""",""""],[""5(15)"","""","""",""0"","""","""",""""],[""6(15)"","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""],["""","""","""","""","""","""",""""]]","public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0){
            denominator = -denominator;
            numerator = (-1)*numerator;
        }
        if (denominator == 0){
            denominator = 1;
        }
        this.numerator = numerator;
        this.denominator = denominator;

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator / (double) denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
       int gcd;
        if (denominator > numerator){
             gcd = GCD(denominator, numerator);
        } else {
             gcd = GCD(numerator, denominator);
        }
        denominator = denominator / gcd;
        numerator = numerator / gcd;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm;
        if (denominator > f.getDenominator()){
            lcm = LCM(denominator, f.getDenominator());
        } else {
            lcm = LCM(f.getDenominator(), denominator);
        }
       int multiplierA = lcm / denominator;
        int multiplierB = lcm / f.getDenominator();
        return new Fraction(numerator * multiplierA + f.getNumerator() * multiplierB, lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
         return new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0) {
            return new Fraction(denominator, numerator);
        }
        return new Fraction(numerator, denominator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }
    
}",-
Khatiwada,Aayush,khatiwada@campus.tu-berlin.de,Beendet,"9. Januar 2022  21:55","9. Januar 2022  23:40","1 Stunde 45 Minuten","15,66","In Objektmethoden können lokale Variablen deklariert werden
; Objektmethoden können überladen werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","void
; private
; static","Zugriff auf private Attribute ermöglichen","Der Name einer Getter-Methode muss vom Schema getAttributsname sein",-,"public class Fraction {

    private int numerator, denominator;

    /**
     * Gibt den größten gemeinsamen Teiler der beiden Argumente (Greatest Common Divider) zurück.
     */
    public static int GCD(int x, int y) {
        if (y == 0) return x;
        return GCD(y, x % y);
    }

    /**
     * Gibt das kleinste gemeinsame Vielfache der beiden Argumente (Lowest Common Multiple) zurück.
     */
    public static int LCM(int x, int y) {
        return (x * y) / GCD(x, y);
    }
    //Beginn der Aufgabe
    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if (denominator < 0) {
            this.numerator = -1 * numerator;
            this.denominator = -1 * denominator;
        }
        else if (denominator == 0) {
            this.denominator = 1;
        }
        else this.denominator = denominator;
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double GZ = ((double) this.numerator/(double)this.denominator);
        return GZ;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s ="""";
        s = s + Integer.toString(this.numerator) +""/""+Integer.toString(this.denominator);
        return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int GCD = Fraction.GCD(this.denominator,this.numerator);
        this.numerator = this.numerator/GCD;
        this.denominator = this.denominator/GCD;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = Fraction.LCM(this.denominator,f.denominator);
        int numerator = this.numerator* (lcm / this.denominator) + f.numerator* (lcm / f.denominator);
        Fraction f0 = new Fraction(numerator,lcm);
        f0.shorten();
        return f0;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int a = this.numerator*f.numerator;
        int b = this.denominator*f.denominator;
        Fraction f0 = new Fraction(a,b);
        f0.shorten();
        return f0;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator == 0)  return new Fraction(this.numerator,this.denominator);

        Fraction f0 = new Fraction(this.denominator,this.numerator);
        return f0;
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction f0 = new Fraction(this.numerator,this.denominator);
       Fraction x = f0.multiply(f.reciprocal());
        x.shorten();
        return x;
    }


}","public class SubwayTest {
    public static void main(String[] args) {
        Subway U_bahn = new Subway(3);
        Wagen w1 = new Wagen(5,10);
        Wagen w2 = new Wagen(7,14);
        Wagen w3 = new Wagen(1 ,14);
        Wagen w4 = new Wagen(4,14);

        U_bahn.addWagen(w1);
        U_bahn.addWagen(w2);

        System.out.println(U_bahn.getSeats());
        System.out.println(U_bahn.getStandingRoom());
        System.out.println(U_bahn.getCapacity());

        U_bahn.addWagen(w3);
        U_bahn.addWagen(w4);

        for (int i = 0; i < 5;i++) {
            U_bahn.removeWagen();
        }
    }
}"
