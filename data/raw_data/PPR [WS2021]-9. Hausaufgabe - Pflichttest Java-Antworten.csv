Nachname,Vorname,E-Mail-Adresse,Status,"Begonnen am",Beendet,"Verbrauchte Zeit","Bewertung/20,00","Antwort 1","Antwort 2","Antwort 3","Antwort 4","Antwort 5","Antwort 6","Antwort 7","Antwort 8","Antwort 9"
Wolf,"Johannes Peter",j.wolf.1@campus.tu-berlin.de,Beendet,"15. Januar 2021  07:58","20. Januar 2021  18:26","5 Tage 10 Stunden","19,55","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","void

; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: 50; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: 50; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator>0) {	
			this.numerator=numerator;
			this.denominator=denominator;
			shorten();
		}
		if (denominator<0) {
			this.numerator=numerator-2*numerator;
			this.denominator=denominator-2*denominator;
			shorten();
		}
		if (denominator==0) {
			this.numerator=numerator;
			this.denominator=1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)getNumerator()/(double)getDenominator();
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return  (this.numerator+""/""+this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        if (numerator<0) {
			numerator = numerator*-1;
			int ggt=GCD(numerator,denominator);
			this.numerator=(numerator/ggt*-1);
			this.denominator=denominator/ggt;
		}
		 if (numerator>0) {
			
			int ggt=GCD(numerator,denominator);
			this.numerator=numerator/ggt;
			this.denominator=denominator/ggt;
		}
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       if (this.denominator!=f.denominator){
			int newnumerator = (this.getNumerator()*f.getDenominator()+f.getNumerator()*this.getDenominator());
			int lcm = LCM(this.getDenominator(),f.getDenominator());
			if (this.denominator/lcm==1){
				return new Fraction (this.getNumerator()+f.getNumerator()*this.getDenominator()/f.getDenominator(),lcm);
			}
			else if (f.denominator/lcm==1){
				return new Fraction (this.getNumerator()*f.getDenominator()/this.getDenominator()+f.getNumerator(),lcm);
			}
			return new Fraction (newnumerator,lcm);
		} 	
		int newnumerator = (this.getNumerator()+f.getNumerator());
		int newdenominator = this.denominator;
		return new Fraction (newnumerator,newdenominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction (this.getNumerator()*f.getNumerator(),this.getDenominator()*f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator!=0){
		   return new Fraction (getDenominator(),getNumerator());
	    } return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }","public class SubwayTest {
	public static void main (String[] args) {
		Subway u9 = new Subway (3);
		
		u9.addWagon(new Wagon (25,30));
		u9.addWagon(new Wagon (55,45));
		
		System.out.println(u9.getSeats());
		System.out.println(u9.getStandingRoom());
		System.out.println(u9.getCapacity());
		
		u9.addWagon(new Wagon (50,80));
		u9.addWagon(new Wagon (55,40));
		
		u9.removeWagon ();
		u9.removeWagon ();
		u9.removeWagon ();
		u9.removeWagon ();
		u9.removeWagon ();
	}
}"
Tesch,Johanna,j.tesch@campus.tu-berlin.de,Beendet,"15. Januar 2021  11:43","16. Januar 2021  19:48","1 Tag 8 Stunden","19,23","void

; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: 1; Teil 59: %; Teil 60: %; Teil 61: l; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: m; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: 0; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: l; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also mathematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) { 
		if(denominator < 0) {
			this.numerator = numerator * -1;
			this.denominator = denominator * -1;
		}
		else if(denominator == 0) { 
			this.denominator = 1;
			this.numerator = numerator;
		}
		else {
			this.numerator = numerator;
			this.denominator = denominator;
		}
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() { 
		double result = (double)this.numerator / this.denominator;
        return result;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() { 
		String result = numerator + ""/"" + denominator;
        return result;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() { 
		int gcd = GCD(numerator, denominator);
		numerator = numerator / gcd;
		denominator = denominator / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) { 
		Fraction result = new Fraction(1, 1);
		int lcm = LCM(this.denominator, f.denominator);
		int factor1 = (lcm / this.denominator);
		int factor2 = (lcm / f.denominator);
		result.numerator = ((this.numerator * factor1) + (f.numerator * factor2));
		result.denominator = lcm;
	   result.shorten();
	   return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) { 
        Fraction result = new Fraction(1, 1);
		result.numerator = this.numerator * f.numerator;
		result.denominator = this.denominator * f.denominator;
		return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() { 
       Fraction result = new Fraction(1, 1);
	   if(this.numerator != 0) {
			result.numerator = this.denominator;
			result.denominator = this.numerator;
	   }
	   else {
		   result.numerator = this.numerator;
		   result.denominator = this.denominator;
	   }
	   if(result.denominator < 0) {
			result.numerator *= -1;
			result.denominator *= -1;
	   }
	   return result;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) { 
	   Fraction result = new Fraction(1, 1);
	   result = this.multiply(f.reciprocal());
	   if(result.denominator < 0) {
			result.denominator *= -1;
			result.numerator *= -1;
	   }
	   result.shorten();
	   return result; 
    }","public class SubwayTest {
	
	public static void main(String[] args) {
		
		Subway u2 = new Subway(3);
		u2.addWagon(new Wagon(25, 30));
		u2.addWagon(new Wagon(30, 40));
		System.out.println(u2.countWagons()+"" Wagons\n""+
							u2.getSeats()+"" Seats\n""+
							u2.getStandingRoom()+"" Standing Room\n""+
							u2.getCapacity()+"" Capacity"");
		u2.addWagon(new Wagon(15, 20));
		u2.addWagon(new Wagon(22, 32));
		for(int i = 0; i<5; i++) {
			u2.removeWagon();
		}
	}
	
}"
Lietz,"Alexander Pascal",a.lietz@campus.tu-berlin.de,Beendet,"15. Januar 2021  18:43","21. Januar 2021  16:39","5 Tage 21 Stunden","17,53","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","private
; void","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 50(11); Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 51(12); Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 52(12); Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: 1; Teil 72: %; Teil 73: 0; Teil 74: -; Teil 75: -; Teil 76: -; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: 0; Teil 120: %; Teil 121: %; Teil 122: -; Teil 123: -; Teil 124: -; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest {

    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        u9.addWagon(new Wagon(25, 30));
        u9.addWagon(new Wagon(55, 45));
        System.out.println(
                u9.countWagons() + "" Wagons\n"" +
                        u9.getSeats() + "" Seats\n"" +
                        u9.getStandingRoom() + "" Standing Room\n"" +
                        u9.getCapacity() + "" Capacity""
        );
        u9.addWagon(new Wagon(20, 35));
        u9.addWagon(new Wagon(12, 33));
        for (int i = 0; i < 5; i++) u9.removeWagon();
        System.out.println(
                u9.countWagons() + "" Wagons\n"" +
                        u9.getSeats() + "" Seats\n"" +
                        u9.getStandingRoom() + "" Standing Room\n"" +
                        u9.getCapacity() + "" Capacity""
        );
    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if (denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        }else if (denominator < 0){
            this.denominator = Math.abs(denominator); //Nenner positiv machen
            this.numerator = -1 * numerator;
        }else {
            this.denominator = denominator;
            this.numerator = numerator;
        }
        shorten();

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator / denominator;

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */

    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(getNumerator(),getDenominator());
        gcd = ( Math.abs(gcd));


        this.numerator = getNumerator() / gcd;
        this.denominator = getDenominator() / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {


        Fraction output = new Fraction(this.numerator,this.denominator);
        Fraction copyInput = new Fraction(f.numerator,f.denominator);
        Fraction tmp = new Fraction(0,0);

        if (output.denominator == copyInput.denominator){
            int zaehler = output.numerator + copyInput.numerator;
             tmp = new Fraction(zaehler,output.denominator);

        }else {
            int lcm = LCM(output.denominator, copyInput.denominator); // kleinstes gemeinsames vielfaches finden
            int erweiterungOutput = lcm / output.denominator;
            int erweiterungF = lcm / copyInput.denominator;

            int outputZaehler = output.numerator * erweiterungOutput;
            int copyInputZaehler = copyInput.numerator * erweiterungF;

            int zaehler = outputZaehler + copyInputZaehler;
             tmp = new Fraction(zaehler, lcm);
        }


        return tmp;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

        Fraction temp = new Fraction(f.numerator,f.denominator);
        Fraction copyInput = new Fraction(this.numerator,this.denominator);

        int zaehler = temp.numerator * copyInput.numerator;
        int nenner = temp.denominator * copyInput.denominator;

        Fraction output = new Fraction(zaehler,nenner);

        return output;

    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction output = new Fraction(this.numerator,this.denominator);

        if (output.numerator != 0){
            output.numerator = denominator;
            output.denominator = numerator;
        }else{

        }

        return output;

    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {

        Fraction copyInput = new Fraction(this.numerator,this.denominator);
        Fraction temp = new Fraction(f.numerator,f.denominator);

        temp = temp.reciprocal();

        Fraction output = copyInput.multiply(temp);
        output.shorten();


        return output;

    }"
Müller-Hardy,"Finnegan Maximilian",f.mueller-hardy@campus.tu-berlin.de,Beendet,"16. Januar 2021  15:53","22. Januar 2021  10:26","5 Tage 18 Stunden","17,76","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Verhindern das Überladen von Methoden
; Verhindern, dass Attributswerte gesetzt werden

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","private
; static

; void","Getter und Setter","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: -; Teil 10: -; Teil 11: -; Teil 12: -; Teil 13: -; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 0; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","//Hier soll die Klasse UBahnDemo stehen!

public class SubwayTest{

	public static void main(String[] args){
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
			u9.countWagons()+"" Wagons\n""+
			u9.getSeats()+"" Seats\n""+
    		u9.getStandingRoom()+"" Standing Room\n""+
    		u9.getCapacity()+"" Capacity""
		);
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++) u9.removeWagon();
		System.out.println(
    		u9.countWagons()+"" Wagons\n""+
		    u9.getSeats()+"" Seats\n""+
		    u9.getStandingRoom()+"" Standing Room\n""+
		    u9.getCapacity()+"" Capacity""
		);
	}
}","public Fraction(int numerator, int denominator) {

        
        this.numerator = numerator;
        this.denominator = denominator;

        
        if (numerator > 0 && denominator > 0){
            this.numerator = numerator;
            this.denominator = denominator;
        }
        
        if (denominator == 0){
            this.numerator = numerator;
            this.denominator = 1;              
        }
        
        if (numerator < 0 && denominator < 0){
            this.numerator = numerator * (-1);
            this.denominator = denominator * (-1);
        }

        if (numerator > 0 && denominator < 0){
            this.denominator = denominator * (-1);
            this.numerator = numerator * (-1);
        }

        if (numerator < 0 && denominator > 0){
            this.denominator = denominator;
            this.numerator = numerator;
        }



        this.shorten();


    }

    /**
    * Gibt den denominator zurueck.
    */
    public int getDenominator() {
        return this.denominator;
    }

    /**
    * Gibt den numerator zurueck.
    */
    public int getNumerator() {
        return this.numerator;
    }

    /**
    * Gibt den Bruch als Gleitkommazahl zurueck.
    */
    public double toDouble() {
        int top = this.getNumerator();
        int bottom = this.getDenominator();

        double topdouble = top;
        double bottomdouble = bottom;

        double decimal = topdouble/bottomdouble;

        return decimal;

    }

    /**
    * Gibt einen String im Format
    * ""Zaehler/Nenner"" zurueck.
    */
    public String toString() {
        String str = this.getNumerator()+""/""+this.getDenominator();
        return str;
    }

    /**
    * Kuerzt (vereinfacht) den Bruch.
    */
    public void shorten() {

        int divisor = GCD(this.getNumerator(), this.getDenominator());
        int top = 1;
        int bottom = 1;

        if(divisor < 0){
            divisor = divisor * (-1);
        }
        
        if (this.numerator == 0){
            top = 0;
            bottom = this.getDenominator();
        }

        else if(this.denominator == 0){
            top = this.getNumerator();
            bottom = this.getDenominator();
        }

        else {
            top = this.getNumerator()/divisor;
            bottom = this.getDenominator()/divisor;
        }
        this.numerator = top;
        this.denominator = bottom;
    }

    /**
    * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
    */
    public Fraction add(Fraction f) {
        int top1 = this.getNumerator();
        int top2 = f.getNumerator();
        int bottom1 = this.getDenominator();
        int bottom2 = f.getDenominator();

        int top1new = top1*bottom2;
        int top2new = top2*bottom1;
    
        int topfinal = top1new + top2new;

        int newbottom = bottom1*bottom2;

        Fraction frac_add = new Fraction(topfinal, newbottom);

        return frac_add;
    }

    /**
    * Multipliziert mit dem uebergebenen Bruch.
    */
    public Fraction multiply(Fraction f) {
        int top1 = this.getNumerator();
        int top2 = f.getNumerator();
        int bottom1 = this.getDenominator();
        int bottom2 = f.getDenominator();

        int newtop = top1*top2;
        int newbottom = bottom1*bottom2;

        Fraction frac_mult = new Fraction(newtop, newbottom);

        return frac_mult;
    }

    /**
    * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
    * Sonst wird der Bruch unveraendert zurueckgegeben.
    */
    public Fraction reciprocal() {
        int top = this.getNumerator();
        int bottom = this.getDenominator();
        //System.out.println(""value in recip"");
        //System.out.println(top);
        //int newtop = 1;
        //int newbottom = 1;
            
        if(this.numerator == 0){
            top = this.getNumerator();
            bottom = this.getDenominator();
        }

        if (this.denominator != 0){
            top = this.getDenominator();
            bottom = this.getNumerator();
        }



        Fraction frac_recip = new Fraction(top, bottom);
        return frac_recip;
    }

    /**
    * Dividiert durch den uebergebenen Bruch 
    * (unter Verwendung von Kehrwert und Multiplikation).
    */
    public Fraction divide(Fraction f) {
        int top1 = this.getNumerator();
        int top2 = f.getNumerator();
        int bottom1 = this.getDenominator();
        int bottom2 = f.getDenominator();

        int newtop = top1*bottom2;
        int newbottom = top2*bottom1;

        Fraction frac_div = new Fraction(newtop, newbottom);

        return frac_div;

    }"
Todorovski,Adrian,adrian.todorovski@campus.tu-berlin.de,Beendet,"17. Januar 2021  17:00","24. Januar 2021  21:11","7 Tage 4 Stunden","12,98","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","static

; void

; private","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: %; Teil 9: 0; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 4(11); Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 5(11); Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 6(11); Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 12; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 4(12); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(12); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(12); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 13; Teil 64: %; Teil 65: 1; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 4(13); Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 5(13); Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 6(13); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 14; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 14; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 15; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 16; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public Fraction(int numerator, int denominator){
		this.numerator = numerator;
		this.denominator = denominator;
		
		if(this.denominator < 0){
			this.denominator = this.denominator * (-1);
			this.numerator = this.numerator * (-1);
		}
		else if(this.denominator == 0){
			this.denominator = 1;
		}
		else{
			this.numerator = numerator;
			this.denominator = denominator;
		}
		shorten();
	}
	public int getDenominator(){
		return this.denominator;
	}
	public int getNumerator(){
		return this.numerator;
	}
	
	public double toDouble(){
	double x = (double)this.numerator;
	double y = (double)this.denominator;
	double gk = x/y;
	return gk;
	}
	


	public String toString(){
		
		return this.numerator+""/""+this.denominator;
	}
	public void shorten(){
		int factor = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator / factor;
		this.denominator = this.denominator / factor;
		if(this.denominator < 0){
			this.numerator = this.numerator *(-1);
			this.denominator = this.denominator *(-1);
		}
	}
	public Fraction add(Fraction f){
		Fraction addiert = new Fraction(this.getNumerator(),this.getDenominator());
		int lcm = LCM(f.getDenominator(), addiert.getDenominator());
		int faktorf = lcm / f.getDenominator();
		f.numerator = f.getNumerator() * faktorf;
		f.denominator = f.getDenominator() * faktorf;
		int faktora = lcm / addiert.getDenominator();
		addiert.denominator = addiert.getDenominator() * faktora;
		addiert.numerator = addiert.getNumerator() * faktora;
		addiert.numerator = addiert.getNumerator() + f.getNumerator();
		addiert.denominator = addiert.getDenominator();
		addiert.shorten();
		return addiert;
	}
	public Fraction	multiply(Fraction f){
		Fraction multi = new Fraction(this.getNumerator(),this.getDenominator());
		multi.numerator = multi.getNumerator() * f.getNumerator();
		multi.denominator = multi.getDenominator() * f.getDenominator();
		multi.shorten();
		return multi;
	}
	 public Fraction reciprocal(){
		Fraction recip = new Fraction(this.getNumerator(),this.getDenominator());
		if(recip.numerator == 0){
			return this;
		}
		else if(recip.numerator != 0){
			int x = this.getNumerator();
			recip.numerator = this.getDenominator();
			recip.denominator = x;
			recip.shorten();
			
		}
		return recip;
	}
		
		public Fraction divide(Fraction f){
			Fraction div = new Fraction(this.getNumerator(),this.getDenominator());
			return div.multiply(f.reciprocal());
}","public class UBahnDemo {

	public static void main(String[] args) {
	Subway u9 = new Subway(3);
	u9.addWagon(new Wagon(25, 30));
	u9.addWagon(new Wagon(55, 45));
	
	System.out.println(u9.countWagons()+"" Wagons\n""+u9.getSeats()+"" Seats\n""+u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");
	
	u9.addWagon(new Wagon(20, 35));
	u9.addWagon(new Wagon(12, 33));
		
		for(int i = 0; i<5; i++) {
		u9.removeWagon();
		}
	
	System.out.println(u9.countWagons()+"" Wagons\n""+u9.getSeats()+"" Seats\n""+u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

	
	}


}"
Wontorra,Lara,lara.wontorra@campus.tu-berlin.de,Beendet,"17. Januar 2021  17:18","24. Januar 2021  11:21","6 Tage 18 Stunden","0,50","class
; void","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein",Interfaces,"class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Verhindern das Überladen von Methoden
; Zugriff auf private Attribute ermöglichen","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:",-,-
Korkmaz,Asena,asena.korkmaz@campus.tu-berlin.de,Beendet,"17. Januar 2021  17:54","24. Januar 2021  22:00","7 Tage 4 Stunden","18,48","Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","private
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: undef; Teil 5: undef; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator < 0){
            this.numerator = numerator * -1;
            this.denominator = denominator * -1;
        }
        else if(denominator == 0){
            this.numerator = numerator;
            this.denominator = 1;
        }
        else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator +""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        /*return new Fraction(numerator * f.denominator + denominator * f.numerator, denominator * f.denominator);*/
        int lcm = LCM(denominator, f.denominator);
        int firstSummandMultiplier = lcm / denominator;
        int secondSummandMultiplier = lcm / f.denominator;
        return new Fraction(numerator*firstSummandMultiplier + f.numerator * secondSummandMultiplier, lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator* f.numerator, denominator*f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0)
            return new Fraction(denominator, numerator);
        else
            return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    }","public class SubwayTest {
    public static void main(String[] args) {
        Subway u5 = new Subway(3);
        u5.addWagon(new Wagon(25,30));
        u5.addWagon(new Wagon(30,35));
        System.out.println(
            u5.countWagons()+ "" Wagons\n""+
            u5.getSeats()+ "" Seats\n""+
            u5.getStandingRoom()+ "" Standing Room\n""+
            u5.getCapacity()+ "" Capacity""
        );

        u5.addWagon(new Wagon(35,40));
        u5.addWagon(new Wagon(40,45));
        for(int i=0; i<5;i++) u5.removeWagon();
        System.out.println(
            u5.countWagons()+ "" Wagons\n""+
            u5.getSeats()+ "" Seats\n""+
            u5.getStandingRoom()+ "" Standing Room\n""+
            u5.getCapacity()+ "" Capacity""
        );
    }
}"
Felchner,"Felix Reinhard",f.felchner@campus.tu-berlin.de,Beendet,"17. Januar 2021  19:00","23. Januar 2021  18:40","5 Tage 23 Stunden","18,97","Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden","void

; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Verhindern, dass Attributswerte gesetzt werden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	
	
	
	
    public Fraction(int numerator, int denominator) {
    	if (denominator < 0) { 
    		this.denominator = Math.abs(denominator); 
    		this.numerator = -numerator;
    	} else if (denominator == 0) { 
    		this.denominator = 1; 
    		this.numerator = numerator;
    	} else {
    	    this.numerator = numerator;
            this.denominator = denominator;
    	}
    	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    	int fickdichppr = numerator;
    	numerator = numerator/GCD(numerator, denominator);
    	denominator = denominator/GCD(fickdichppr, denominator);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int denomExt = denominator * f.getDenominator();
       int num1 = numerator * f.getDenominator();
       int num2 = f.getNumerator() * denominator;
       return new Fraction(num1 + num2, denomExt);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	if (numerator != 0) {
    		int numNew = denominator;
    		denominator = numerator;
    		numerator = numNew;
    	}
    	return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	f.reciprocal();
    	return this.multiply(f);
    }","public class SubwayTest {

	public static void main(String[] args) {

		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
			    u9.countWagons()+"" Wagons\n""+
			    u9.getSeats()+"" Seats\n""+
			    u9.getStandingRoom()+"" Standing Room\n""+
			    u9.getCapacity()+"" Capacity""
			);
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++) u9.removeWagon();
	}

}"
Niewiarra,"Julian Baptiste",niewiarra@campus.tu-berlin.de,Beendet,"17. Januar 2021  19:08","24. Januar 2021  23:59","7 Tage 4 Stunden","18,84","private
; static

; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: 50; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: 51; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: 52; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: 0; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: 0; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator == 0) {denominator = 1;}
		if(denominator < 0) {
			denominator = denominator * (-1);
			numerator = numerator * (-1);
		}
		
		this.numerator = numerator;
		this.denominator = denominator;
		
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator / (double)this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator +""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int shorty = Fraction.GCD(this.numerator,this.denominator);
		if(shorty > 1){
			this.numerator = this.numerator / shorty;
			this.denominator = this.denominator / shorty;
		}
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction f1 = new Fraction((this.numerator * f.denominator) + (f.numerator * this.denominator), this.denominator * f.denominator);
	   f1.shorten();
	   return f1;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction f1 = new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
		f1.shorten();
		return f1;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(this.numerator != 0){
		   return new Fraction(this.denominator, this.numerator);
	   }
	   else{
		   return new Fraction(this.numerator,this.denominator);
	   }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction f1 = new Fraction(this.numerator, this.denominator);
		Fraction f1a = f1.multiply(f.reciprocal());
		f1a.shorten();
        return f1a;
    }","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest{
	
	public static void main(String[] args){
		
		Subway U6 = new Subway(3);
		
		U6.addWagon(new Wagon(25,30));
		U6.addWagon(new Wagon(55,45));
		
		System.out.println(
			U6.countWagons()+"" Wagons\n""+
			U6.getSeats()+"" Seats\n""+
			U6.getStandingRoom()+"" Standing Room\n""+
			U6.getCapacity()+"" Capacity"");
		
		U6.addWagon(new Wagon(20,35));
		U6.addWagon(new Wagon(12, 33));
		
		for(int i = 0; i < 5; i++){
			U6.removeWagon();
		}
		
			System.out.println(
			U6.countWagons()+"" Wagons\n""+
			U6.getSeats()+"" Seats\n""+
			U6.getStandingRoom()+"" Standing Room\n""+
			U6.getCapacity()+"" Capacity"");

	}
}"
Lietz,"Leonie Luisa",leonie.lietz@campus.tu-berlin.de,Beendet,"17. Januar 2021  21:55","22. Januar 2021  17:40","4 Tage 19 Stunden","17,70","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","static

; private
; void","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(52); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(51); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(50); Teil 57: %; Teil 58: 1; Teil 59: %; Teil 60: %; Teil 61: 0; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: 1; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(52); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(51); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: 1; Teil 104: 6(50); Teil 105: %; Teil 106: 0; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public Fraction(int numerator, int denominator) {
		if(denominator < 0 ) {
			this.numerator = - numerator;
			this.denominator = - denominator;			
		}
		else if(denominator == 0){
			this.denominator = 1; 
			this.numerator = numerator;
		}
		else {
			this.denominator = denominator;
			this.numerator = numerator;
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double ergebnis = (double)numerator/denominator;
		return ergebnis;
		
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return  numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int factorC = GCD(this.numerator,this.denominator);
		numerator = numerator/factorC;
        denominator = denominator/factorC;
	}

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int x = numerator  * f.getDenominator()+ denominator * f.getNumerator();
		int y = denominator * f.getDenominator();

		Fraction b = new Fraction(x,y);
		b.shorten();
		return b;
		//Fraction temp = new Fraction(numerator,denominator);
		//shorten();
		//temp.numerator = temp.numerator * f.denominator;
        //temp.denominator = temp.denominator * f.denominator;
		//shorten();
		//return temp ;
		
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction temp = new Fraction(numerator,denominator);
		temp.shorten();
		temp.numerator = numerator * f.numerator;
        temp.denominator = denominator * f.denominator;
		temp.shorten();
		return temp;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       Fraction temp = new Fraction(numerator, denominator);
	   temp.shorten();
       int newNumerator = numerator;
       int newDenominator = denominator;
       temp.numerator = newDenominator;
       temp.denominator = newNumerator;
	   return temp;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction temp = new Fraction(numerator, denominator);
		temp.shorten();
		//temp.multiply(f.reciprocal());
		//temp.shorten();
		//return temp; 
		temp.numerator = numerator*f.getDenominator();
		temp.denominator = denominator*f.getNumerator();
		temp.shorten();
		return temp;
    }","public class SubwayTest {

	public static void main(String[] args){
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity"");
		
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity"");
	}
}"
Latz,"Simon Leonhard",s.latz@campus.tu-berlin.de,Beendet,"18. Januar 2021  00:02","24. Januar 2021  23:59","6 Tage 23 Stunden","17,72","Getter und Setter","static

; void","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","class Rechteck {
    private int breite;
    public Rechteck(int breite) {
        this.breite = breite;
    }
    public void setBreite(int breite) {
        this.breite = breite;
    }

    public int getBreite() {
    return this.breite;
    }
  }
public class RechteckTest {
    public static void main(String[] args) {
        Rechteck r = new Rechteck(5);
        System.out.println(""""+ r.getBreite());
    }
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: 0; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: 0; Teil 97: 0; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 0; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","/**
 * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
 * uebergeben bekommt und die entsprechenden Attribute setzt.
 * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
 * auftreten (nicht im ""denominator""-Attribut).
 * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
 * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
 * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
 * und der Wert des Bruchs (die Argumente) unverändert bleibt
 * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
 * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
 * auf Eins gesetzt.
 * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
 */


public Fraction(int numerator, int denominator) {
  this.numerator = numerator;
  this.denominator = denominator;
  if(this.denominator == 0) this.denominator = 1;
  if(this.denominator<0){
    this.numerator=numerator*(-1);
    this.denominator= denominator*(-1);
  }
  shorten();
}

/**
 * Gibt den Nenner zurueck.
 */
public int getDenominator() {
  return this.denominator;
}

/**
 * Gibt den Zaehler zurueck.
 */
public int getNumerator() {
  return this.numerator;
}

/**
 * Gibt den Bruch als Gleitkommazahl zurueck.
 */
public double toDouble() {
  double gleitK = (double)this.numerator/(double)this.denominator;
  return gleitK;
}

/**
 * Gibt einen String im Format
 * ""Zaehler/Nenner"" zurueck.
 */
public String toString() {
  String str = this.numerator+""/""+this.denominator;
  return str;
}

/**
 * Kuerzt (vereinfacht) den Bruch.
 */
public void shorten() {
  int klGeNe = GCD(this.numerator, this.denominator);
  this.numerator = this.numerator/klGeNe;
  this.denominator = this.denominator/klGeNe;
}

/**
 * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
 */
public Fraction add(Fraction f) {
  int geNe = this.denominator*f.denominator;
  int num = f.numerator*this.denominator + f.denominator*this.numerator;
  int den = geNe;
  Fraction add = new Fraction(num, den);
  add.shorten();
  return add;
}

/**
 * Multipliziert mit dem uebergebenen Bruch.
 */
public Fraction multiply(Fraction f) {
  int num = this.numerator*f.numerator;
  int den = this.denominator*f.denominator;
  Fraction mult = new Fraction(num, den);
  mult.shorten();
  return mult;
}

/**
 * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
 * Sonst wird der Bruch unveraendert zurueckgegeben.
 */
 public Fraction reciprocal() {
   Fraction reciproc = new Fraction(0,0);
   if(this.numerator!=0){
     int tmp = this.numerator;
     reciproc.numerator = this.denominator;
     reciproc.denominator = tmp;
     return reciproc;
   }else{
   reciproc.numerator = this.denominator;
   reciproc.denominator = this.numerator;
   return reciproc;
  }
 }

/**
 * Dividiert durch den uebergebenen Bruch
 * (unter Verwendung von Kehrwert und Multiplikation).
 */
public Fraction divide(Fraction f) {
  int num = this.numerator*f.denominator;
  int den = this.denominator*f.numerator;
  Fraction teile = new Fraction(num, den);
  teile.shorten();
  return teile;
}","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest{

  public static void main(String[] args) {

    Subway u9 = new Subway(3);
    u9.addWagon(new Wagon(25,30));
    u9.addWagon(new Wagon(55,45));
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

    u9.addWagon(new Wagon(20,35));
    u9.addWagon(new Wagon(12,33));
    for(int i=0;i<5;i++) u9.removeWagon();
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

  }
}"
Mesfun-Ghebrekidan,Yoel,yoel.mesfun-ghebrekidan@campus.tu-berlin.de,Beendet,"18. Januar 2021  00:03","24. Januar 2021  18:10","6 Tage 18 Stunden","11,76","Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Setter-Methoden haben in der Regel den Rückgabetyp void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void

; static

; private","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3 (15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5 (15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7 (15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","//Hier soll die Klasse UBahnDemo stehen!

public class SubwayTest{
    public static void main(String [] args){

        Subway a = new Subway(3);
        a.addWagon(new Wagon(24,29));
        a.addWagon(new Wagon(54,44));
        System.out.println(a.getSeats());
        System.out.println(a.getStandingRoom());
        System.out.println(a.getCapacity());
        a.addWagon(new Wagon(19,34));
        a.addWagon(new Wagon(11, 32));
        a.removeWagon();
        a.removeWagon();
        a.removeWagon();
        a.removeWagon();
        a.removeWagon();

    }
}"
Günther,Till,9f091c3fdba2e9ee628d741520967ce1,Beendet,"18. Januar 2021  00:06","24. Januar 2021  20:03","6 Tage 19 Stunden","0,58","Objektmethoden modellieren das Verhalten von Objekten",private,"Inkonsistenzen beim Ändern von Attributwerten vermeiden","abstrakte Methoden","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }",-
Abdalla,"Hanen K Moustafa",hanen.abdalla@campus.tu-berlin.de,Beendet,"18. Januar 2021  00:08","24. Januar 2021  23:06","6 Tage 22 Stunden","15,64","static

; void

; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);","Getter und Setter","Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {

    public static void main(String[] args) {
            Subway u9 = new Subway(3);
u9.addWagon(new Wagon(25,30));
u9.addWagon(new Wagon(55,45));
System.out.println(
        u9.countWagons()+"" Wagons\n""+
        u9.getSeats()+"" Seats\n""+
        u9.getStandingRoom()+"" Standing Room\n""+
        u9.getCapacity()+"" Capacity""
        );
u9.addWagon(new Wagon(20,35));
u9.addWagon(new Wagon(12, 33));
for(int i=0;i<5;i++) u9.removeWagon();
System.out.println(
        u9.countWagons()+"" Wagons\n""+
        u9.getSeats()+"" Seats\n""+
        u9.getStandingRoom()+"" Standing Room\n""+
        u9.getCapacity()+"" Capacity""
        );
        }


        // write your code here
    }","public Fraction(int numerator, int denominator) {
        this.numerator = numerator*((denominator==0?1:Integer.signum(denominator)));
        this.denominator = (denominator == 0) ? 1 : Math.abs(denominator);
        shorten();
    }


    public int getDenominator() {
        return this.denominator;
    }


    public int getNumerator() {
        return this.numerator;
    }


    public double toDouble() {
        return (double) this.numerator / (double) this.denominator;
    }


    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }


    public void shorten() {
        int z = GCD(this.numerator, this.denominator);
        this.numerator /= z;
        this.denominator /= z;
    }


    public Fraction add(Fraction f) {
        int x = 0;
        if (this.denominator < f.denominator) {
            x = GCD(this.denominator, f.denominator);
        }else{
            x = LCM(this.denominator, f.denominator);
        }

        return new Fraction((int) ((double) this.numerator * ((double) x / this.denominator)) + (int) ((double) f.numerator * ((double) x / f.denominator)), x);
    }


    public Fraction multiply(Fraction f) {
        return new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
    }

    public Fraction reciprocal() {
        if (this.denominator != 0)
            return new Fraction(this.denominator, this.numerator);
        else
            return new Fraction(this.numerator, this.denominator);
    }


    public Fraction divide(Fraction f) {
        return new Fraction(this.numerator * f.denominator, this.denominator * f.numerator);
    }"
Witri,"Farah Shavira",witri@campus.tu-berlin.de,Beendet,"18. Januar 2021  00:13","24. Januar 2021  22:45","6 Tage 22 Stunden","16,27","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Verhindern das Überladen von Methoden
; Zugriff auf private Attribute ermöglichen
; Verhindern, dass Attributswerte gesetzt werden","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","private
; void

; static","class Rechteck { 
    private int breite;
    public Rechteck() {}
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;

        if (denominator == 0)
            this.denominator = 1;
        else if (denominator < 0) {
            this.denominator = (-1) * denominator;
            this.numerator = (-1) * this.numerator;
        } else
            this.denominator = denominator;

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return this.numerator / ((double) this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (this.getNumerator() + ""/"" + this.getDenominator());
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int x = this.numerator;
        int y = this.denominator;
        if (this.numerator < 0)
            x = this.numerator * (-1);
        if (this.denominator < 0)
            y = this.denominator * (-1);
        int divisor = GCD(x, y);
        this.numerator = this.numerator / divisor;
        this.denominator = this.denominator / divisor;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int rNumerator = f.denominator * this.numerator + this.denominator * f.numerator;
        int rDemoninator = f.denominator * this.denominator;
        Fraction result = new Fraction(rNumerator, rDemoninator);
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int rNumerator = this.numerator * f.numerator;
        int rDemoninator = this.denominator * f.denominator;
        Fraction result = new Fraction(rNumerator, rDemoninator);
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0) {
            return this;
        } else {
            Fraction inverted = new Fraction(this.denominator, this.numerator);
            return inverted;
        }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    }","//Hier soll die Klasse UBahnDemo stehen!"
Jakir,"Luka Kristian",jakir@campus.tu-berlin.de,Beendet,"18. Januar 2021  00:20","24. Januar 2021  19:24","6 Tage 19 Stunden","1,36","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","case
; class","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: %; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 11; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 11; Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 11; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 11; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 11; Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 11; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 11; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 11; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 11; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 11; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 11; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 11; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 11; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 11; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 11; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 11; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 11; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %",-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Terziyska,Radina,r.terziyska@campus.tu-berlin.de,Beendet,"18. Januar 2021  11:07","24. Januar 2021  21:43","6 Tage 10 Stunden","15,89","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","void

; class
; private","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 50(11); Teil 8: %; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 11; Teil 15: %; Teil 16: %; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 51(12); Teil 22: %; Teil 23: %; Teil 24: %; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 12; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 52(13); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 13; Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 14; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 3(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 4(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 5(15); Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 6(15); Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 7(15); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 3(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 4(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 5(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 6(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 7(17); Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;

        if (denominator == 0) {
            this.denominator = 1;
        }
        else if(denominator < 0) {
            this.numerator *= -1;
            this.denominator = denominator * -1;
        }
        else if (denominator > 0) {
            this.denominator = denominator;
        }

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck. 
     */
    public double toDouble() {
        return this.numerator / (double) this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck. 
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch. 
     */
    public void shorten() {
        int min = LCM(this.numerator, this.denominator);

        int[] primeNumbers = GetPrimeNumbers(min);

        for (int i = 0; i < primeNumbers.length; i++) {

            int prime = primeNumbers[i];
            while (this.numerator % prime == 0 && this.denominator % prime == 0) {
                this.numerator /= prime;
                this.denominator /= prime;
            }
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch. 
     */
    public Fraction add(Fraction f) {
        int newNumerator;
        int newDenominator;

        if (this.denominator % f.denominator == 0) {
            newDenominator = Math.max(this.denominator, f.denominator);
        } else {
            newDenominator = this.denominator * f.denominator;
        }

        if (this.denominator == newDenominator) {
            newNumerator = this.numerator + f.numerator * (newDenominator / f.denominator);
        } else if (f.denominator == newDenominator) {
            newNumerator = this.numerator * (newDenominator / this.denominator) + f.numerator;
        } else {
            newNumerator = this.numerator * f.denominator + f.numerator * this.denominator;
        }

        return new Fraction(newNumerator, newDenominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch. 
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = this.numerator * f.numerator;
        int newDenominator = this.denominator * f.denominator;

        return new Fraction(newNumerator, newDenominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator == 0) {
            return new Fraction(this.numerator, this.numerator);
        }

        return new Fraction(this.denominator, this.numerator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation). 
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }


    private int[] GetPrimeNumbers(int number) {
        //list for result
        boolean[] isPrime = new boolean[Math.abs(number) + 1];

        for (int i = 2; i < isPrime.length; i++) {
            isPrime[i] = true;
        }

        for (int i = 2; i < isPrime.length; i++) {

            if (isPrime[i] == true) {

                if (i * i >= isPrime.length) {
                    break;
                }

                for (int j = i * i; j < isPrime.length; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        int counter = 0;
        for (int i = 2; i < isPrime.length; i++) {

            if (isPrime[i] == true) {
                counter++;
            }
        }

        int[] primeNumbers = new int[counter];
        int index = 0;

        for (int i = 2; i < isPrime.length; i++) {

            if (isPrime[i] == true) {
                primeNumbers[index++] = i;
            }
        }

        return primeNumbers;
    }","public class SubwayTest {
    public static void main(String[] args) {

        Subway u9 = new Subway(3);
        u9.addWagon(new Wagon(25,30));
        u9.addWagon(new Wagon(55,45));
        System.out.println(
                u9.countWagons()+"" Wagons\n""+
                        u9.getSeats()+"" Seats\n""+
                        u9.getStandingRoom()+"" Standing Room\n""+
                        u9.getCapacity()+"" Capacity""
        );
        u9.addWagon(new Wagon(20,35));
        u9.addWagon(new Wagon(12, 33));
        for(int i=0;i<5;i++) u9.removeWagon();
        System.out.println(
                u9.countWagons()+"" Wagons\n""+
                        u9.getSeats()+"" Seats\n""+
                        u9.getStandingRoom()+"" Standing Room\n""+
                        u9.getCapacity()+"" Capacity""
        );
    }
}"
Klocksin,"Malte Carl",m.klocksin@campus.tu-berlin.de,Beendet,"18. Januar 2021  11:36","23. Januar 2021  13:33","5 Tage 1 Stunde","19,18","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","private
; void

; static","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 50; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	 
	 
	 



	public Fraction(int numerator, int denominator){
		this.numerator = numerator;
		this.denominator = denominator;
		if(denominator == 0){
			this.denominator = 1;
		}
		int teiler = GCD(getNumerator(), getDenominator());
		this.numerator = this.numerator/teiler;
		this.denominator = this.denominator/teiler;
		if(this.denominator < 0){
			this.denominator = this.denominator * -1;
			this.numerator = this.numerator * -1;
		}
	}
    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double b = (double)getNumerator()/(double)getDenominator();
		return b;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch = getNumerator()+""/""+getDenominator();
		return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(getNumerator(), getDenominator());
		this.numerator = this.numerator/teiler;
		this.denominator = this.denominator/teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction summe = new Fraction(3, 5);
	   if(this.denominator == f.denominator){
		   summe.denominator = this.denominator;
		   summe.numerator = this.numerator + f.numerator;
		   summe.shorten();
		   return summe;
	   }
	   int kGV = LCM(this.denominator, f.denominator);
	   int faktor1 = kGV / this.denominator;
	   int faktor2 = kGV / f.denominator;
	   summe.numerator = this.numerator * faktor1 + f.numerator * faktor2;
	   summe.denominator = kGV;
	   summe.shorten();
 	   return summe;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction produkt = new Fraction(3, 5);
		produkt.numerator = f.numerator * this.numerator;
		produkt.denominator = f.denominator * this.denominator;
		produkt.shorten();
		return produkt;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if(this.numerator == 0){
			Fraction kehrwert = new Fraction(this.numerator, this.denominator);
			return kehrwert;
		}
		Fraction kehrwert = new Fraction(3, 5);
		kehrwert.numerator = this.denominator;
		kehrwert.denominator = this.numerator;
		return kehrwert;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction quotient = new Fraction(3, 5);
	   quotient.numerator = this.numerator;
	   quotient.denominator = this.denominator;
	   quotient = quotient.multiply(f.reciprocal());
	   quotient.shorten();
	   return quotient;
    }","public class SubwayTest{
	
	public static void main(String[] args){
		
		Subway ubahn = new Subway(3);
		Wagon a = new Wagon(10, 20);
		ubahn.addWagon(a);
		Wagon b = new Wagon(5, 10);
		ubahn.addWagon(b);
		System.out.println(ubahn.getSeats());
		System.out.println(ubahn.getStandingRoom());
		System.out.println(ubahn.getCapacity());
		Wagon c = new Wagon(5, 10);
		ubahn.addWagon(c);
		Wagon d = new Wagon(5, 10);
		ubahn.addWagon(d);
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
	}
}"
Ohlendorf,Lasse,b8ec4bc7fa13cac6e41f2b7afb9c79c8,Beendet,"18. Januar 2021  12:26","24. Januar 2021  19:00","6 Tage 6 Stunden","18,51","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","private
; void","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: undef; Teil 40: undef; Teil 41: undef; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: mitte; Teil 61: links; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: 1; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon w1=new Wagon(25,30);
        u9.addWagon(w1);
        Wagon w2=new Wagon(55,45);
        u9.addWagon(w2);
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagon w3=new Wagon(25,35);
        u9.addWagon(w3);
        Wagon w4=new Wagon(12,33);
        u9.addWagon(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagon();
        }
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }
}","public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }

    public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }"
Gontarz,Jakob,jakob.gontarz@campus.tu-berlin.de,Beendet,"18. Januar 2021  12:37","24. Januar 2021  19:22","6 Tage 6 Stunden","18,00","static

; void","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    public Rechteck(int breite) {
        this.breite = breite;
    }
public void setBreite(int breite){
this.breite = breite;
}
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; Objektmethoden können überladen werden","Getter und Setter","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: 0; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: 0; Teil 97: 0; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 0; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest{

  public static void main(String[] args) {

    Subway u9 = new Subway(3);
    u9.addWagon(new Wagon(25,30));
    u9.addWagon(new Wagon(55,45));
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

    u9.addWagon(new Wagon(20,35));
    u9.addWagon(new Wagon(12,33));
    for(int i=0;i<5;i++) u9.removeWagon();
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

  }
}","/**
  * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
  * uebergeben bekommt und die entsprechenden Attribute setzt.
  * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
  * auftreten (nicht im ""denominator""-Attribut).
  * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
  * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
  * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
  * und der Wert des Bruchs (die Argumente) unverändert bleibt
  * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
  * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
  * auf Eins gesetzt.
  * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
  */


 public Fraction(int numerator, int denominator) {
   this.numerator = numerator;
   this.denominator = denominator;
   if(this.denominator == 0) this.denominator = 1;
   if(this.denominator<0){
     this.numerator=numerator*(-1);
     this.denominator= denominator*(-1);
   }
   shorten();
 }

 /**
  * Gibt den Nenner zurueck.
  */
 public int getDenominator() {
   return this.denominator;
 }

 /**
  * Gibt den Zaehler zurueck.
  */
 public int getNumerator() {
   return this.numerator;
 }

 /**
  * Gibt den Bruch als Gleitkommazahl zurueck.
  */
 public double toDouble() {
   double gleitK = (double)this.numerator/(double)this.denominator;
   return gleitK;
 }

 /**
  * Gibt einen String im Format
  * ""Zaehler/Nenner"" zurueck.
  */
 public String toString() {
   String str = this.numerator+""/""+this.denominator;
   return str;
 }

 /**
  * Kuerzt (vereinfacht) den Bruch.
  */
 public void shorten() {
   int klGeNe = GCD(this.numerator, this.denominator);
   this.numerator = this.numerator/klGeNe;
   this.denominator = this.denominator/klGeNe;
 }

 /**
  * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
  */
 public Fraction add(Fraction f) {
   int geNe = this.denominator*f.denominator;
   int num = f.numerator*this.denominator + f.denominator*this.numerator;
   int den = geNe;
   Fraction add = new Fraction(num, den);
   add.shorten();
   return add;
 }

 /**
  * Multipliziert mit dem uebergebenen Bruch.
  */
 public Fraction multiply(Fraction f) {
   int num = this.numerator*f.numerator;
   int den = this.denominator*f.denominator;
   Fraction mult = new Fraction(num, den);
   mult.shorten();
   return mult;
 }

 /**
  * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
  * Sonst wird der Bruch unveraendert zurueckgegeben.
  */
  public Fraction reciprocal() {
    Fraction reciproc = new Fraction(0,0);
    if(this.numerator!=0){
      int tmp = this.numerator;
      reciproc.numerator = this.denominator;
      reciproc.denominator = tmp;
      return reciproc;
    }else{
    reciproc.numerator = this.denominator;
    reciproc.denominator = this.numerator;
    return reciproc;
   }
  }

 /**
  * Dividiert durch den uebergebenen Bruch
  * (unter Verwendung von Kehrwert und Multiplikation).
  */
 public Fraction divide(Fraction f) {
   int num = this.numerator*f.denominator;
   int den = this.denominator*f.numerator;
   Fraction teile = new Fraction(num, den);
   teile.shorten();
   return teile;
 }"
Ardisson,"Maxim Dimitri",ardisson@campus.tu-berlin.de,Beendet,"18. Januar 2021  12:38","24. Januar 2021  18:13","6 Tage 5 Stunden","15,95","Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","class Rechteck {
    private int breite;

    public Rechteck( int breite){
      this.breite = breite;
    }

    public void setBreite(int breite) {
        this.breite = breite;
    }

    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","void

; static","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: 0; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: &; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: 0; Teil 97: 0; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 0; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest{

  public static void main(String[] args) {

    Subway u9 = new Subway(3);
    u9.addWagon(new Wagon(25,30));
    u9.addWagon(new Wagon(55,45));
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

    u9.addWagon(new Wagon(20,35));
    u9.addWagon(new Wagon(12,33));
    for(int i=0;i<5;i++) u9.removeWagon();
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

  }
}","/**
  * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
  * uebergeben bekommt und die entsprechenden Attribute setzt.
  * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
  * auftreten (nicht im ""denominator""-Attribut).
  * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
  * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
  * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
  * und der Wert des Bruchs (die Argumente) unverändert bleibt
  * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
  * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
  * auf Eins gesetzt.
  * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
  */


 public Fraction(int numerator, int denominator) {
   this.numerator = numerator;
   this.denominator = denominator;
   if(this.denominator == 0) this.denominator = 1;
   if(this.denominator<0){
     this.numerator=numerator*(-1);
     this.denominator= denominator*(-1);
   }
   shorten();
 }

 /**
  * Gibt den Nenner zurueck.
  */
 public int getDenominator() {
   return this.denominator;
 }

 /**
  * Gibt den Zaehler zurueck.
  */
 public int getNumerator() {
   return this.numerator;
 }

 /**
  * Gibt den Bruch als Gleitkommazahl zurueck.
  */
 public double toDouble() {
   double gleitK = (double)this.numerator/(double)this.denominator;
   return gleitK;
 }

 /**
  * Gibt einen String im Format
  * ""Zaehler/Nenner"" zurueck.
  */
 public String toString() {
   String str = this.numerator+""/""+this.denominator;
   return str;
 }

 /**
  * Kuerzt (vereinfacht) den Bruch.
  */
 public void shorten() {
   int klGeNe = GCD(this.numerator, this.denominator);
   this.numerator = this.numerator/klGeNe;
   this.denominator = this.denominator/klGeNe;
 }

 /**
  * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
  */
 public Fraction add(Fraction f) {
   Fraction addi = new Fraction(0, 0);
   int geNe = this.denominator*f.denominator;
   addi.numerator = f.numerator*this.denominator + f.denominator*this.numerator;
   addi.denominator = geNe;
   addi.shorten();
   return addi;
 }

 /**
  * Multipliziert mit dem uebergebenen Bruch.
  */
 public Fraction multiply(Fraction f) {
   Fraction mult = new Fraction(0, 0);
   mult.numerator = this.numerator*f.numerator;
   mult.denominator = this.denominator*f.denominator;
   mult.shorten();
   return mult;
 }

 /**
  * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
  * Sonst wird der Bruch unveraendert zurueckgegeben.
  */
 public Fraction reciprocal() {
   Fraction reci = new Fraction(0,0);
   if(this.numerator==0){
     reci.numerator = this.denominator;
     reci.denominator = 1;
     return reci;
   }else{
   reci.numerator = this.denominator;
   reci.denominator = this.numerator;
   return reci;
  }
 }

 /**
  * Dividiert durch den uebergebenen Bruch
  * (unter Verwendung von Kehrwert und Multiplikation).
  */
 public Fraction divide(Fraction f) {
   Fraction div = new Fraction(0, 0);
   div.numerator = this.numerator*f.denominator;
   div.denominator = this.denominator*f.numerator;
   div.shorten();
   return div;
 }"
Kemmler,"Erich Lorenz Boy",kemmler@campus.tu-berlin.de,Beendet,"18. Januar 2021  12:49","24. Januar 2021  09:31","5 Tage 20 Stunden","17,61","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","static

; void","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: 0; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: %; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		
        if (denominator == 0){
			this.denominator = 1;
		}
		if (denominator < 0){
			this.numerator = -numerator;
            this.denominator = -denominator;
        }
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }
	



    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (((double) this.numerator) / ((double) this.denominator));
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int gcd = GCD(numerator,denominator);
		if(gcd<0){
			gcd=-gcd;
		}
		numerator/=gcd;
		denominator/=gcd;
    
	}

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        Fraction newFraction = new Fraction(1,1);
        int n = this.numerator * f.getDenominator() + f.getNumerator() * this.denominator;
        int d = this.denominator * f.getDenominator();
        newFraction.numerator = n;
        newFraction.denominator = d;
        newFraction.shorten();
		return newFraction;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction newFraction = new Fraction(1,1);
        int n = this.numerator * f.getNumerator();
        int d = this.denominator * f.getDenominator();
        newFraction.numerator = n;
        newFraction.denominator = d;
        return newFraction;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       Fraction newFraction = new Fraction(1,1);
	   if (this.numerator != 0){
		   newFraction.numerator = this.denominator;
           newFraction.denominator =this.numerator;
	       if(this.numerator<0){
			   newFraction.numerator = -this.denominator;
		       newFraction.denominator= -this.numerator;
	        }
		return newFraction;
		}
		return newFraction;
	}
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction newFraction = new Fraction(numerator,denominator);
	   
	   Fraction new1 = f.reciprocal();
	   Fraction new3 = newFraction.multiply(new1);
	   new3.shorten();
	   return new3;
    }","public class SubwayTest{
	
	public static void main (String[] args){
		Subway u1 = new Subway(3);
		u1.addWagon(new Wagon(25,30));
		u1.addWagon(new Wagon(55,45));
		System.out.println(
		u1.countWagons()+"" Wagons\n""+
        u1.getSeats()+"" Seats\n""+
        u1.getStandingRoom()+"" Standing Room\n""+
        u1.getCapacity()+"" Capacity""
		);
		
		u1.addWagon(new Wagon(20,35));
		u1.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++){
		  u1.removeWagon();
		} 
        
		System.out.println(
        u1.countWagons()+"" Wagons\n""+
        u1.getSeats()+"" Seats\n""+
        u1.getStandingRoom()+"" Standing Room\n""+
        u1.getCapacity()+"" Capacity""
		);
	}

}"
"Mailhos Nogues","Lucas Fel",642dc2fc24f2168530e7533d52e691ae,Beendet,"18. Januar 2021  16:08","22. Januar 2021  14:25","3 Tage 22 Stunden","18,88","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","Getter und Setter","void

; private","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest {

    public static void main(String[] args){
        Subway thomas = new Subway(3);
        Wagon a = new Wagon(10, 5);
        Wagon b = new Wagon(20, 10);

        thomas.addWagon(a);
        thomas.addWagon(b);

        System.out.println(thomas.getSeats()+ "" Seats"");
        System.out.println(thomas.getStandingRoom()+ "" Standing Room"");
        System.out.println(thomas.getCapacity()+ "" Capacity"");

        Wagon c = new Wagon(2, 1);
        Wagon d = new Wagon(100, 69);

        thomas.addWagon(c);
        thomas.addWagon(d);

        thomas.removeWagon();
        thomas.removeWagon();
        thomas.removeWagon();
        thomas.removeWagon();
        thomas.removeWagon();
    }
}","public Fraction(int numerator, int denominator){

        if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
            shorten();
        }else if(denominator > 0){
            this.numerator = numerator;
            this.denominator = denominator;
            shorten();
        }else if(denominator < 0){
            this.numerator = -numerator; //wtf is wrong here??
            this.denominator = -denominator;
            shorten();
            if(this.numerator == 1 ){
                this.numerator = -numerator; //wtf is wrong here??
                this.denominator = -denominator;
            }
        }
    }

    public int getDenominator() {
        return this.denominator;
    }

    public int getNumerator() {
        return this.numerator;
    }

    public double toDouble() {
        double a = (double)this.numerator / (double)this.denominator;
        return a;
    }

    public String toString() {
    String a = Integer.toString(numerator);
    String b = Integer.toString(denominator);
    String c = a + ""/"" + b;
    return c;
    }

    public void shorten() {
        int gdc = GCD(this.numerator,this.denominator);
        this.numerator = this.numerator/gdc;
        this.denominator = this.denominator/gdc;
    }

    public Fraction add(Fraction f) {
        int lmc = LCM(this.denominator, f.denominator);
        int num1 = ((lmc/this.denominator)*this.numerator);
        int numf = ((lmc/f.denominator)*f.numerator);
        int a = num1 + numf;
        int b = lmc;
        Fraction x = new Fraction(a,b);
        return x;
    }

    public Fraction multiply(Fraction f) {
        int a = this.numerator * f.numerator;
        int b = this.denominator * f.denominator;
        Fraction x = new Fraction(a,b);
        return x;
    }

    public Fraction reciprocal() {
        if(this.numerator != 0){
            int a = this.denominator;
            int b = this.numerator;
            Fraction x = new Fraction(a,b);
            return x;
        }else{
            Fraction y = new Fraction(this.numerator, this.denominator);
            return y;
        }
    }

    public Fraction divide(Fraction f) {
        Fraction fRep = new Fraction(f.reciprocal().numerator, f.reciprocal().denominator );
        return multiply(fRep);
    }"
Wegert,"Johan Ole",j.wegert@campus.tu-berlin.de,Beendet,"18. Januar 2021  16:47","24. Januar 2021  23:59","6 Tage 7 Stunden","19,82","Getter und Setter","Setzen falscher Attributwerte verhindern

; Verhindern, dass Attributswerte gesetzt werden

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; void","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest {
public static void main(String[] args) {
	Subway s=new Subway(4);
	s.addWagon(new Wagon(10,15));
	System.out.println(s.countWagons());
	s.removeWagon();
	s.removeWagon();
	s.addWagon(new Wagon(10,15));
	s.addWagon(new Wagon(15,20));
	s.addWagon(new Wagon(20,30));
	s.addWagon(new Wagon(30,40));
	s.addWagon(new Wagon(10,15));
	System.out.println(s.countWagons());

	s.removeWagon();
	System.out.println(s.countWagons());

	System.out.println(s.getSeats());
	System.out.println(s.getStandingRoom());
	System.out.println(s.getCapacity());


}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }else if(denominator==0){
            this.denominator=1;
            this.numerator=numerator;
        }else{
            this.numerator=numerator;
            this.denominator=denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)((double)numerator/(double)denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s=numerator+""/""+denominator;
        return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int i=GCD(numerator,denominator);
        numerator=numerator/i;
        denominator=denominator/i;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int gemNenner=LCM(denominator,f.getDenominator());
       int numerator1=numerator*gemNenner/denominator;
       int numerator2=f.getNumerator()*gemNenner/f.getDenominator();
       Fraction g=new Fraction(numerator1+numerator2,gemNenner);
       g.shorten();
       return g;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction ret=new Fraction(numerator*f.getNumerator(),denominator*f.getDenominator());
        ret.shorten();
        return ret;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(denominator==0){
           return this;
       }else{
           return new Fraction(denominator,numerator);
       }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        if(f.getNumerator()==0){
            return null;
        }else{
            Fraction u=multiply(f.reciprocal());
            u.shorten();
            return u;
        }
       
    }"
Lex,Matthias,m.lex@campus.tu-berlin.de,Beendet,"18. Januar 2021  19:19","24. Januar 2021  23:58","6 Tage 4 Stunden","5,70","void

; static

; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","public class SubwayTest{

	public static void main(String[] args){
		Subway U2 = new Subway(3);
		U2.addWagon(20,10);
		U2.addWagon(25,15);
		System.out.println(""Gesamtanzahl Stehplaetze: ""+U2.getSeats()+""\t""+""Gesamtanzahl Sitzplaetze: ""+U2.getStandingRoom()+""\t""+""Gesamtanzahl Plaetze: ""+U2.getCapacity());
		U2.removeWagon();
		U2.removeWagon();
		U2.removeWagon();
		U2.removeWagon();
		U2.removeWagon();
	}
}"
Mäding,"Toni Siegfried",t.maeding@campus.tu-berlin.de,Beendet,"18. Januar 2021  19:53","24. Januar 2021  22:24","6 Tage 2 Stunden","1,00",class,"Setter-Methoden haben in der Regel den Rückgabetyp void","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:",-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Ramge,Max,ramge@campus.tu-berlin.de,Beendet,"18. Januar 2021  20:25","24. Januar 2021  10:58","5 Tage 14 Stunden","18,63","Getter und Setter","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","void

; private","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: --; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: %; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: 1; Teil 100: 0; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: 0; Teil 109: 0; Teil 110: 1; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 1; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest {
	public static void main(String[] args) {		
		Subway u2 = new Subway(3);
		u2.addWagon(new Wagon(25,30));
		u2.addWagon(new Wagon(45,55));
		System.out.println(u2.getSeats());		
		System.out.println(u2.getStandingRoom());		
		System.out.println(u2.getCapacity());
		u2.addWagon(new Wagon(10,15));
		u2.addWagon(new Wagon(20,25));
		u2.removeWagon();
		u2.removeWagon();
		u2.removeWagon();
		u2.removeWagon();
		u2.removeWagon();
	}
}","public Fraction(int numerator, int denominator) {
		
		if (denominator < 0) {
			this.numerator = numerator*(-1);
			this.denominator = denominator*(-1);
		}
		if (denominator == 0){
			this.numerator = numerator;
			this.denominator = 1;
		}
		if (denominator > 0) {
			this.numerator = numerator; 
			this.denominator = denominator;
		}
		this.shorten(); 
    }
	
    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }
	
	public double toDouble() {
		double a = (double)getNumerator();
		double b = (double)getDenominator();
		double r = a/b;
		return r;
    }
	
	public String toString() { 
		String r = getNumerator()+""/""+getDenominator();
        return r;
    }
	 
	public void shorten() { 
		int t = GCD(getNumerator(),getDenominator());
		while(t != 1){
		this.numerator = getNumerator()/t;
		this.denominator = getDenominator()/t;
		t = GCD(getNumerator(),getDenominator());
		}
    }
	
	public Fraction add(Fraction f) {
	  int x = (this.getNumerator() * f.getDenominator())+(f.getNumerator() * this.getDenominator());
	  int y = this.getDenominator() * f.getDenominator();  
	  Fraction t = new Fraction(x,y);
	  return t;
    }
	
	public Fraction multiply(Fraction f) {
		int x = (this.getNumerator() * f.getNumerator());
		int y = (this.getDenominator() * f.getDenominator());
		Fraction t = new Fraction(x,y);
		return t;
    }
	
	public Fraction reciprocal() {
	   int x,y;
	   
	   if(this.getNumerator() != 0){
		   x = this.getNumerator();
		   y = this.getDenominator();
	   }
	   else {
		   y = this.getNumerator();
		   x = this.getDenominator();
	   }
	   
		Fraction t = new Fraction(y,x);
		return t;	   
    }
	
	public Fraction divide(Fraction f) {
       Fraction t = this.multiply(f.reciprocal());
	   return t;
    }"
Skodlerak,Torben,skodlerak@tu-berlin.de,Beendet,"19. Januar 2021  11:02","24. Januar 2021  19:11","5 Tage 8 Stunden","19,06","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; void","Setzen falscher Attributwerte verhindern

; Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: undef; Teil 40: undef; Teil 41: undef; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: mitte; Teil 61: links; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: 1; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon w1=new Wagon(25,30);
        u9.addWagon(w1);
        Wagon w2=new Wagon(55,45);
        u9.addWagon(w2);
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagon w3=new Wagon(25,35);
        u9.addWagon(w3);
        Wagon w4=new Wagon(12,33);
        u9.addWagon(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagon();
        }

        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }

}","public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

   
    public int getNumerator() {
        return numerator;
    }

   
    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

   
    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }
     public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }"
Mittelstädt,"Lina Sophia",l.mittelstaedt@campus.tu-berlin.de,Beendet,"19. Januar 2021  13:28","24. Januar 2021  20:10","5 Tage 6 Stunden","18,99","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","void

; private
; static","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden können überladen werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest {
	public static void main(String[] args){
		Subway u7 = new Subway(3);
		u7.addWagon(new Wagon(20,30));
		u7.addWagon(new Wagon(50,45));
		//System.out.println(u7.countWagons()+"" Wagons\n""+u7.getSeats()+"" Seats\n""+u7.getStandingRoom()+"" Standing Room\n""+u7.getCapacity()+"" Capacity"");
		u7.addWagon(new Wagon(12,35));
		u7.addWagon(new Wagon(20, 33));
		for(int i=0;i<5;i++) u7.removeWagon();
		//System.out.println(u7.countWagons()+"" Wagons\n""+u7.getSeats()+"" Seats\n""+u7.getStandingRoom()+"" Standing Room\n""+u7.getCapacity()+"" Capacity"");	
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if (denominator == 0) {
            this.denominator = 1;
            this.numerator = numerator;
		} else if (denominator < 0) { // doesnt matter if numerator is negative as well
            this.denominator = denominator * -1;
            this.numerator = numerator * -1;
        } else {
            this.numerator = numerator;
            this.denominator = denominator;
		}
		this.shorten(); 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         return ((double) this.numerator) / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int reverse = 1;
        if (numerator < 0) {
            reverse = -1;
            numerator = numerator * -1;
        }
        int divide = 0;
        while (divide != 1) {
            divide = GCD(this.numerator, this.denominator);
            this.denominator = this.denominator / divide;
            this.numerator = this.numerator / divide;
        }
        numerator *= reverse;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       this.numerator = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
		this.denominator = denominator * f.getDenominator();
		return new Fraction(this.numerator, this.denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = numerator * f.numerator;
		int newDenominator = denominator * f.denominator;
		Fraction result = new Fraction(newNumerator, newDenominator);
		return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (getNumerator () != 0) {
		   return new Fraction (denominator,numerator);
		}
		return new Fraction (numerator,denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f = f.reciprocal();
		return this.multiply(f);
    }"
Aung,Okkar,okkar.aung@campus.tu-berlin.de,Beendet,"19. Januar 2021  13:52","24. Januar 2021  23:59","5 Tage 10 Stunden","18,28","Getter und Setter","static

; private
; void","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest {
	
	public static void main (String[] args) {
		
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon (30,60));
		u9.addWagon(new Wagon (20,40));
		
		System.out.println( u9.countWagons()+"" Wagons\n""+ u9.getSeats()+"" Seats\n""+u9.getStandingRoom()+"" Standing Room\n""+ u9.getCapacity()+"" Capacity"");
		
		u9.addWagon (new Wagon (15,30));
		u9.addWagon (new Wagon (10,20));
		for (int i=0; i<5; i++) {
			u9.removeWagon();
		}
	}
}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		if (denominator == 0) {
			this.denominator = 1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double numeratorDouble = numerator;
		return numeratorDouble/denominator;
    }

    /**
     * Gibt einen String im Format  
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		shorten();
        return (+numerator+""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
		this.numerator = numerator / gcd;
		this.denominator = denominator / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */

	public Fraction add(Fraction f) {
		this.numerator = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
		this.denominator = denominator * f.getDenominator();
		Fraction sum = new Fraction(this.numerator, this.denominator);
		sum.shorten();
		return sum;
	}
   	
	

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int multipliedNumerator = numerator * f.numerator;
		int multipliedDenominator = denominator * f.denominator;
		Fraction multiple = new Fraction (multipliedNumerator, multipliedDenominator);
		multiple.shorten();
		return multiple;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		int newNumerator;
		int newDenominator;
	   if (numerator != 0) {
		   newNumerator = denominator;
		   newDenominator = numerator;
	   }
	   else {
		   newNumerator = numerator;
		   newDenominator = denominator;
	   }
	   Fraction reciprocal = new Fraction(newNumerator, newDenominator);
	   reciprocal.shorten();
	   return reciprocal;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction reciprocal = f.reciprocal();
	   Fraction quotient = multiply(reciprocal);
	   quotient.shorten();
	   return quotient;
    }"
Chaudhary,Pradeep,p.chaudhary@campus.tu-berlin.de,Beendet,"19. Januar 2021  14:03","24. Januar 2021  23:59","5 Tage 9 Stunden","0,25",-,-,"class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}",-,void,-,"Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }",-
Gosling,"Kian Peter",gosling@campus.tu-berlin.de,Beendet,"19. Januar 2021  17:44","24. Januar 2021  23:59","5 Tage 6 Stunden","3,10","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Getter und Setter","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","private
; void","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: ; Teil 6: ; Teil 7: 11; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:","//Hier soll die Klasse UBahnDemo stehen!
class UBahnDemo {
    public static void main(String[] args) {
        Subway U9 = new Subway(3); 
        
        U9.addWagon(new Wagon(10, 10)); 
        U9.addWagon(new Wagon(20, 20));
        
        //System.out.println(""Wagons: "" + U9.countWagons());
        System.out.println(""Sitzplätze: "" + U9.getSeats());
        System.out.println(""Stehplätze: "" + U9.getStandingRoom());
        System.out.println(""Capacity: "" + U9.getCapacity());
        
        U9.addWagon(new Wagon(5, 5)); 
        U9.addWagon(new Wagon(15, 15)); 
        
        U9.removeWagon(); 
        U9.removeWagon(); 
        U9.removeWagon(); 
        U9.removeWagon(); 
        U9.removeWagon(); 

    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return 
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Wegener,Erik,erik.wegener@campus.tu-berlin.de,Beendet,"20. Januar 2021  08:00","20. Januar 2021  08:05","4 Minuten 52 Sekunden","1,44","In Objektmethoden können lokale Variablen deklariert werden","Setzen falscher Attributwerte verhindern","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter",case,"Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: 11; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: 12; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:",-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Kalz,Andreas,a.kalz.1@tu-berlin.de,Beendet,"20. Januar 2021  09:52","20. Januar 2021  11:03","1 Stunde 11 Minuten","19,84","Getter und Setter","void

; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 50; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(15); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
        	this.denominator = 1;
        	this.numerator = numerator;
        } else {
        	this.denominator = Math.abs(denominator);
        	this.numerator = numerator * (denominator/Math.abs(denominator));	
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """"+this.numerator+""/""+this.denominator+"""";
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int divider = GCD(numerator,denominator);
        this.numerator = this.numerator/divider;
        this.denominator = this.denominator/divider;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
       return new Fraction(this.numerator*(lcm/this.denominator)+f.getNumerator()*(lcm/f.getDenominator()), lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(f.getNumerator()*this.numerator, f.getDenominator()*this.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0) return new Fraction(this.numerator, this.denominator);
       return new Fraction(this.denominator, this.numerator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return f.reciprocal().multiply(this);
    }","class SubwayTest {

	public static void main(String[] args) {
		Subway s = new Subway(3);
		Wagon w0 = new Wagon(4,5);
		Wagon w1 = new Wagon(10,23);
		s.addWagon(w0);
		s.addWagon(w1);
		System.out.println(
			s.countWagons() + "" Wagons\n"" + 
			s.getSeats() + "" Seats\n"" +
			s.getStandingRoom() + "" Standing Room\n""+
			s.getCapacity() + "" Capacity"");
		Wagon w2 = new Wagon(11,5);
		Wagon w3 = new Wagon(6,33);
		s.addWagon(w2);
		s.addWagon(w3);
		for (int i = 0; i < 5; i++) {
			s.removeWagon();
		}
		System.out.println(
			s.countWagons() + "" Wagons\n"" + 
			s.getSeats() + "" Seats\n"" +
			s.getStandingRoom() + "" Standing Room\n""+
			s.getCapacity() + "" Capacity"");
	}
}"
Jäger,"Fabia Cecilia",f.jaeger@tu-berlin.de,Beendet,"20. Januar 2021  11:15","24. Januar 2021  20:17","4 Tage 9 Stunden","19,57","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","private
; void","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden können überladen werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: links; Teil 40: mitte; Teil 41: rechts; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: links; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: links; Teil 89: mitte; Teil 90: rechts; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: links; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            this.denominator = -1 * denominator;
            this.numerator = -1 * numerator;
        } else if (denominator == 0) {
            this.denominator = 1;
            this.numerator = numerator;
        } else {
            this.denominator = denominator;
            this.numerator = numerator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator / denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = Math.abs(GCD(numerator, denominator));
        numerator /= gcd;
        denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int n1 = this.numerator * f.denominator;
        int n2 = f.numerator * this.denominator;
        int d = this.denominator * f.denominator;
        return new Fraction(n1 + n2, d);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0) {
            return new Fraction(denominator, numerator);
        } else {
            return new Fraction(numerator, denominator);
        }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }","public class SubwayTest {

    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon firstWagon = new Wagon(36, 72);
        Wagon secondWagon = new Wagon(42, 60);
        u9.addWagon(firstWagon);
        u9.addWagon(secondWagon);
        System.out.println(
            u9.countWagons() + "" Wagons\n"" +
            u9.getSeats() + "" Seats\n"" +
            u9.getStandingRoom() + "" Standing Room\n"" +
            u9.getCapacity() + "" Capacity""
        );
        Wagon thirdWagon = new Wagon(42, 60);
        Wagon fourthWagon = new Wagon(36, 72);
        u9.addWagon(thirdWagon);
        u9.addWagon(fourthWagon);
        for (int i = 0; i < 5; i++) {
            u9.removeWagon();
        }
        System.out.println(
            u9.countWagons() + "" Wagons\n"" +
            u9.getSeats() + "" Seats\n"" +
            u9.getStandingRoom() + "" Standing Room\n"" +
            u9.getCapacity() + "" Capacity""
        );
    }
}"
Klemt,"Dorothea Klara",d.klemt@campus.tu-berlin.de,Beendet,"20. Januar 2021  11:27","24. Januar 2021  20:10","4 Tage 8 Stunden","17,64","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","void

; private
; static","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest {

	public static void main (String [] args) {

		Subway u9 = new Subway(3);

		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));

		System.out.println(
   	 	u9.countWagons()+"" Wagons\n""+
 		u9.getSeats()+"" Seats\n""+
  		u9.getStandingRoom()+"" Standing Room\n""+
    	u9.getCapacity()+"" Capacity"");

		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));

		for(int i = 0; i < 5; i++) {
			u9.removeWagon();
		}
			System.out.println(
   			u9.countWagons()+"" Wagons\n""+
   			u9.getSeats()+"" Seats\n""+
    		u9.getStandingRoom()+"" Standing Room\n""+
    		u9.getCapacity()+"" Capacity"");

    }
}","public Fraction(int numerator, int denominator) {
		this.denominator = denominator;
		this.numerator= numerator;
		if (denominator == 0){
			this.denominator = 1;
		}
		shorten();
	}

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         return ((double) this.numerator) / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;

		}

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
	 
	
    public void shorten() {
		int gcd = GCD(numerator, denominator);
		if (denominator < 0){
			int a = -1;
			numerator /= gcd*a;
			denominator /= gcd*a;
		}
		else {
		numerator /= gcd;
		denominator /= gcd;
		}
    }
	
/**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */	
	public Fraction add(Fraction f) {
		this.numerator = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
		this.denominator = denominator * f.getDenominator();
		return new Fraction(this.numerator, this.denominator);
	}
   	
	 /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int newNumerator = numerator * f.numerator;
		int newDenominator = denominator * f.denominator;
		Fraction result = new Fraction(newNumerator, newDenominator);
		return result; 
    }
 /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (getNumerator () != 0) {
		   return new Fraction (denominator,numerator);
		}
		return new Fraction (numerator,denominator);
	}
	  /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		f = f.reciprocal();
		return this.multiply(f);
	}"
Taranuschitsch,Kristina,k.taranuschitsch@campus.tu-berlin.de,Beendet,"20. Januar 2021  12:06","24. Januar 2021  23:59","4 Tage 11 Stunden","10,65","static

; void","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 52; Teil 47: 51; Teil 48: 52; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","/* Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
		if(denominator < 0) {
			denominator = (denominator*(-1));
			numerator = (numerator*(-1));
		
		this.denominator = denominator;
		this.numerator = numerator;
		}	
		
		else if(denominator == 0) {
			denominator = 1;
			numerator = numerator;
		
		this.denominator = denominator;
		this.numerator = numerator;
		}	
		
		else{
		this.denominator = denominator;
		this.numerator = numerator;
		shorten();
		}
		
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double fraction = (double)numerator/(double)denominator;
		return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = + numerator + ""/"" + denominator;
		return str;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int ggT = GCD(numerator, denominator);
		
		numerator =  numerator/ggT;
		denominator = denominator/ggT;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int kgV = LCM(denominator, f.denominator);
	   
	   numerator = ((kgV/denominator)*numerator);
	   f.numerator = ((kgV/f.denominator) *f.numerator);
	   
	   denominator = kgV;
	   numerator = numerator + f.numerator;
    
	 
		return new Fraction(numerator,denominator);
	}

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        numerator = numerator * f.numerator;
		denominator = denominator * f.denominator;
    
	return new Fraction(numerator,denominator);
	}

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator == 0) {
			numerator = numerator;
			denominator = denominator;
	   } 
	   else if (numerator > 0) {
		   int tmp = numerator;
		   numerator = denominator;
		   denominator = tmp;
	   }
		return new Fraction(numerator,denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		numerator = numerator*f.denominator;
		denominator = denominator*f.numerator;
    
	return new Fraction(numerator,denominator);
	
	}",-
Schrenk,"Philipp Albert",p.schrenk@campus.tu-berlin.de,Beendet,"20. Januar 2021  13:23","24. Januar 2021  23:59","4 Tage 10 Stunden","19,78","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","void

; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: -; Teil 37: -; Teil 38: -; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: 0; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: -; Teil 86: -; Teil 87: -; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 0; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest {
	
	public static void main(String[] args) {
		Subway ubahn = new Subway(3);
		
		ubahn.addWagon(new Wagon(50, 75));
		ubahn.addWagon(new Wagon(40, 100));
		
		System.out.println(ubahn.getSeats() + "" Seats"");
		System.out.println(ubahn.getStandingRoom() + "" Standing Room"");
		System.out.println(ubahn.getCapacity() + "" Capacity"");
		
		ubahn.addWagon(new Wagon(60, 65));
		ubahn.addWagon(new Wagon(30, 110));
		
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
	}
}","/**
	 * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
	 * uebergeben bekommt und die entsprechenden Attribute setzt. 
	 * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
	 * auftreten (nicht im ""denominator""-Attribut).
	 * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
	 * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
	 * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
	 * und der Wert des Bruchs (die Argumente) unverändert bleibt 
	 * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
	 * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
	 * auf Eins gesetzt.
	 * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
	 */
	public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		if(denominator < 0) {
			this.numerator *= (-1);
			this.denominator *= (-1);
		}
		else if(denominator == 0) {
			this.denominator++;
		}
		this.shorten();
	}

	/**
	 * Gibt den Nenner zurueck.
	 */
	public int getDenominator() {
		return denominator;
	}

	/**
	 * Gibt den Zaehler zurueck.
	 */
	public int getNumerator() {
		return numerator;
	}

	/**
	 * Gibt den Bruch als Gleitkommazahl zurueck.
	 */
	public double toDouble() {
		double d = (double)numerator / (double)denominator;
		return d;
	}

	/**
	 * Gibt einen String im Format
	 * ""Zaehler/Nenner"" zurueck.
	 */
	public String toString() {
		return """" + numerator + ""/"" + denominator + """";
	}

	/**
	 * Kuerzt (vereinfacht) den Bruch.
	 */
	public void shorten() {
		int gcd = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator/gcd;
		this.denominator = this.denominator/gcd;
	}

	/**
	 * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
	 */
	public Fraction add(Fraction f) {
		int numerator = this.numerator;
		int denominator = this.denominator;
		numerator = numerator * f.denominator + f.numerator * denominator;
		denominator = denominator * f.denominator;
		return new Fraction(numerator, denominator);
	}

	/**
	 * Multipliziert mit dem uebergebenen Bruch.
	 */
	public Fraction multiply(Fraction f) {
		int numerator = this.numerator;
		int denominator = this.denominator;
		numerator = numerator * f.numerator;
		denominator = denominator * f.denominator;
		return new Fraction(numerator, denominator);
		}

	/**
	 * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
	 * Sonst wird der Bruch unveraendert zurueckgegeben.
	 */
	public Fraction reciprocal() {
		int numerator = this.numerator;
		int denominator = this.denominator;
		if(numerator != 0) {
		   int num = numerator;
		   numerator = denominator;
		   denominator = num;
	   }
	   return new Fraction(numerator, denominator);
	}

	/**
	 * Dividiert durch den uebergebenen Bruch 
	 * (unter Verwendung von Kehrwert und Multiplikation).
	 */
	public Fraction divide(Fraction f) {
		Fraction bruch = this.multiply(f.reciprocal());
		bruch.shorten();
		return bruch;
	}"
"Ramos Ruiz",Natalia,n.ramosruiz@campus.tu-berlin.de,Beendet,"20. Januar 2021  14:34","24. Januar 2021  23:58","4 Tage 9 Stunden","10,01","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Objektmethoden können überladen werden

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; Objektmethoden modellieren das Verhalten von Objekten","private
; static

; void

; class","class Rechteck {
    private int breite;

    public void setBreite(int breite) {
        this.breite = breite;
    }

    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {

        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: undef; Teil 40: undef; Teil 41: undef; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: -; Teil 65: -; Teil 66: -; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: 1; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: undef; Teil 89: undef; Teil 90: undef; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: -; Teil 113: -; Teil 114: -; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public Fraction(int numerator, int denominator) {

    if(denominator<0){
            numerator = numerator * (-1);
            denominator *= -1;
         }
    
  if(numerator==0){
        this.numerator = 1;
      
    }
    this.numerator = numerator;
        this.denominator = denominator;

        shorten();

  }

  /**
   * Gibt den Nenner zurueck.
   */
  public int getDenominator() {
    return denominator;

  }

  /**
   * Gibt den Zaehler zurueck.
   */
  public int getNumerator() {
    int numerator = 0;
    return numerator += this.numerator;

  }

  /**
   * Gibt den Bruch als Gleitkommazahl zurueck.
   */
  public double toDouble() {
      return  (double) numerator / (double) denominator;
  }

  /**
   * Gibt einen String im Format
   * ""Zaehler/Nenner"" zurueck.
   */
  public String toString() {
     return numerator + ""/"" + denominator;

  }

  /**
   * Kuerzt (vereinfacht) den Bruch.
   */
  public void shorten() {
    int x = GCD(numerator, denominator);
        numerator /= x;
        denominator /= x;
    }



  /**
   * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
   */
  public Fraction add(Fraction f) {
    return new Fraction(
                (this.numerator * f.denominator) + (f.numerator * this.denominator),
                this.denominator * f.denominator);

  }

  /**
   * Multipliziert mit dem uebergebenen Bruch.
   */
  public Fraction multiply(Fraction f) {
    return new Fraction(this.numerator * f.numerator,
                  this.denominator * f.denominator );

  }

  /**
   * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
   * Sonst wird der Bruch unveraendert zurueckgegeben.
   */
  public Fraction reciprocal() {
  return new Fraction(denominator,numerator);
}



  /**
   * Dividiert durch den uebergebenen Bruch
   * (unter Verwendung von Kehrwert und Multiplikation).
   */
  public Fraction divide(Fraction f) {

        return multiply(f.reciprocal());

  }","public class SubwayTest {



    public static void main(String [] args) {
      Subway train = new Subway(3);
      train.countWagon(2);
      train.getSeats(25);
      train.getStandingRoom(30);
      train.getCapacity();
      train.addWagons(25,30);
      train.removeWagon(10,20);
      System.out.println(train.countWagon()+"" Wagons\n""+
    train.getSeats()+"" Seats\n""+
    train.getStandingRoom()+"" Standing Room\n""+
    train.getCapacity()+"" Capacity""
);
train.addWagon(25,30);
for(int i=0;i<5;i++) {
  train.removeWagon();
  System.out.println(
    train.countWagons()+"" Wagons\n""+
    train.getSeats()+"" Seats\n""+
    train.getStandingRoom()+"" Standing Room\n""+
    train.getCapacity()+"" Capacity"";
}

    }
}"
Lindner,Lucie-Marie,l.lindner@campus.tu-berlin.de,Beendet,"20. Januar 2021  16:02","23. Januar 2021  21:42","3 Tage 5 Stunden","17,70","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden können überladen werden","class Rechteck {
    private int breite;

    public void setBreite(int breite) {
        this.breite = breite;
    }

    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest {
    public static void main(String[] args) {

        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
    }
}","void

; private
; static","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden
; Setzen falscher Attributwerte verhindern","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: 0; Teil 12: -; Teil 13: -; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: 0; Teil 20: -; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: 1; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 4 (15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: 1; Teil 82: %; Teil 83: 0; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: 0; Teil 123: 0; Teil 124: 0; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest {
    public static void main(String[] args) {
        Subway u5 = new Subway(3);
        u5.addWagon(new Wagon(30, 90));
        u5.addWagon(new Wagon(25, 100));
        System.out.println(u5.countWagons() + "" Wagons\n"" + u5.getSeats() + "" Seats\n"" + u5.getStandingRoom() + "" Standing Room\n"" + u5.getCapacity() + "" Capacity"");

        u5.addWagon(new Wagon(15, 50));
        u5.addWagon(new Wagon(40, 20));

        for (int i = 0; i < 5; i++) u5.removeWagon();
        System.out.println(u5.countWagons() + "" Wagons\n"" + u5.getSeats() + "" Seats\n"" + u5.getStandingRoom() + "" Standing Room\n"" + u5.getCapacity() + "" Capacity"");
        return;
    }

}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
        if (this.denominator < 0) {
            this.numerator *= -1;
            this.denominator *= -1;
        } else if (this.denominator == 0) {
            this.denominator = 1;
        }
        shorten();

//        System.out.println(""getNumerator: "" + this.getNumerator());
//        System.out.println(""getDenominator: "" + this.getDenominator());
//        System.out.println(""toDouble: "" + this.toDouble());
//
//        final int gcd = Fraction.GCD(this.numerator, this.denominator);
//        System.out.println(""GCD: "" + gcd);
//
//        System.out.println(""toString: "" + this.toString());
//        this.shorten();
//        System.out.println(""toString: "" + this.toString());
    }

//    public static void main(String[] args) {
////        final Fraction[] fractions = new Fraction[]{
////                new Fraction(25, 50),
////                new Fraction(25, -50),
////                new Fraction(-25, 50),
////                new Fraction(-25, -50),
////                new Fraction(5, 0),
////                new Fraction(1, 5),
////                new Fraction(2, 7)
////        };
////
////        System.out.println();
////        System.out.println(""----"");
////
////        System.out.println(fractions[5].toString());
////        System.out.println(fractions[6].toString());
////        fractions[5].add(fractions[6]);
////        fractions[5].multiply(fractions[6]);
////
////        System.out.println(new Fraction(1, 1).divide(new Fraction(1, 2)).toString()); // = 2
//        System.out.println(new Fraction(18, 2).toString()); // 9/1
//        System.out.println(new Fraction(2, 7).add(new Fraction(3, 7)).toString()); // = 5/7
//        System.out.println(new Fraction(1, 7).add(new Fraction(-1, 5)).toString()); // = -2/35
//        System.out.println(new Fraction(2, 3).divide(new Fraction(-2, 3)).toString()); // = -1/1
//    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""5/5"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        final int gcd = Fraction.GCD(this.numerator, this.denominator);
        this.numerator /= gcd;
        this.denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        final int lcm = Fraction.LCM(this.denominator, f.denominator);
        final int num1 = lcm / this.denominator * this.numerator;
        final int num2 = lcm / f.denominator * f.numerator;
        final Fraction result = new Fraction(num1 + num2, lcm);
        result.shorten();
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        final Fraction result = new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
        result.shorten();
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator != 0) {
            final Fraction result = new Fraction(this.denominator, this.numerator);
            result.shorten();
            return result;
        } else {
            return new Fraction(this.numerator, this.denominator);
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }"
Hogel,Stephan,2d485c3a9c60231ba2c51ed3cb4b4cdb,Beendet,"20. Januar 2021  17:18","24. Januar 2021  19:32","4 Tage 2 Stunden","19,72","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","Getter und Setter","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern, dass Attributswerte gesetzt werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","private
; void","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 5; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: 50; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	
	
	
	
    public Fraction(int numerator, int denominator) {
    	if (denominator < 0) { 
    		this.denominator = Math.abs(denominator); 
    		this.numerator = -numerator;
    	} else if (denominator == 0) { 
    		this.denominator = 1; 
    		this.numerator = numerator;
    	} else {
    	    this.numerator = numerator;
            this.denominator = denominator;
    	}
    	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    	int sh = numerator;
    	numerator = numerator/GCD(numerator, denominator);
    	denominator = denominator/GCD(sh, denominator);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int dE = denominator * f.getDenominator();
       int n1E = numerator * f.getDenominator();
       int n2E = f.getNumerator() * denominator;
       return new Fraction(n1E + n2E, dE);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
    }
    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	if (numerator != 0) {
    		int nR = denominator;
    		denominator = numerator;
    		numerator = nR;
    	}
    	return new Fraction(numerator, denominator);
    }
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	f.reciprocal();
    	return this.multiply(f);
    }","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {

	public static void main(String[] args) {

		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity""
		);
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++) u9.removeWagon();
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity""
		);
	}
    }"
Bürgel,Benedikt,b.buergel@campus.tu-berlin.de,Beendet,"21. Januar 2021  04:43","24. Januar 2021  03:09","2 Tage 22 Stunden","17,55","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist",void,"Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 0; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest {
	
	public static void main(String[] args) {
		Subway u5 = new Subway(3);
		u5.addWagon(new Wagon(30,70));
		u5.addWagon(new Wagon(15,25));
		System.out.println(u5.getSeats()+"" Seats \n""
				+u5.getStandingRoom()+"" Standing Room \n""
				+ u5.getCapacity()+"" Capacity"");
		u5.addWagon(new Wagon(17,36));
		u5.addWagon(new Wagon(20,40));
		for(int i=0;i<5;i++){
			u5.removeWagon();
		}
	}
	
	
}","public Fraction(int numerator, int denominator) {
        this.numerator=numerator;
		this.denominator=denominator;
		if(denominator==0){
			numerator=numerator;
			denominator=1;
		}
		if(denominator<0){
			numerator= -numerator;
			denominator= -denominator;
		}
		else{
		numerator=numerator;
		denominator=denominator;
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double x;
        return x=(double) numerator / (double) denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator +""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int ggt= GCD(numerator,denominator);
		if(denominator>0){
		numerator/=ggt;
		denominator/=ggt;
		}	
		else if (denominator<0){
			numerator = -numerator;
			denominator = -denominator;
		}
		else if(denominator==0){
			numerator = numerator;
			denominator = 1;
		}
		

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		numerator=numerator*f.getDenominator()+denominator*f.getNumerator();
		denominator= denominator*f.getDenominator();
		Fraction e=new Fraction(numerator,denominator);
		e.shorten();
		return e;

		
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		numerator=numerator*f.getNumerator();
		denominator=denominator*f.getDenominator();
		Fraction d=new Fraction(numerator,denominator);		
		d.shorten();
		return d;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if(numerator!=0){
			int x= numerator;
			numerator=denominator;
			denominator=x;
			Fraction c=new Fraction(numerator,denominator);
			return c;
		}
		else {
			Fraction d=new Fraction(numerator,denominator);
			return d;
		}
		
		
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction kehrwert= new Fraction(f.getNumerator(),f.getDenominator());
		kehrwert=kehrwert.reciprocal();
		Fraction multiplizieren= new Fraction(kehrwert.getNumerator(),kehrwert.getDenominator());
		Fraction g=new Fraction(numerator,denominator);
		multiplizieren=multiplizieren.multiply(g);
		numerator= multiplizieren.getNumerator();
		denominator=multiplizieren.getDenominator();
		Fraction h=new Fraction(numerator,denominator);


					
		h.shorten();
		return h;
	}"
Dietrich,"Lukas Sebastian",lukas.dietrich@campus.tu-berlin.de,Beendet,"21. Januar 2021  09:48","24. Januar 2021  15:38","3 Tage 5 Stunden","17,74","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Verhindern, dass Attributswerte gesetzt werden

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void

; private
; static","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: undef; Teil 40: undef; Teil 41: undef; Teil 42: 4(15; Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: 0; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: 0; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator_, int denominator_) {
        this.numerator = numerator_;
		this.denominator = denominator_;
		if (denominator_<0){
			this.denominator = denominator * -1;
			this.numerator *= -1;
		}
		else if (denominator_ == 0){
			this.denominator = 1;
		}
		shorten(numerator, denominator);
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double toDouble = (double)numerator / (double)denominator;
		return toDouble;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
	@Override
    public String toString() {
        String ausgeben;
		ausgeben = numerator+""/""+denominator;
		return ausgeben;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten(int numerator, int denominator) {
        int gcd = GCD(numerator, denominator);
		int numeratorKurz = numerator / gcd;
		int denominatorKurz = denominator / gcd;
		
		this.numerator = numeratorKurz;
		this.denominator = denominatorKurz;
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int nA = this.numerator;
		int nB = f.getNumerator();
		int dA = this.denominator;
		int dB = f.getDenominator();
		
		int lcm = LCM(dA, dB);
		
		int fA = lcm / dA;
		int fB = lcm / dB;
		
		int mA = nA * fA;
		int mB = nB * fB;
		
		int newN = mA + mB;
		
		return new Fraction(newN, lcm);
		
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int nA = this.numerator;
		int nB = f.getNumerator();
		int dA = this.denominator;
		int dB = f.getDenominator();
		
		int neuN = nA * nB;
		int neuD = dA * dB;
		
		return new Fraction (neuN, neuD);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if(this.numerator == 0){	
			return new Fraction( this.numerator, this.denominator);
		}else{
			return new Fraction(this.denominator, this.numerator);
		}
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		return multiply(f.reciprocal());
    }","public class SubwayTest  {
	
	public static void main (String[] args){
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(55,43));
		u9.addWagon(new Wagon(34,65));
		System.out.println(
			u9.countWagons()+"" Wagons\n""+
			u9.getSeats()+"" Seats\n""+
			u9.getStandingRoom()+"" Standing Room\n""+
			u9.getCapacity()+"" Capacity""
			);
		u9.addWagon(new Wagon(45,33));
		u9.addWagon(new Wagon(56,45));
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		System.out.println(
			u9.countWagons()+"" Wagons\n""+
			u9.getSeats()+"" Seats\n""+
			u9.getStandingRoom()+"" Standing Room\n""+
			u9.getCapacity()+"" Capacity""
			);
		
	}
	
	
}"
Vorbeck,Tim,tim.vorbeck@campus.tu-berlin.de,Beendet,"21. Januar 2021  10:39","24. Januar 2021  20:21","3 Tage 9 Stunden","19,06","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","void

; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: undef; Teil 40: undef; Teil 41: undef; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: mitte; Teil 61: links; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: 1; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }

    public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }","public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon w1=new Wagon(25,30);
        u9.addWagon(w1);
        Wagon w2=new Wagon(55,45);
        u9.addWagon(w2);
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagon w3=new Wagon(25,35);
        u9.addWagon(w3);
        Wagon w4=new Wagon(12,33);
        u9.addWagon(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagon();
        }
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }
}"
Bloch,"Céline Louisa",c.bloch.1@campus.tu-berlin.de,Beendet,"21. Januar 2021  11:46","24. Januar 2021  23:12","3 Tage 11 Stunden","18,81","Objektmethoden können überladen werden

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","void

; private
; static","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern das Überladen von Methoden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: -; Teil 123: -; Teil 124: -; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
   
		
	public Fraction(int numerator, int denominator) {
     if (denominator == 0) {
            this.denominator =1;
            this.numerator = numerator;
		} else if (denominator < 0) { 
            this.denominator =denominator * -1;
            this.numerator =numerator * -1;
        } else {
            this.numerator =numerator;
            this.denominator =denominator;
		}
		this.shorten(); 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) this.numerator)/this.denominator; // (double) wenn von einer form in die andere konvertiert
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.        
     */
    public void shorten() {
              int reverse = 1;
        if (numerator < 0) {
            reverse = -1;
            numerator = numerator * -1;
        }
        int divide = 0;
        while ( divide != 1) {
            divide = GCD (this.numerator, this.denominator);
            this.denominator = this.denominator / divide;
            this.numerator = this.numerator / divide;
        }
        numerator *= reverse;
    }
    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
      
	this.numerator = (numerator*f.getDenominator()) + (f.getNumerator()*denominator);
		this.denominator = denominator*f.getDenominator();
		return new Fraction(this.numerator,this.denominator); // objekt wird erstellt und direkt abgespeichert
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int x = numerator * f.getNumerator();
		int y = denominator * f.getDenominator();
		Fraction g = new Fraction(x,y);
		return g;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		
       if (getNumerator() != 0) {
		   return new Fraction (denominator, numerator);
		}
		return new Fraction (numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
	  f = f.reciprocal() ;
		return this.multiply(f);
	}","public class SubwayTest {
	public static void main (String [] args) {
	Subway u9 = new Subway(3);
u9.addWagon(new Wagon(25,30));
u9.addWagon(new Wagon(55,45));

System.out.println(u9.countWagons()+"" Wagons\n""+u9.getSeats()+"" Seats\n""+u9.getStandingRoom()+"" Standing Room\n""+u9.getCapacity()+"" Capacity"");

u9.addWagon(new Wagon(20,35));
u9.addWagon(new Wagon(12, 33));
for(int i=0;i<5;i++) u9.removeWagon();

System.out.println(u9.countWagons()+"" Wagons\n""+ u9.getSeats()+"" Seats\n""+ u9.getStandingRoom()+"" Standing Room\n""+u9.getCapacity()+"" Capacity"");
	}
}"
Uth,"Celine Victoria",a06a412970e89d27a5d2a53764297db5,Beendet,"21. Januar 2021  13:50","24. Januar 2021  11:43","2 Tage 21 Stunden","2,58","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Verhindern das Überladen von Methoden","Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten","void

; private
; class","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 3(14); Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 4; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: rechts; Teil 40: %; Teil 41: %; Teil 42: 5; Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: mitte; Teil 49: 6; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: links; Teil 55: %; Teil 56: 7; Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 14; Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 17; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 14; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 15; Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 16; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 17; Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %",-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Ciepielowska,"Maria Aleksandra",maria.ciepielowska@campus.tu-berlin.de,Beendet,"21. Januar 2021  17:00","24. Januar 2021  23:26","3 Tage 6 Stunden","16,29","Getter und Setter","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; In Objektmethoden können lokale Variablen deklariert werden","Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","private
; void","Teil 1: undef; Teil 2: undef; Teil 3: undef; Teil 4: undef; Teil 5: undef; Teil 6: undef; Teil 7: 11(50); Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12(51); Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13(52); Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: 0; Teil 33: 0; Teil 34: 1; Teil 35: 15; Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 16; Teil 43: 1; Teil 44: %; Teil 45: 0; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 17; Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 18; Teil 57: 0; Teil 58: %; Teil 59: %; Teil 60: 0; Teil 61: %; Teil 62: 0; Teil 63: 11; Teil 64: %; Teil 65: undef; Teil 66: undef; Teil 67: undef; Teil 68: undef; Teil 69: undef; Teil 70: 12; Teil 71: %; Teil 72: 0; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 13; Teil 78: %; Teil 79: %; Teil 80: 1; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 14; Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 0; Teil 89: 0; Teil 90: 1; Teil 91: 15; Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 16; Teil 99: 1; Teil 100: %; Teil 101: 1; Teil 102: %; Teil 103: %; Teil 104: 17; Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 18; Teil 112: 0; Teil 113: %; Teil 114: %; Teil 115: 0; Teil 116: %; Teil 117: 0; Teil 118: 11; Teil 119: %; Teil 120: undef; Teil 121: undef; Teil 122: undef; Teil 123: undef; Teil 124: undef; Teil 125: 12; Teil 126: %; Teil 127: 0; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: undef; Teil 133: undef; Teil 134: undef; Teil 135: undef; Teil 136: undef; Teil 137: undef","public class SubwayTest{
	public static void main(String[] args){
		Subway u9 = new Subway(3);
u9.addWagon(new Wagon(25,30));
u9.addWagon(new Wagon(55,45));
System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity""
);
u9.addWagon(new Wagon(20,35));
u9.addWagon(new Wagon(12, 33));
for(int i=0;i<5;i++) u9.removeWagon();
System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity""
);
	
	
	
	
	

	
	
	
	}
	
	
}","public Fraction(int x, int y) {
       
		if(y== 0 ){
			denominator = 1;
			numerator = x;
		}
		if(y<0){
			denominator = y*-1;
			numerator = x*-1;
		}
		if(y>0){
			denominator = y;
			numerator = x;
		}
		shorten();
	} 
	/**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
       
	   return (double)numerator/denominator; 
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return Integer.toString(numerator)+""/""+Integer.toString(denominator);
    }
	 

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
			int nwd = GCD(numerator, denominator);
			numerator = numerator/nwd;
			denominator = denominator/nwd;
			
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int nww = LCM(denominator, f.getDenominator() );
	   int nowynumerator1 = numerator*(nww/denominator);
	  int nowynumerator2 = f.getNumerator()*(nww/f.getDenominator());
	   Fraction ulamek = new Fraction(nowynumerator1+nowynumerator2, nww);	
		return ulamek;
	
	}

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
			int nowynumerator = numerator*f.getNumerator();
			int nowydenominator = denominator*f.getDenominator();
		Fraction ulamek = new Fraction(nowynumerator, nowydenominator);
		return ulamek;
	}

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
     Fraction ulamek;
	   if(numerator!=0){
		    ulamek = new Fraction (denominator, numerator);
	   }
	   else{
		   ulamek = new Fraction(numerator,denominator);
			
	   }
	   return ulamek;
   }
	
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
      Fraction ulamek = multiply(f.reciprocal()) ;
	  return ulamek;
    }"
Weiß,Jasmina,jasmina.weiss@campus.tu-berlin.de,Beendet,"21. Januar 2021  21:12","24. Januar 2021  22:56","3 Tage 1 Stunde","10,90","Getter und Setter",void,"Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: 5; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: 1; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: -; Teil 123: -; Teil 124: -; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest {
	public static void main(String[] args) {
		Subway u9 = new Subway(3);		
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
			    u9.countWagons()+"" Wagons\n""+
			    u9.getSeats()+"" Seats\n""+
			    u9.getStandingRoom()+"" Standing Room\n""+
			    u9.getCapacity()+"" Capacity"");
		u9.addWagon(new Wagon (20, 35));
		u9.addWagon(new Wagon (12,33));
		for(int i=0; i<5; i++) {
			u9.removeWagon();
		}
		System.out.println(
			    u9.countWagons()+"" Wagons\n""+
			    u9.getSeats()+"" Seats\n""+
			    u9.getStandingRoom()+"" Standing Room\n""+
			    u9.getCapacity()+"" Capacity"");
		
	}

}","public int kürzungszahl;
	public int erweiterungszahl;

	public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
	}
	public int getDenominator() {
		if (denominator < 0) {
			denominator = -denominator;
		} else if (denominator == 0) {
			denominator = 1;
		}
		return denominator;

	}


	public int getNumerator() {
		return numerator;
	}

	
	public double toDouble() {
		double Bruch = numerator / denominator;
		return Bruch;
	}
	public String toString() {
		String Bruch = +numerator + ""/"" + denominator;
		return Bruch;
	}

	public void shorten() {
		numerator /= kürzungszahl;
		denominator /= kürzungszahl;
	}

	public Fraction add(Fraction f) {
		int b= f.denominator % denominator;
		int a = f.numerator + numerator;
		a= a/b;
		return new Fraction(a, b);

	}

	public Fraction multiply(Fraction f) {
		int x = f.numerator * numerator;
		int y = f.denominator * denominator;
		return new Fraction(x, y);
	}
	public Fraction reciprocal() {
		if (numerator != 0) {
			this.denominator = numerator;
			this.numerator = denominator;
			return new Fraction(this.denominator, this.numerator);
		}else {
		return new Fraction(numerator, denominator);
		}

	}
	public Fraction divide(Fraction f) {
		f.reciprocal();
		f.multiply(f);
		return new Fraction (f.numerator, f.denominator);

	}"
Morsalpoor,Mohadese,m.morsalpoor@tu-berlin.de,Beendet,"21. Januar 2021  22:08","24. Januar 2021  13:25","2 Tage 15 Stunden","18,55","Getter und Setter","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","private
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest{
	public static void main(String[] args){
		Subway u=new Subway(3);
		Wagon w1=new Wagon(25,30);
		Wagon w2=new Wagon(55,45);
		u.addWagon(w1);
		//System.out.println(u.countWagons());
		u.addWagon(w2);
		//System.out.println(u.countWagons());
		System.out.println(u.countWagons()+"" Wagons\n""+u.getSeats()+"" Seats\n""+u.getStandingRoom()+"" Standing Room\n""+u.getCapacity()+"" Capacity"");
		Wagon w3=new Wagon(100,150);
		Wagon w4=new Wagon(110,160);
		u.addWagon(w3);
		u.addWagon(w4);
		for(int i=0;i<5;i++) u.removeWagon();
		System.out.println(u.countWagons()+"" Wagons\n""+u.getSeats()+"" Seats\n""+u.getStandingRoom()+"" Standing Room\n""+u.getCapacity()+"" Capacity"");
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator<0){
			numerator*=-1;
			denominator*=-1;
		}
		if (denominator==0){
			denominator=1;
		}
		this.numerator=numerator;
		this.denominator=denominator;
		shorten();
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator / (double) denominator;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s= numerator+""/""+denominator;
		return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int common= GCD(numerator,denominator);
		numerator=numerator/common;
		denominator=denominator/common;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        Fraction sum=new Fraction(numerator,denominator);
		sum.denominator=denominator*f.denominator;
		sum.numerator=numerator*f.denominator+denominator*f.numerator;
		sum.shorten();
		return sum;
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction product=new Fraction(numerator,denominator);
		product.numerator=numerator*f.numerator;
		product.denominator=denominator*f.denominator;
		product.shorten();
		return product;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction inverse=new Fraction(numerator,denominator);
	 
	    if (this.numerator!=0){
		   inverse.numerator=this.denominator;
		   inverse.denominator=this.numerator;
	   }
	   inverse.shorten();
	   return inverse;
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction result=new Fraction(numerator,denominator);
		result=result.multiply(f.reciprocal());
		return result;
       
    }"
Korn,"Eric Rene",eric.korn@campus.tu-berlin.de,Beendet,"22. Januar 2021  18:58","23. Januar 2021  22:21","1 Tag 3 Stunden","19,40","void

; private","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern, dass Attributswerte gesetzt werden","Getter und Setter","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden können überladen werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: l; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: m; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: l; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        //Fall Nenner = 0 abfangen:
        if (denominator == 0)
            denominator = 1;

        //ggf Vorzeichen anpassen: (für Fälle (-/-) & (+/-))
        if ((numerator < 0 && denominator < 0) || (numerator > 0 && denominator < 0)) {
            numerator *= (-1);
            denominator *= (-1);
        }
        
        this.numerator = numerator;
        this.denominator = denominator;
        
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) this.numerator / (double) this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (this.numerator + ""/"" + this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        //ggT bestimmen:
        int ggT = GCD(this.numerator, this.denominator);
        
        //kürzen:
        if (ggT != 1 && ggT != 0) {
            this.numerator /= ggT;
            this.denominator /= ggT;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int nenner1 = this.denominator;
        int nenner2 = f.getDenominator();
        int kgV = LCM(nenner1, nenner2);

        int zaehler1 = this.numerator * (kgV / nenner1);
        int zaehler2 = f.getNumerator() * (kgV / nenner2);
        int sumZaehler = zaehler1 + zaehler2;
        return new Fraction(sumZaehler, kgV);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction((this.numerator * f.getNumerator()), (this.denominator * f.getDenominator()));
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator != 0) {
           int s = this.denominator;
           this.denominator = this.numerator;
           this.numerator = s;
       }
       return new Fraction(this.numerator, this.denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f = f.reciprocal();
       return multiply(f);
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {
    public static void main(String[] args) throws Exception {
        Subway uBahn = new Subway(3);
        uBahn.addWagon(new Wagon(5, 10));
        uBahn.addWagon(new Wagon(22, 30));
        p(uBahn.getSeats() + "" Seats"");
        p(uBahn.getStandingRoom() + "" Standing Room"");
        p(uBahn.getCapacity() + "" Capacity"");
        uBahn.addWagon(new Wagon(15, 20));
        uBahn.addWagon(new Wagon(30, 40));
        for (int i = 0; i < 5; i++) {
            uBahn.removeWagon();
        }
    }

    public static void p(String s) {
        System.out.println(s);
    }
}"
Brockhaus,"Clara Madeleine",c.brockhaus@campus.tu-berlin.de,Beendet,"23. Januar 2021  13:45","24. Januar 2021  23:31","1 Tag 9 Stunden","19,08","void

; private
; static","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; Objektmethoden können überladen werden","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern das Überladen von Methoden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {
	
	public static void main(String[] args) {
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(57, 120));
		u9.addWagon(new Wagon(80, 100));
		System.out.println(u9.getSeats()+"" Seats\n""
			+u9.getStandingRoom()+"" Standing Room\n""+u9.getCapacity()+"" Capacity"");
		u9.addWagon(new Wagon(43, 22));
		u9.addWagon(new Wagon(59, 110));
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
	 	this.numerator = numerator;
	 	this.denominator = denominator;
	 	this.getNumerator();
	 	this.getDenominator();
	 	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		if (denominator == 0) {
			denominator = 1;
		}
		else if (denominator <= 0) {
			denominator *= -1;
		}
		return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		if (numerator < 0 && denominator < 0) {
		    	 numerator = numerator*-1;
		 } else if (numerator > 0 && denominator < 0) {
		    		numerator = numerator*-1;
		 }
		 return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double gleitkomma = (double)numerator/denominator;
		return gleitkomma;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String stringbruch = this.numerator+""/""+this.denominator;
		return stringbruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int gcd = GCD(this.numerator,this.denominator);
		this.numerator = this.numerator/gcd;
		this.denominator = this.denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int lcm = LCM(this.denominator,f.denominator);
		int denominator2 = lcm;
		int a = lcm/this.denominator;
		int b = lcm/f.denominator;
		int numerator2 = this.numerator*a + f.numerator*b;
		return new Fraction(numerator2,denominator2);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int numerator2 = f.numerator*this.numerator;
		int denominator2 = f.denominator*this.denominator;
		return new Fraction(numerator2, denominator2);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if (this.numerator != 0) {
			return new Fraction(this.denominator,this.numerator);
		}
		else{
			return new Fraction(this.numerator,this.denominator);
		}
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction bruch1 = f.reciprocal();
		Fraction bruch2 = this.multiply(bruch1);
     	return new Fraction(bruch2.numerator,bruch2.denominator);
    }"
Hofmann,Timo,timo.hofmann@campus.tu-berlin.de,Beendet,"23. Januar 2021  15:27","24. Januar 2021  16:37","1 Tag 1 Stunde","19,57","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void

; private","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen","Getter und Setter","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: l; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: m; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: l; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0){
            denominator = 1;
        }

        if (denominator < 0){
            denominator *= -1;
            numerator *= -1;
        }

        this.numerator = numerator;
        this.denominator = denominator;

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double num = this.numerator;
        double den = this.denominator;

        return num/den;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {

        int gcd = GCD(this.numerator, this.denominator);

        if (gcd != 1){
            this.numerator /= gcd;
            this.denominator /= gcd;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int num = f.getNumerator();
        int den = f.getDenominator();

        int lcm = LCM(this.denominator, den);

        // Ersten Bruch erweitern
        int a = lcm / this.denominator;
        int a_num = a * this.numerator;

        // Zweiten Bruch erweitern
        int b = lcm / den;
        int b_num = b * num;

        int num_final = a_num + b_num;

        return new Fraction(num_final, lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int num = this.numerator * f.getNumerator();
        int den = this.denominator * f.getDenominator();

        return new Fraction(num, den);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator == 0){
            return this;
        }
        return new Fraction(this.denominator, this.numerator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f = f.reciprocal();

        return this.multiply(f);
    }","public class SubwayTest {

    public static void main(String[] args){

        Subway u2 = new Subway(3);
        u2.addWagon(new Wagon(30, 30));
        u2.addWagon(new Wagon(25, 25));

        System.out.println(u2.getSeats()+"" Seats"");
        System.out.println(u2.getStandingRoom()+"" Standing Room"");
        System.out.println(u2.getCapacity()+"" Capacity"");

        u2.addWagon(new Wagon(10, 10));
        u2.addWagon(new Wagon(15, 15));

        for (int i = 0; i < 5; i ++) u2.removeWagon();
    }
}"
Padberg,"Ruben Bernhard",ruben.padberg@campus.tu-berlin.de,Beendet,"23. Januar 2021  15:37","24. Januar 2021  18:12","1 Tag 2 Stunden","18,59","void

; private","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden können überladen werden","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest{
	public static void main (String[] args){
		Subway u9 = new Subway(3);
u9.addWagon(new Wagon(25,30));
u9.addWagon(new Wagon(55,45));
System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity""
);
u9.addWagon(new Wagon(20,35));
u9.addWagon(new Wagon(12, 33));
for(int i=0;i<5;i++) u9.removeWagon();
System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity""
);
	}
}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;

        if (denominator == 0)
            this.denominator = 1;
        else if (denominator < 0) {
            this.denominator = (-1) * denominator;
            this.numerator = (-1) * this.numerator;
        } else
            this.denominator = denominator;

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return this.numerator / ((double) this.denominator);
    }

    /**
     * Gibt einen String im Format ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (this.getNumerator() + ""/"" + this.getDenominator());
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int x = this.numerator;
        int y = this.denominator;
        if (this.numerator < 0)
            x = this.numerator * (-1);
        if (this.denominator < 0)
            y = this.denominator * (-1);
        int divisor = GCD(x, y);
        this.numerator = this.numerator / divisor;
        this.denominator = this.denominator / divisor;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int rNumerator = f.denominator * this.numerator + this.denominator * f.numerator;
        int rDemoninator = f.denominator * this.denominator;
        Fraction result = new Fraction(rNumerator, rDemoninator);
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int rNumerator = this.numerator * f.numerator;
        int rDemoninator = this.denominator * f.denominator;
        Fraction result = new Fraction(rNumerator, rDemoninator);
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist. Sonst wird der Bruch
     * unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator == 0) {
            return this;
        } else {
            Fraction inverted = new Fraction(this.denominator, this.numerator);
            return inverted;
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch (unter Verwendung von Kehrwert und
     * Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return multiply(f.reciprocal());

    }"
Kilic,Ceren,ceren.kilic@campus.tu-berlin.de,Beendet,"23. Januar 2021  16:10","24. Januar 2021  19:47","1 Tag 3 Stunden","12,64","void

; private","Getter und Setter","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 1; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {
    public static void main(String[] args) {
        Subway u2 = new Subway(3);
        u2.addWagon(new Wagon(25,30));
        u2.addWagon(new Wagon(43,23));
        System.out.println(
            u2.countWagons()+ "" Wagons\n""+
            u2.getSeats()+ "" Seats\n""+
            u2.getStandingRoom()+ "" Standing Room\n""+
            u2.getCapacity()+ "" Capacity""
        );

        u2.addWagon(new Wagon(31,50));
        u2.addWagon(new Wagon(42,46));
        for(int i=0; i<5;i++) u2.removeWagon();
        System.out.println(
            u2.countWagons()+ "" Wagons\n""+
            u2.getSeats()+ "" Seats\n""+
            u2.getStandingRoom()+ "" Standing Room\n""+
            u2.getCapacity()+ "" Capacity""
        );
    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0){
            this.numerator= -1*numerator;
            this.denominator= -1*denominator;
        }
        else if(denominator==0){
        
            this.numerator=numerator;
            this.denominator=1;
        }
        else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
            
       shorten() ;
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
       
       
       return (double) numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String b = numerator+""/""+ denominator;
        return b;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int shrt = GCD(numerator, denominator);
        numerator /= shrt;
        denominator /= shrt;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(denominator, f.denominator);
       int d = lcm/denominator;
       int e = lcm/ f.denominator;
       return new Fraction(numerator*d + f.numerator*e, lcm);
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.numerator, denominator*f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       boolean c = numerator != 0;
       if(c)
       return new Fraction(denominator,numerator);
       else
       return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    
    }"
Heyde,Jan-Frederik,heyde@campus.tu-berlin.de,Beendet,"23. Januar 2021  16:32","24. Januar 2021  19:33","1 Tag 3 Stunden","19,42","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Verhindern, dass Attributswerte gesetzt werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","void

; private","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: 50; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	
	
	
	
    public Fraction(int numerator, int denominator) {
    	if (denominator < 0) { 
    		this.denominator = Math.abs(denominator); 
    		this.numerator = -numerator;
    	} else if (denominator == 0) { 
    		this.denominator = 1; 
    		this.numerator = numerator;
    	} else {
    	    this.numerator = numerator;
            this.denominator = denominator;
    	}
    	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    	int tmp = numerator;
    	numerator = numerator/GCD(numerator, denominator);
    	denominator = denominator/GCD(tmp, denominator);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int deEx = denominator * f.getDenominator();
       int n1 = numerator * f.getDenominator();
       int n2 = f.getNumerator() * denominator;
       return new Fraction(n1 + n2, deEx);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	if (numerator != 0) {
    		int nNew = denominator;
    		denominator = numerator;
    		numerator = nNew;
    	}
    	return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	f.reciprocal();
    	return this.multiply(f);
    }","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {

	public static void main(String[] args) {

		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity""
		);
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++) u9.removeWagon();
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity""
		);
	}

}"
Shen,Yishu,yishu.shen@campus.tu-berlin.de,Beendet,"23. Januar 2021  16:38","24. Januar 2021  15:59","23 Stunden 21 Minuten","18,87","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","private
; void","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: l; Teil 40: m; Teil 41: r; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: l; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: l; Teil 89: m; Teil 90: r; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: l; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 0; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon w1=new Wagon(25,30);
        u9.addWagon(w1);
        Wagon w2=new Wagon(55,45);
        u9.addWagon(w2);
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagon w3=new Wagon(25,35);
        u9.addWagon(w3);
        Wagon w4=new Wagon(12,33);
        u9.addWagon(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagon();
        }
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }
}","public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }

    public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }"
Kolberg,"Niklas Moritz",niklas.m.kolberg@campus.tu-berlin.de,Beendet,"23. Januar 2021  18:54","24. Januar 2021  22:30","1 Tag 3 Stunden","15,49","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden können überladen werden","void

; private","Getter und Setter","Verhindern das Überladen von Methoden
; Verhindern, dass Attributswerte gesetzt werden

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Setzen falscher Attributwerte verhindern","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: 0; Teil 33: 0; Teil 34: 1; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: %; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: 1; Teil 82: 0; Teil 83: 0; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: 0; Teil 130: 0; Teil 131: 0; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest {

	public static void main(String[] args) {
		Subway sub = new Subway(3);
		sub.addWagon(new Wagon(23,25));
		sub.addWagon(new Wagon(33,42));
		System.out.println(sub.countWagons()+"" Wagons"");
		System.out.println(sub.getSeats()+"" Seats"");
		System.out.println(sub.getStandingRoom()+"" Standing Room"");
		System.out.println(sub.getCapacity()+"" Capacity"");
		sub.addWagon(new Wagon(54,12));
		sub.addWagon(new Wagon(22,11));
		sub.removeWagon();
		sub.removeWagon();
		sub.removeWagon();
		sub.removeWagon();
		sub.removeWagon();
		System.out.println(sub.countWagons()+"" Wagons"");
		System.out.println(sub.getSeats()+"" Seats"");
		System.out.println(sub.getStandingRoom()+"" Standing Room"");
		System.out.println(sub.getCapacity()+"" Capacity"");
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            this.numerator *= -1;
        }
    	if (denominator == 0) {
    		this.denominator = 1;	    		
    	}	
    	this.numerator = numerator;
    	this.denominator = denominator; 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) numerator)/((double) denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int i = Math.min(Math.abs(numerator), Math.abs(denominator));
    	
    	   if (i == 0)
    		   return;
    	   
    	   while ((numerator % i != 0) || (denominator % i != 0)) 
    		   i--;
    	   numerator   = numerator  / i; 
    	   denominator = denominator / i;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction sum = new Fraction(numerator * f.denominator + denominator * f.numerator,denominator * f.denominator); 
    	sum.shorten(); 
    	return sum; 
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction product = new Fraction(numerator * f.numerator, denominator * f.denominator);
        product.shorten();
        return product;  
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator != 0) {
    	Fraction temp = new Fraction(denominator, numerator);
		return temp;
    }
    	else return this; 
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f.multiply(reciprocal());
    	 f.shorten();
    	 return f;
    }"
Arimbawa,"Made Niro Aditya",arimbawa@campus.tu-berlin.de,Beendet,"23. Januar 2021  20:39","24. Januar 2021  05:34","8 Stunden 54 Minuten","17,49","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden können überladen werden","Getter und Setter","private
; void","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: 1; Teil 72: %; Teil 73: 0; Teil 74: -; Teil 75: -; Teil 76: -; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 1; Teil 90: 0; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: 1; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: 0; Teil 120: %; Teil 121: %; Teil 122: -; Teil 123: -; Teil 124: -; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if ((denominator < 0)){
			this.denominator = (denominator * (-1));
			this.numerator = (numerator * (-1));
		}
		else{ 
		this.denominator = denominator; 
		this.numerator = numerator;
		}
		if (denominator == 0){ 
		this.denominator = 1; 
		}
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() { 
	double den =  Double.valueOf(this.denominator);
	double num = Double.valueOf(this.numerator);
	double doub = num/den;
	return doub;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = +this.numerator+""/""+this.denominator;
		return str;
		
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		if (gcd == 0){
			this.numerator = this.numerator;
		this.denominator = this.denominator;
		}
		else{ 
		
		if (gcd < 0) {
			gcd = gcd * (-1); 
		}
		this.numerator = this.numerator / gcd;
		this.denominator = this.denominator/ gcd;
    }
	}

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
	   this.numerator = (this.numerator * (lcm/this.denominator)) + (f.numerator * (lcm/f.denominator)); 
	   this.denominator = lcm;
	 this.shorten();
	  int num = this.numerator;
	   int den = this.denominator;
	Fraction g = new Fraction(num, den);
	 return g; 
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator = this.numerator *  f.numerator; 
	   this.denominator = this.denominator * f.denominator;
	   this.shorten();
	   int num = this.numerator;
	   int den = this.denominator;
	Fraction g = new Fraction(num, den);
	 return g; 
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		 int num = this.numerator; 
		 int den = this.denominator;
		 if (this.numerator == 0){
		 }
		 else { 
			this.numerator = den; 
			this.denominator = num;
		 }
	 num = this.numerator;
	 den = this.denominator;
	Fraction g = new Fraction(num, den);
	 return g; 
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		f.reciprocal();
        this.numerator = this.numerator *  f.numerator; 
	   this.denominator = this.denominator * f.denominator;
	   this.shorten();
	   int num = this.numerator;
	   int den = this.denominator;
	Fraction g = new Fraction(num, den);
	 return g; 
    }","//Hier soll die Klasse UBahnDemo stehen!\
public class SubwayTest{
	public static void main (String[]args){
	Subway a =  new Subway(3); 
	Wagon x = new Wagon(5,10);
	Wagon y = new Wagon(3,4);
	a.addWagon(x); 
	a.addWagon(y);
	System.out.println(+a.getSeats()+ ""\n"" + a.getStandingRoom() + ""\n"" + a.getCapacity());
	Wagon z1 = new Wagon(4,6);
	Wagon z2 = new Wagon(1,1);
	a.addWagon(z1);
	a.addWagon(z2);
	System.out.println(a.countWagons());
	
		for (int i=0; i<5; i++){
		a.removeWagon();
		}
	 
	}
}"
Napiwotzki,Nicklas,n.napiwotzki@campus.tu-berlin.de,Beendet,"24. Januar 2021  15:28","24. Januar 2021  21:14","5 Stunden 45 Minuten","19,75","class Rechteck { 
    protected int breite;
    
    protected void setBreite(int breite) {
        this.breite = breite;
    }
    
    protected int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Setzen falscher Attributwerte verhindern

; Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","void

; static

; private","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator=numerator;
		this.denominator=denominator;
        if(this.denominator==0){
			this.denominator=1;
		}
		if(this.denominator<0){
			this.denominator=this.denominator*(-1);
			this.numerator=this.numerator*(-1);
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double a = this.numerator;
		double b = this.denominator;
		return a/b;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch;
		bruch = numerator+""/""+denominator;
        return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int t;
		t=GCD(this.numerator,this.denominator);
		this.numerator=this.numerator/t;
		this.denominator=this.denominator/t;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int v;
	   int a;
	   int b;
       v=LCM(this.denominator,f.getDenominator());
	   a=v/this.denominator;
	   b=v/f.getDenominator();
	   this.numerator=a*this.numerator+b*f.getNumerator();
	   this.denominator=a*this.denominator;
	   Fraction c = new Fraction(this.numerator, this.denominator);
	   return c;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator=this.numerator*f.getNumerator();
		this.denominator=this.denominator*f.getDenominator();
		Fraction b = new Fraction(this.numerator, this.denominator);
		return b;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       int n;
		int d;
		n=this.numerator;
		d=this.denominator;
       if(this.numerator==0){
		   Fraction b = new Fraction(this.numerator, this.denominator);
		   return b;
	   }
	   else{
		   this.numerator=d;
		   this.denominator=n;
		   Fraction b = new Fraction(this.numerator, this.denominator);
		   return b;
	   }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       multiply(f.reciprocal());
	   Fraction b = new Fraction(this.numerator, this.denominator);
	   return b;
    }","class SubwayTest{
	public static void main (String[] args){
		Subway u1 = new Subway(3);
		u1.addWagon(new Wagon(25,30));
		u1.addWagon(new Wagon(55,45));
		System.out.println(
			u1.countWagons()+"" Wagons\n""+
			u1.getSeats()+"" Seats\n""+
			u1.getStandingRoom()+"" Standing Room\n""+
			u1.getCapacity()+"" Capacity""
		);
		u1.addWagon(new Wagon(20,35));
		u1.addWagon(new Wagon(12,33));
		for(int i=0; i<5;i++) u1.removeWagon();
		System.out.println(
			u1.countWagons()+"" Wagons\n""+
			u1.getSeats()+"" Seats\n""+
			u1.getStandingRoom()+"" Standing Room\n""+
			u1.getCapacity()+"" Capacity""
		);
	}
}"
Birke,"Matthias Benedict",benedict.birke@campus.tu-berlin.de,Beendet,"24. Januar 2021  17:05","24. Januar 2021  23:25","6 Stunden 19 Minuten","16,87","static

; private
; void","class Rechteck { 
    public int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; Objektmethoden modellieren das Verhalten von Objekten","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Getter und Setter","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: 0; Teil 33: 0; Teil 34: 1; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: %; Teil 40: %; Teil 41: %; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 0; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: %; Teil 68: %; Teil 69: %; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: 1; Teil 82: 0; Teil 83: 0; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: %; Teil 89: %; Teil 90: %; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: %; Teil 116: %; Teil 117: %; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: 0; Teil 130: 0; Teil 131: 0; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","public class SubwayTest {


    public static void main(String[] args) {

        Subway sub1 = new Subway(3);

        sub1.addWagon(new Wagon(3, 4));
        sub1.addWagon(new Wagon(5,6));

        System.out.println(sub1.getSeats());
        System.out.println(sub1.getStandingRoom());
        System.out.println(sub1.getCapacity());

        sub1.addWagon(new Wagon(1,1));
        sub1.addWagon(new Wagon(2,2));

        sub1.removeWagon();
        sub1.removeWagon();
        sub1.removeWagon();
        sub1.removeWagon();
        sub1.removeWagon();


    }

}","public Fraction(int numerator, int denominator) {
        
        if(denominator<0){
          
        numerator=0-numerator;
        denominator=0-denominator;
            
        }
        else if(denominator==0){
            denominator=1;
        }
        this.numerator=numerator;
        this.denominator=denominator;
        this.shorten();
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    	
    	double n= this.numerator;
    	double d= this.denominator;
    	return (n/d);
    	
    	
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
       return new String(String.valueOf(this.numerator)+""/""+String.valueOf(this.denominator));
    	
    	
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator,this.denominator);
        if(gcd<0) {
        	gcd=0-gcd;
        }
        
        this.numerator=this.numerator/gcd;
        this.denominator=this.denominator/gcd;
    	
    	
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    	if(this.denominator==f.denominator) {
    		Fraction r=new Fraction(this.numerator+f.numerator,this.denominator);
    	    return r;
    	}
    
    	
    	else {
    		int lcm= LCM(this.denominator, f.denominator);
    		Fraction r=new Fraction(this.numerator*f.denominator+f.numerator*this.denominator,lcm);
    		
    		
    		return r;
    		
    	}
    
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    	Fraction r=new Fraction(this.numerator*f.numerator,this.denominator*f.denominator);
       	return r;
    	
    	
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    	if(this.numerator==0) {
    		return this;
    	}
    	Fraction r= new Fraction(this.denominator,this.numerator);
    	return r;
    	
    	
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    	Fraction r= this.multiply(f.reciprocal());
    	return r;
    	
    	
    }"
Seidel,Frithjof,frithjof.seidel@campus.tu-berlin.de,Beendet,"24. Januar 2021  17:44","24. Januar 2021  23:01","5 Stunden 16 Minuten","12,70","Getter und Setter","static

; private
; void","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 51; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","public class SubwayTest {
	
	public static void main (String[] args) {
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(u9.getSeats());
		System.out.println(u9.getStandingRoom());
		System.out.println(u9.getCapacity());
		u9.addWagon(new Wagon(0,0));
		u9.addWagon(new Wagon(0,0));
		
		for (int i=0;i<5;i++) {
			u9.removeWagon();
		}
		
	}
	
}"
Neß,"Jonas Lennart",jonas.ness@campus.tu-berlin.de,Beendet,"24. Januar 2021  18:05","24. Januar 2021  19:54","1 Stunde 49 Minuten","11,63","Zugriff auf private Attribute ermöglichen
; Inkonsistenzen beim Ändern von Attributwerten vermeiden","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","private
; static

; void","Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: 0; Teil 41: 1; Teil 42: 4(15); Teil 43: %; Teil 44: %; Teil 45: %; Teil 46: 1; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: %; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: %; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: %; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: %; Teil 133: %; Teil 134: %; Teil 135: %; Teil 136: %; Teil 137: %","public class SubwayTest{
	
	public static void main(String[] args){
		Subway U1 = new Subway(3);
		Wagon N1 = new Wagon(10, 20);
		Wagon N2 = new Wagon(15, 20);
		Wagon N3 = new Wagon(5, 10);
		Wagon N4 = new Wagon(30, 50);
		
		U1.addWagon(N1);
		U1.addWagon(N2);
		
		System.out.println(U1.getSeats());
		System.out.println(U1.getStandingRoom());
		System.out.println(U1.getCapacity());
		
		U1.addWagon(N3);
		U1.addWagon(N4);
		
		U1.removeWagon();
		U1.removeWagon();
		U1.removeWagon();
		U1.removeWagon();
		U1.removeWagon();
	}
	
	
	
	
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Heuer,"Lukas Paul Ernst",heuer.1@campus.tu-berlin.de,Beendet,"24. Januar 2021  18:49","24. Januar 2021  23:59","5 Stunden 9 Minuten","18,11","class Rechteck {
    private int breite;
    public Rechteck( int breite){
      this.breite = breite;
    }
    public void setBreite(int breite) {
        this.breite = breite;
    }
    public int getBreite() {
        return this.breite;
    }
    }
    public class RechteckTest
    {
	public static void main(String[] args)  {	
	Rechteck r = new Rechteck(5);
    System.out.println("""" + r.getBreite());
	}
}","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","static

; void","Getter und Setter","Objektmethoden können überladen werden

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; In Objektmethoden können lokale Variablen deklariert werden

; Objektmethoden modellieren das Verhalten von Objekten","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 0; Teil 40: %; Teil 41: 1; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: %; Teil 53: %; Teil 54: %; Teil 55: 0; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 1; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: 1; Teil 72: 0; Teil 73: 0; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 1; Teil 89: 0; Teil 90: 0; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: 0; Teil 96: 0; Teil 97: 0; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 0; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: 0; Teil 120: 0; Teil 121: 0; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: -; Teil 136: -; Teil 137: -","/**
  * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
  * uebergeben bekommt und die entsprechenden Attribute setzt.
  * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
  * auftreten (nicht im ""denominator""-Attribut).
  * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
  * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
  * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
  * und der Wert des Bruchs (die Argumente) unverändert bleibt
  * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
  * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
  * auf Eins gesetzt.
  * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
  */
public Fraction(int numerator, int denominator) {
   this.numerator = numerator;
   this.denominator = denominator;
   if(this.denominator == 0) this.denominator = 1;
   if(this.denominator<0){
     this.numerator=numerator*(-1);
     this.denominator= denominator*(-1);
   }
   shorten();
 }
 /**
  * Gibt den Nenner zurueck.
  */
 public int getDenominator() {
   return this.denominator;
 }
/**
  * Gibt den Zaehler zurueck.
  */
 public int getNumerator() {
   return this.numerator;
 }
/**
  * Gibt den Bruch als Gleitkommazahl zurueck.
  */
 public double toDouble() {
   double gleitK = (double)this.numerator/(double)this.denominator;
   return gleitK;
 }
/**
  * Gibt einen String im Format
  * ""Zaehler/Nenner"" zurueck.
  */
 public String toString() {
   String str = this.numerator+""/""+this.denominator;
   return str;
 }
/**
  * Kuerzt (vereinfacht) den Bruch.
  */
 public void shorten() {
   int klGeNe = GCD(this.numerator, this.denominator);
   this.numerator = this.numerator/klGeNe;
   this.denominator = this.denominator/klGeNe;
 }
/**
  * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
  */
 public Fraction add(Fraction f) {
   int geNe = this.denominator*f.denominator;
   int num = f.numerator*this.denominator + f.denominator*this.numerator;
   int den = geNe;
   Fraction add = new Fraction(num, den);
   add.shorten();
   return add;
 }
/**
  * Multipliziert mit dem uebergebenen Bruch.
  */
 public Fraction multiply(Fraction f) {
   int num = this.numerator*f.numerator;
   int den = this.denominator*f.denominator;
   Fraction mult = new Fraction(num, den);
   mult.shorten();
   return mult;
 }
/**
  * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
  * Sonst wird der Bruch unveraendert zurueckgegeben.
  */
  public Fraction reciprocal() {
    Fraction reciproc = new Fraction(0,0);
    if(this.numerator!=0){
      int tmp = this.numerator;
      reciproc.numerator = this.denominator;
      reciproc.denominator = tmp;
      return reciproc;
    }else{
    reciproc.numerator = this.denominator;
    reciproc.denominator = this.numerator;
    return reciproc;
   }
  }
 /**
  * Dividiert durch den uebergebenen Bruch
  * (unter Verwendung von Kehrwert und Multiplikation).
  */
 public Fraction divide(Fraction f) {
   int num = this.numerator*f.denominator;
   int den = this.denominator*f.numerator;
   Fraction teile = new Fraction(num, den);
   teile.shorten();
   return teile;
 }","public class SubwayTest{

  public static void main(String[] args) {

    Subway u9 = new Subway(3);
    u9.addWagon(new Wagon(25,30));
    u9.addWagon(new Wagon(55,45));
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");
u9.addWagon(new Wagon(20,35));
    u9.addWagon(new Wagon(12,33));
    for(int i=0;i<5;i++) u9.removeWagon();
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");
}
}"
Schellong,"Sören Rafael",r.schellong@campus.tu-berlin.de,Beendet,"24. Januar 2021  19:08","24. Januar 2021  22:34","3 Stunden 26 Minuten","20,00","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Getter und Setter","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Inkonsistenzen beim Ändern von Attributwerten vermeiden","private
; void","Objektmethoden können überladen werden

; Objektmethoden modellieren das Verhalten von Objekten

; In Objektmethoden können lokale Variablen deklariert werden","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %","public Fraction(int numerator, int denominator) {
        if(denominator == 0){
			this.denominator = 1;
			this.numerator = numerator;
		}
		else if(denominator < 0){
			this.denominator = denominator * (-1);
			this.numerator = numerator*(-1);
		}
		else {
		this.numerator = numerator;
		this.denominator = denominator;
		shorten();
		}
    }


    public int getDenominator() {
        return denominator;
    }


    public int getNumerator() {
		return numerator;
    }


    public double toDouble() {
        return ((double)numerator / (double)denominator);
    }


    public String toString() {
		String str = numerator + ""/"" + denominator;
		return str;
    } 


    public void shorten() {
		int temp = 0;
		while (GCD(numerator, denominator) != 1){
			temp = GCD(numerator, denominator);
			numerator /= temp;
			denominator /= temp;
		}
    }


    public Fraction add(Fraction f) {
		int exp = LCM(f.denominator, denominator);
		numerator *= (exp/denominator);
		f.numerator *= (exp/f.denominator);
		numerator += f.numerator;
		denominator = exp;
		Fraction res = new Fraction (numerator, denominator);
		return res;
    }


    public Fraction multiply(Fraction f) {
      numerator *= f.numerator;
	  denominator *= f.denominator;
	   Fraction res = new Fraction (numerator, denominator);
		return res;
    }


    public Fraction reciprocal() {
		int temp = 0;
       if(numerator != 0)
		temp = numerator;
		numerator = denominator;
		denominator = temp;
		Fraction res = new Fraction (numerator, denominator);
		return res;
    }
    

    public Fraction divide(Fraction f) {
		Fraction temp = f.reciprocal();
		Fraction res = multiply(temp);
		return res;
    }","public class SubwayTest {
	
	public static void main (String[] args) {
		Subway newyork = new Subway (3);
		newyork.addWagon(new Wagon(12, 36));
		newyork.addWagon(new Wagon(112, 333));
				
		System.out.println(newyork.getSeats()+ "" Seats\n""
							+ newyork.getStandingRoom()+ "" Standing Room\n""
							+newyork.getCapacity()+ "" Capacity"");
							
		newyork.addWagon(new Wagon(4, 5));
		newyork.addWagon(new Wagon(20, 32));
		
		for(int i=0; i<5; i++) {
			newyork.removeWagon();
		}
	}
}"
Theo,Yovan,yovan.theo@campus.tu-berlin.de,Beendet,"24. Januar 2021  20:12","24. Januar 2021  23:57","3 Stunden 45 Minuten","5,42","Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; Objektmethoden können überladen werden

; In Objektmethoden können lokale Variablen deklariert werden","Getter und Setter","class Rechteck { 
    private int breite;
    
    public void setBreite(int breite) {
        this.breite = breite;
    }
    
    public int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","void

; static

; private","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","Der Name einer Getter-Methode muss vom Schema getAttributsname sein","Teil 1: -; Teil 2: -; Teil 3: -; Teil 4: -; Teil 5: -; Teil 6: -; Teil 7: 11; Teil 8: 0; Teil 9: %; Teil 10: %; Teil 11: %; Teil 12: %; Teil 13: %; Teil 14: 12; Teil 15: %; Teil 16: 0; Teil 17: %; Teil 18: %; Teil 19: %; Teil 20: %; Teil 21: 13; Teil 22: %; Teil 23: %; Teil 24: 1; Teil 25: %; Teil 26: %; Teil 27: %; Teil 28: 14; Teil 29: %; Teil 30: %; Teil 31: %; Teil 32: %; Teil 33: %; Teil 34: %; Teil 35: 3(15); Teil 36: %; Teil 37: %; Teil 38: %; Teil 39: 50; Teil 40: 51; Teil 41: 52; Teil 42: 4(15); Teil 43: 1; Teil 44: %; Teil 45: %; Teil 46: %; Teil 47: %; Teil 48: %; Teil 49: 5(15); Teil 50: %; Teil 51: %; Teil 52: 0; Teil 53: %; Teil 54: %; Teil 55: %; Teil 56: 6(15); Teil 57: %; Teil 58: %; Teil 59: %; Teil 60: %; Teil 61: 50; Teil 62: %; Teil 63: 7(15); Teil 64: %; Teil 65: %; Teil 66: %; Teil 67: -; Teil 68: -; Teil 69: -; Teil 70: 15; Teil 71: %; Teil 72: %; Teil 73: %; Teil 74: %; Teil 75: %; Teil 76: %; Teil 77: 16; Teil 78: %; Teil 79: %; Teil 80: %; Teil 81: %; Teil 82: %; Teil 83: %; Teil 84: 3(17); Teil 85: %; Teil 86: %; Teil 87: %; Teil 88: 50; Teil 89: 51; Teil 90: 52; Teil 91: 4(17); Teil 92: 0; Teil 93: %; Teil 94: %; Teil 95: %; Teil 96: %; Teil 97: %; Teil 98: 5(17); Teil 99: %; Teil 100: %; Teil 101: %; Teil 102: %; Teil 103: %; Teil 104: 6(17); Teil 105: %; Teil 106: %; Teil 107: %; Teil 108: %; Teil 109: 50; Teil 110: %; Teil 111: 7(17); Teil 112: %; Teil 113: %; Teil 114: %; Teil 115: -; Teil 116: -; Teil 117: -; Teil 118: 17; Teil 119: %; Teil 120: %; Teil 121: %; Teil 122: %; Teil 123: %; Teil 124: %; Teil 125: 18; Teil 126: %; Teil 127: %; Teil 128: %; Teil 129: %; Teil 130: %; Teil 131: %; Teil 132: -; Teil 133: -; Teil 134: -; Teil 135: %; Teil 136: %; Teil 137: %",-,-
Gäbel,Lara,lara.gaebel@campus.tu-berlin.de,Beendet,"24. Januar 2021  22:01","24. Januar 2021  22:04","3 Minuten 9 Sekunden","0,92","Getter-Methoden haben in der Regel den Rückgabetyp des betreffenden Attributs","Getter und Setter",void,"Zugriff auf private Attribute ermöglichen","Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);

; In Objektmethoden können lokale Variablen deklariert werden","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:",-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Bosner,Celina,c.bosner@campus.tu-berlin.de,Beendet,"24. Januar 2021  22:21","24. Januar 2021  22:26","4 Minuten 27 Sekunden","0,83","class Rechteck { 
    private int breite;
    
    private void setBreite(int breite) {
        this.breite = breite;
    }
    
    private int getBreite() {
        return this.breite;
    }
}

public class RechteckTest
{
	public static void main(String[] args)  {	
		
        Rechteck r = new Rechteck();
        r.setBreite(5);
        System.out.println("""" + r.getBreite());
	}
}","Inkonsistenzen beim Ändern von Attributwerten vermeiden

; Zugriff auf private Attribute ermöglichen","case
; class
; private","Objektmethoden modellieren das Verhalten von Objekten

; Objektmethoden werden aufgerufen mit: Klassenname.Methodenname(Objekt o);","Getter und Setter","Setter-Methoden haben in der Regel den Rückgabetyp void","Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:",-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Rosskopp,Thorge,rosskopp@campus.tu-berlin.de,Beendet,"24. Januar 2021  22:50","24. Januar 2021  23:59","1 Stunde 8 Minuten","0,67","Setter-Methoden haben in der Regel einen Übergabeparameter der vom Typ des zu ändernden Attributs ist","class
; void

; static

; private","Zugriff auf private Attribute ermöglichen
; Setzen falscher Attributwerte verhindern

; Verhindern das Überladen von Methoden","Getter und Setter",-,-,"Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:",-,-
Hake,"Anna Franziska",a.hake@campus.tu-berlin.de,Beendet,"24. Januar 2021  23:04","24. Januar 2021  23:04","21 Sekunden","0,00",-,-,-,-,-,-,"Teil 1: ; Teil 2: ; Teil 3: ; Teil 4: ; Teil 5: ; Teil 6: ; Teil 7: ; Teil 8: ; Teil 9: ; Teil 10: ; Teil 11: ; Teil 12: ; Teil 13: ; Teil 14: ; Teil 15: ; Teil 16: ; Teil 17: ; Teil 18: ; Teil 19: ; Teil 20: ; Teil 21: ; Teil 22: ; Teil 23: ; Teil 24: ; Teil 25: ; Teil 26: ; Teil 27: ; Teil 28: ; Teil 29: ; Teil 30: ; Teil 31: ; Teil 32: ; Teil 33: ; Teil 34: ; Teil 35: ; Teil 36: ; Teil 37: ; Teil 38: ; Teil 39: ; Teil 40: ; Teil 41: ; Teil 42: ; Teil 43: ; Teil 44: ; Teil 45: ; Teil 46: ; Teil 47: ; Teil 48: ; Teil 49: ; Teil 50: ; Teil 51: ; Teil 52: ; Teil 53: ; Teil 54: ; Teil 55: ; Teil 56: ; Teil 57: ; Teil 58: ; Teil 59: ; Teil 60: ; Teil 61: ; Teil 62: ; Teil 63: ; Teil 64: ; Teil 65: ; Teil 66: ; Teil 67: ; Teil 68: ; Teil 69: ; Teil 70: ; Teil 71: ; Teil 72: ; Teil 73: ; Teil 74: ; Teil 75: ; Teil 76: ; Teil 77: ; Teil 78: ; Teil 79: ; Teil 80: ; Teil 81: ; Teil 82: ; Teil 83: ; Teil 84: ; Teil 85: ; Teil 86: ; Teil 87: ; Teil 88: ; Teil 89: ; Teil 90: ; Teil 91: ; Teil 92: ; Teil 93: ; Teil 94: ; Teil 95: ; Teil 96: ; Teil 97: ; Teil 98: ; Teil 99: ; Teil 100: ; Teil 101: ; Teil 102: ; Teil 103: ; Teil 104: ; Teil 105: ; Teil 106: ; Teil 107: ; Teil 108: ; Teil 109: ; Teil 110: ; Teil 111: ; Teil 112: ; Teil 113: ; Teil 114: ; Teil 115: ; Teil 116: ; Teil 117: ; Teil 118: ; Teil 119: ; Teil 120: ; Teil 121: ; Teil 122: ; Teil 123: ; Teil 124: ; Teil 125: ; Teil 126: ; Teil 127: ; Teil 128: ; Teil 129: ; Teil 130: ; Teil 131: ; Teil 132: ; Teil 133: ; Teil 134: ; Teil 135: ; Teil 136: ; Teil 137:",-,-
