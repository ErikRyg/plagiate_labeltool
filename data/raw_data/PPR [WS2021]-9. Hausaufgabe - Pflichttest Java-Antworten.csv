Nachname,Vorname,Antwort 8,Antwort 9
Name_6,VName_6,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator>0) {	
			this.numerator=numerator;
			this.denominator=denominator;
			shorten();
		}
		if (denominator<0) {
			this.numerator=numerator-2*numerator;
			this.denominator=denominator-2*denominator;
			shorten();
		}
		if (denominator==0) {
			this.numerator=numerator;
			this.denominator=1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)getNumerator()/(double)getDenominator();
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return  (this.numerator+""/""+this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        if (numerator<0) {
			numerator = numerator*-1;
			int ggt=GCD(numerator,denominator);
			this.numerator=(numerator/ggt*-1);
			this.denominator=denominator/ggt;
		}
		 if (numerator>0) {
			
			int ggt=GCD(numerator,denominator);
			this.numerator=numerator/ggt;
			this.denominator=denominator/ggt;
		}
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       if (this.denominator!=f.denominator){
			int newnumerator = (this.getNumerator()*f.getDenominator()+f.getNumerator()*this.getDenominator());
			int lcm = LCM(this.getDenominator(),f.getDenominator());
			if (this.denominator/lcm==1){
				return new Fraction (this.getNumerator()+f.getNumerator()*this.getDenominator()/f.getDenominator(),lcm);
			}
			else if (f.denominator/lcm==1){
				return new Fraction (this.getNumerator()*f.getDenominator()/this.getDenominator()+f.getNumerator(),lcm);
			}
			return new Fraction (newnumerator,lcm);
		} 	
		int newnumerator = (this.getNumerator()+f.getNumerator());
		int newdenominator = this.denominator;
		return new Fraction (newnumerator,newdenominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction (this.getNumerator()*f.getNumerator(),this.getDenominator()*f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator!=0){
		   return new Fraction (getDenominator(),getNumerator());
	    } return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
    }","public class SubwayTest {
	public static void main (String[] args) {
		Subway u9 = new Subway (3);
		
		u9.addWagon(new Wagon (25,30));
		u9.addWagon(new Wagon (55,45));
		
		System.out.println(u9.getSeats());
		System.out.println(u9.getStandingRoom());
		System.out.println(u9.getCapacity());
		
		u9.addWagon(new Wagon (50,80));
		u9.addWagon(new Wagon (55,40));
		
		u9.removeWagon ();
		u9.removeWagon ();
		u9.removeWagon ();
		u9.removeWagon ();
		u9.removeWagon ();
	}
}"
Name_230,VName_230,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also mathematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) { 
		if(denominator < 0) {
			this.numerator = numerator * -1;
			this.denominator = denominator * -1;
		}
		else if(denominator == 0) { 
			this.denominator = 1;
			this.numerator = numerator;
		}
		else {
			this.numerator = numerator;
			this.denominator = denominator;
		}
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() { 
		double result = (double)this.numerator / this.denominator;
        return result;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() { 
		String result = numerator + ""/"" + denominator;
        return result;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() { 
		int gcd = GCD(numerator, denominator);
		numerator = numerator / gcd;
		denominator = denominator / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) { 
		Fraction result = new Fraction(1, 1);
		int lcm = LCM(this.denominator, f.denominator);
		int factor1 = (lcm / this.denominator);
		int factor2 = (lcm / f.denominator);
		result.numerator = ((this.numerator * factor1) + (f.numerator * factor2));
		result.denominator = lcm;
	   result.shorten();
	   return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) { 
        Fraction result = new Fraction(1, 1);
		result.numerator = this.numerator * f.numerator;
		result.denominator = this.denominator * f.denominator;
		return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() { 
       Fraction result = new Fraction(1, 1);
	   if(this.numerator != 0) {
			result.numerator = this.denominator;
			result.denominator = this.numerator;
	   }
	   else {
		   result.numerator = this.numerator;
		   result.denominator = this.denominator;
	   }
	   if(result.denominator < 0) {
			result.numerator *= -1;
			result.denominator *= -1;
	   }
	   return result;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) { 
	   Fraction result = new Fraction(1, 1);
	   result = this.multiply(f.reciprocal());
	   if(result.denominator < 0) {
			result.denominator *= -1;
			result.numerator *= -1;
	   }
	   result.shorten();
	   return result; 
    }","public class SubwayTest {
	
	public static void main(String[] args) {
		
		Subway u2 = new Subway(3);
		u2.addWagon(new Wagon(25, 30));
		u2.addWagon(new Wagon(30, 40));
		System.out.println(u2.countWagons()+"" Wagons\n""+
							u2.getSeats()+"" Seats\n""+
							u2.getStandingRoom()+"" Standing Room\n""+
							u2.getCapacity()+"" Capacity"");
		u2.addWagon(new Wagon(15, 20));
		u2.addWagon(new Wagon(22, 32));
		for(int i = 0; i<5; i++) {
			u2.removeWagon();
		}
	}
	
}"
Name_231,VName_231,"public class SubwayTest {

    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        u9.addWagon(new Wagon(25, 30));
        u9.addWagon(new Wagon(55, 45));
        System.out.println(
                u9.countWagons() + "" Wagons\n"" +
                        u9.getSeats() + "" Seats\n"" +
                        u9.getStandingRoom() + "" Standing Room\n"" +
                        u9.getCapacity() + "" Capacity""
        );
        u9.addWagon(new Wagon(20, 35));
        u9.addWagon(new Wagon(12, 33));
        for (int i = 0; i < 5; i++) u9.removeWagon();
        System.out.println(
                u9.countWagons() + "" Wagons\n"" +
                        u9.getSeats() + "" Seats\n"" +
                        u9.getStandingRoom() + "" Standing Room\n"" +
                        u9.getCapacity() + "" Capacity""
        );
    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if (denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        }else if (denominator < 0){
            this.denominator = Math.abs(denominator); //Nenner positiv machen
            this.numerator = -1 * numerator;
        }else {
            this.denominator = denominator;
            this.numerator = numerator;
        }
        shorten();

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator / denominator;

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */

    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(getNumerator(),getDenominator());
        gcd = ( Math.abs(gcd));


        this.numerator = getNumerator() / gcd;
        this.denominator = getDenominator() / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {


        Fraction output = new Fraction(this.numerator,this.denominator);
        Fraction copyInput = new Fraction(f.numerator,f.denominator);
        Fraction tmp = new Fraction(0,0);

        if (output.denominator == copyInput.denominator){
            int zaehler = output.numerator + copyInput.numerator;
             tmp = new Fraction(zaehler,output.denominator);

        }else {
            int lcm = LCM(output.denominator, copyInput.denominator); // kleinstes gemeinsames vielfaches finden
            int erweiterungOutput = lcm / output.denominator;
            int erweiterungF = lcm / copyInput.denominator;

            int outputZaehler = output.numerator * erweiterungOutput;
            int copyInputZaehler = copyInput.numerator * erweiterungF;

            int zaehler = outputZaehler + copyInputZaehler;
             tmp = new Fraction(zaehler, lcm);
        }


        return tmp;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

        Fraction temp = new Fraction(f.numerator,f.denominator);
        Fraction copyInput = new Fraction(this.numerator,this.denominator);

        int zaehler = temp.numerator * copyInput.numerator;
        int nenner = temp.denominator * copyInput.denominator;

        Fraction output = new Fraction(zaehler,nenner);

        return output;

    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction output = new Fraction(this.numerator,this.denominator);

        if (output.numerator != 0){
            output.numerator = denominator;
            output.denominator = numerator;
        }else{

        }

        return output;

    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {

        Fraction copyInput = new Fraction(this.numerator,this.denominator);
        Fraction temp = new Fraction(f.numerator,f.denominator);

        temp = temp.reciprocal();

        Fraction output = copyInput.multiply(temp);
        output.shorten();


        return output;

    }"
Name_232,VName_232,"//Hier soll die Klasse UBahnDemo stehen!

public class SubwayTest{

	public static void main(String[] args){
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
			u9.countWagons()+"" Wagons\n""+
			u9.getSeats()+"" Seats\n""+
    		u9.getStandingRoom()+"" Standing Room\n""+
    		u9.getCapacity()+"" Capacity""
		);
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++) u9.removeWagon();
		System.out.println(
    		u9.countWagons()+"" Wagons\n""+
		    u9.getSeats()+"" Seats\n""+
		    u9.getStandingRoom()+"" Standing Room\n""+
		    u9.getCapacity()+"" Capacity""
		);
	}
}","public Fraction(int numerator, int denominator) {

        
        this.numerator = numerator;
        this.denominator = denominator;

        
        if (numerator > 0 && denominator > 0){
            this.numerator = numerator;
            this.denominator = denominator;
        }
        
        if (denominator == 0){
            this.numerator = numerator;
            this.denominator = 1;              
        }
        
        if (numerator < 0 && denominator < 0){
            this.numerator = numerator * (-1);
            this.denominator = denominator * (-1);
        }

        if (numerator > 0 && denominator < 0){
            this.denominator = denominator * (-1);
            this.numerator = numerator * (-1);
        }

        if (numerator < 0 && denominator > 0){
            this.denominator = denominator;
            this.numerator = numerator;
        }



        this.shorten();


    }

    /**
    * Gibt den denominator zurueck.
    */
    public int getDenominator() {
        return this.denominator;
    }

    /**
    * Gibt den numerator zurueck.
    */
    public int getNumerator() {
        return this.numerator;
    }

    /**
    * Gibt den Bruch als Gleitkommazahl zurueck.
    */
    public double toDouble() {
        int top = this.getNumerator();
        int bottom = this.getDenominator();

        double topdouble = top;
        double bottomdouble = bottom;

        double decimal = topdouble/bottomdouble;

        return decimal;

    }

    /**
    * Gibt einen String im Format
    * ""Zaehler/Nenner"" zurueck.
    */
    public String toString() {
        String str = this.getNumerator()+""/""+this.getDenominator();
        return str;
    }

    /**
    * Kuerzt (vereinfacht) den Bruch.
    */
    public void shorten() {

        int divisor = GCD(this.getNumerator(), this.getDenominator());
        int top = 1;
        int bottom = 1;

        if(divisor < 0){
            divisor = divisor * (-1);
        }
        
        if (this.numerator == 0){
            top = 0;
            bottom = this.getDenominator();
        }

        else if(this.denominator == 0){
            top = this.getNumerator();
            bottom = this.getDenominator();
        }

        else {
            top = this.getNumerator()/divisor;
            bottom = this.getDenominator()/divisor;
        }
        this.numerator = top;
        this.denominator = bottom;
    }

    /**
    * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
    */
    public Fraction add(Fraction f) {
        int top1 = this.getNumerator();
        int top2 = f.getNumerator();
        int bottom1 = this.getDenominator();
        int bottom2 = f.getDenominator();

        int top1new = top1*bottom2;
        int top2new = top2*bottom1;
    
        int topfinal = top1new + top2new;

        int newbottom = bottom1*bottom2;

        Fraction frac_add = new Fraction(topfinal, newbottom);

        return frac_add;
    }

    /**
    * Multipliziert mit dem uebergebenen Bruch.
    */
    public Fraction multiply(Fraction f) {
        int top1 = this.getNumerator();
        int top2 = f.getNumerator();
        int bottom1 = this.getDenominator();
        int bottom2 = f.getDenominator();

        int newtop = top1*top2;
        int newbottom = bottom1*bottom2;

        Fraction frac_mult = new Fraction(newtop, newbottom);

        return frac_mult;
    }

    /**
    * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
    * Sonst wird der Bruch unveraendert zurueckgegeben.
    */
    public Fraction reciprocal() {
        int top = this.getNumerator();
        int bottom = this.getDenominator();
        //System.out.println(""value in recip"");
        //System.out.println(top);
        //int newtop = 1;
        //int newbottom = 1;
            
        if(this.numerator == 0){
            top = this.getNumerator();
            bottom = this.getDenominator();
        }

        if (this.denominator != 0){
            top = this.getDenominator();
            bottom = this.getNumerator();
        }



        Fraction frac_recip = new Fraction(top, bottom);
        return frac_recip;
    }

    /**
    * Dividiert durch den uebergebenen Bruch 
    * (unter Verwendung von Kehrwert und Multiplikation).
    */
    public Fraction divide(Fraction f) {
        int top1 = this.getNumerator();
        int top2 = f.getNumerator();
        int bottom1 = this.getDenominator();
        int bottom2 = f.getDenominator();

        int newtop = top1*bottom2;
        int newbottom = top2*bottom1;

        Fraction frac_div = new Fraction(newtop, newbottom);

        return frac_div;

    }"
Name_233,VName_233,"public Fraction(int numerator, int denominator){
		this.numerator = numerator;
		this.denominator = denominator;
		
		if(this.denominator < 0){
			this.denominator = this.denominator * (-1);
			this.numerator = this.numerator * (-1);
		}
		else if(this.denominator == 0){
			this.denominator = 1;
		}
		else{
			this.numerator = numerator;
			this.denominator = denominator;
		}
		shorten();
	}
	public int getDenominator(){
		return this.denominator;
	}
	public int getNumerator(){
		return this.numerator;
	}
	
	public double toDouble(){
	double x = (double)this.numerator;
	double y = (double)this.denominator;
	double gk = x/y;
	return gk;
	}
	


	public String toString(){
		
		return this.numerator+""/""+this.denominator;
	}
	public void shorten(){
		int factor = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator / factor;
		this.denominator = this.denominator / factor;
		if(this.denominator < 0){
			this.numerator = this.numerator *(-1);
			this.denominator = this.denominator *(-1);
		}
	}
	public Fraction add(Fraction f){
		Fraction addiert = new Fraction(this.getNumerator(),this.getDenominator());
		int lcm = LCM(f.getDenominator(), addiert.getDenominator());
		int faktorf = lcm / f.getDenominator();
		f.numerator = f.getNumerator() * faktorf;
		f.denominator = f.getDenominator() * faktorf;
		int faktora = lcm / addiert.getDenominator();
		addiert.denominator = addiert.getDenominator() * faktora;
		addiert.numerator = addiert.getNumerator() * faktora;
		addiert.numerator = addiert.getNumerator() + f.getNumerator();
		addiert.denominator = addiert.getDenominator();
		addiert.shorten();
		return addiert;
	}
	public Fraction	multiply(Fraction f){
		Fraction multi = new Fraction(this.getNumerator(),this.getDenominator());
		multi.numerator = multi.getNumerator() * f.getNumerator();
		multi.denominator = multi.getDenominator() * f.getDenominator();
		multi.shorten();
		return multi;
	}
	 public Fraction reciprocal(){
		Fraction recip = new Fraction(this.getNumerator(),this.getDenominator());
		if(recip.numerator == 0){
			return this;
		}
		else if(recip.numerator != 0){
			int x = this.getNumerator();
			recip.numerator = this.getDenominator();
			recip.denominator = x;
			recip.shorten();
			
		}
		return recip;
	}
		
		public Fraction divide(Fraction f){
			Fraction div = new Fraction(this.getNumerator(),this.getDenominator());
			return div.multiply(f.reciprocal());
}","public class UBahnDemo {

	public static void main(String[] args) {
	Subway u9 = new Subway(3);
	u9.addWagon(new Wagon(25, 30));
	u9.addWagon(new Wagon(55, 45));
	
	System.out.println(u9.countWagons()+"" Wagons\n""+u9.getSeats()+"" Seats\n""+u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");
	
	u9.addWagon(new Wagon(20, 35));
	u9.addWagon(new Wagon(12, 33));
		
		for(int i = 0; i<5; i++) {
		u9.removeWagon();
		}
	
	System.out.println(u9.countWagons()+"" Wagons\n""+u9.getSeats()+"" Seats\n""+u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

	
	}


}"
Name_5,VName_5,-,-
Name_234,VName_234,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator < 0){
            this.numerator = numerator * -1;
            this.denominator = denominator * -1;
        }
        else if(denominator == 0){
            this.numerator = numerator;
            this.denominator = 1;
        }
        else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator +""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        /*return new Fraction(numerator * f.denominator + denominator * f.numerator, denominator * f.denominator);*/
        int lcm = LCM(denominator, f.denominator);
        int firstSummandMultiplier = lcm / denominator;
        int secondSummandMultiplier = lcm / f.denominator;
        return new Fraction(numerator*firstSummandMultiplier + f.numerator * secondSummandMultiplier, lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator* f.numerator, denominator*f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0)
            return new Fraction(denominator, numerator);
        else
            return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    }","public class SubwayTest {
    public static void main(String[] args) {
        Subway u5 = new Subway(3);
        u5.addWagon(new Wagon(25,30));
        u5.addWagon(new Wagon(30,35));
        System.out.println(
            u5.countWagons()+ "" Wagons\n""+
            u5.getSeats()+ "" Seats\n""+
            u5.getStandingRoom()+ "" Standing Room\n""+
            u5.getCapacity()+ "" Capacity""
        );

        u5.addWagon(new Wagon(35,40));
        u5.addWagon(new Wagon(40,45));
        for(int i=0; i<5;i++) u5.removeWagon();
        System.out.println(
            u5.countWagons()+ "" Wagons\n""+
            u5.getSeats()+ "" Seats\n""+
            u5.getStandingRoom()+ "" Standing Room\n""+
            u5.getCapacity()+ "" Capacity""
        );
    }
}"
Name_235,VName_235,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	
	
	
	
    public Fraction(int numerator, int denominator) {
    	if (denominator < 0) { 
    		this.denominator = Math.abs(denominator); 
    		this.numerator = -numerator;
    	} else if (denominator == 0) { 
    		this.denominator = 1; 
    		this.numerator = numerator;
    	} else {
    	    this.numerator = numerator;
            this.denominator = denominator;
    	}
    	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    	int fickdichppr = numerator;
    	numerator = numerator/GCD(numerator, denominator);
    	denominator = denominator/GCD(fickdichppr, denominator);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int denomExt = denominator * f.getDenominator();
       int num1 = numerator * f.getDenominator();
       int num2 = f.getNumerator() * denominator;
       return new Fraction(num1 + num2, denomExt);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	if (numerator != 0) {
    		int numNew = denominator;
    		denominator = numerator;
    		numerator = numNew;
    	}
    	return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	f.reciprocal();
    	return this.multiply(f);
    }","public class SubwayTest {

	public static void main(String[] args) {

		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
			    u9.countWagons()+"" Wagons\n""+
			    u9.getSeats()+"" Seats\n""+
			    u9.getStandingRoom()+"" Standing Room\n""+
			    u9.getCapacity()+"" Capacity""
			);
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++) u9.removeWagon();
	}

}"
Name_236,VName_236,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator == 0) {denominator = 1;}
		if(denominator < 0) {
			denominator = denominator * (-1);
			numerator = numerator * (-1);
		}
		
		this.numerator = numerator;
		this.denominator = denominator;
		
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator / (double)this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator +""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int shorty = Fraction.GCD(this.numerator,this.denominator);
		if(shorty > 1){
			this.numerator = this.numerator / shorty;
			this.denominator = this.denominator / shorty;
		}
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction f1 = new Fraction((this.numerator * f.denominator) + (f.numerator * this.denominator), this.denominator * f.denominator);
	   f1.shorten();
	   return f1;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction f1 = new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
		f1.shorten();
		return f1;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(this.numerator != 0){
		   return new Fraction(this.denominator, this.numerator);
	   }
	   else{
		   return new Fraction(this.numerator,this.denominator);
	   }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction f1 = new Fraction(this.numerator, this.denominator);
		Fraction f1a = f1.multiply(f.reciprocal());
		f1a.shorten();
        return f1a;
    }","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest{
	
	public static void main(String[] args){
		
		Subway U6 = new Subway(3);
		
		U6.addWagon(new Wagon(25,30));
		U6.addWagon(new Wagon(55,45));
		
		System.out.println(
			U6.countWagons()+"" Wagons\n""+
			U6.getSeats()+"" Seats\n""+
			U6.getStandingRoom()+"" Standing Room\n""+
			U6.getCapacity()+"" Capacity"");
		
		U6.addWagon(new Wagon(20,35));
		U6.addWagon(new Wagon(12, 33));
		
		for(int i = 0; i < 5; i++){
			U6.removeWagon();
		}
		
			System.out.println(
			U6.countWagons()+"" Wagons\n""+
			U6.getSeats()+"" Seats\n""+
			U6.getStandingRoom()+"" Standing Room\n""+
			U6.getCapacity()+"" Capacity"");

	}
}"
Name_231,VName_231,"public Fraction(int numerator, int denominator) {
		if(denominator < 0 ) {
			this.numerator = - numerator;
			this.denominator = - denominator;			
		}
		else if(denominator == 0){
			this.denominator = 1; 
			this.numerator = numerator;
		}
		else {
			this.denominator = denominator;
			this.numerator = numerator;
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double ergebnis = (double)numerator/denominator;
		return ergebnis;
		
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return  numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int factorC = GCD(this.numerator,this.denominator);
		numerator = numerator/factorC;
        denominator = denominator/factorC;
	}

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int x = numerator  * f.getDenominator()+ denominator * f.getNumerator();
		int y = denominator * f.getDenominator();

		Fraction b = new Fraction(x,y);
		b.shorten();
		return b;
		//Fraction temp = new Fraction(numerator,denominator);
		//shorten();
		//temp.numerator = temp.numerator * f.denominator;
        //temp.denominator = temp.denominator * f.denominator;
		//shorten();
		//return temp ;
		
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction temp = new Fraction(numerator,denominator);
		temp.shorten();
		temp.numerator = numerator * f.numerator;
        temp.denominator = denominator * f.denominator;
		temp.shorten();
		return temp;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       Fraction temp = new Fraction(numerator, denominator);
	   temp.shorten();
       int newNumerator = numerator;
       int newDenominator = denominator;
       temp.numerator = newDenominator;
       temp.denominator = newNumerator;
	   return temp;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction temp = new Fraction(numerator, denominator);
		temp.shorten();
		//temp.multiply(f.reciprocal());
		//temp.shorten();
		//return temp; 
		temp.numerator = numerator*f.getDenominator();
		temp.denominator = denominator*f.getNumerator();
		temp.shorten();
		return temp;
    }","public class SubwayTest {

	public static void main(String[] args){
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity"");
		
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity"");
	}
}"
Name_237,VName_237,"/**
 * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
 * uebergeben bekommt und die entsprechenden Attribute setzt.
 * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
 * auftreten (nicht im ""denominator""-Attribut).
 * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
 * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
 * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
 * und der Wert des Bruchs (die Argumente) unverändert bleibt
 * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
 * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
 * auf Eins gesetzt.
 * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
 */


public Fraction(int numerator, int denominator) {
  this.numerator = numerator;
  this.denominator = denominator;
  if(this.denominator == 0) this.denominator = 1;
  if(this.denominator<0){
    this.numerator=numerator*(-1);
    this.denominator= denominator*(-1);
  }
  shorten();
}

/**
 * Gibt den Nenner zurueck.
 */
public int getDenominator() {
  return this.denominator;
}

/**
 * Gibt den Zaehler zurueck.
 */
public int getNumerator() {
  return this.numerator;
}

/**
 * Gibt den Bruch als Gleitkommazahl zurueck.
 */
public double toDouble() {
  double gleitK = (double)this.numerator/(double)this.denominator;
  return gleitK;
}

/**
 * Gibt einen String im Format
 * ""Zaehler/Nenner"" zurueck.
 */
public String toString() {
  String str = this.numerator+""/""+this.denominator;
  return str;
}

/**
 * Kuerzt (vereinfacht) den Bruch.
 */
public void shorten() {
  int klGeNe = GCD(this.numerator, this.denominator);
  this.numerator = this.numerator/klGeNe;
  this.denominator = this.denominator/klGeNe;
}

/**
 * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
 */
public Fraction add(Fraction f) {
  int geNe = this.denominator*f.denominator;
  int num = f.numerator*this.denominator + f.denominator*this.numerator;
  int den = geNe;
  Fraction add = new Fraction(num, den);
  add.shorten();
  return add;
}

/**
 * Multipliziert mit dem uebergebenen Bruch.
 */
public Fraction multiply(Fraction f) {
  int num = this.numerator*f.numerator;
  int den = this.denominator*f.denominator;
  Fraction mult = new Fraction(num, den);
  mult.shorten();
  return mult;
}

/**
 * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
 * Sonst wird der Bruch unveraendert zurueckgegeben.
 */
 public Fraction reciprocal() {
   Fraction reciproc = new Fraction(0,0);
   if(this.numerator!=0){
     int tmp = this.numerator;
     reciproc.numerator = this.denominator;
     reciproc.denominator = tmp;
     return reciproc;
   }else{
   reciproc.numerator = this.denominator;
   reciproc.denominator = this.numerator;
   return reciproc;
  }
 }

/**
 * Dividiert durch den uebergebenen Bruch
 * (unter Verwendung von Kehrwert und Multiplikation).
 */
public Fraction divide(Fraction f) {
  int num = this.numerator*f.denominator;
  int den = this.denominator*f.numerator;
  Fraction teile = new Fraction(num, den);
  teile.shorten();
  return teile;
}","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest{

  public static void main(String[] args) {

    Subway u9 = new Subway(3);
    u9.addWagon(new Wagon(25,30));
    u9.addWagon(new Wagon(55,45));
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

    u9.addWagon(new Wagon(20,35));
    u9.addWagon(new Wagon(12,33));
    for(int i=0;i<5;i++) u9.removeWagon();
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

  }
}"
Name_238,VName_238,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","//Hier soll die Klasse UBahnDemo stehen!

public class SubwayTest{
    public static void main(String [] args){

        Subway a = new Subway(3);
        a.addWagon(new Wagon(24,29));
        a.addWagon(new Wagon(54,44));
        System.out.println(a.getSeats());
        System.out.println(a.getStandingRoom());
        System.out.println(a.getCapacity());
        a.addWagon(new Wagon(19,34));
        a.addWagon(new Wagon(11, 32));
        a.removeWagon();
        a.removeWagon();
        a.removeWagon();
        a.removeWagon();
        a.removeWagon();

    }
}"
Name_239,VName_239,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }",-
Name_240,VName_240,"//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {

    public static void main(String[] args) {
            Subway u9 = new Subway(3);
u9.addWagon(new Wagon(25,30));
u9.addWagon(new Wagon(55,45));
System.out.println(
        u9.countWagons()+"" Wagons\n""+
        u9.getSeats()+"" Seats\n""+
        u9.getStandingRoom()+"" Standing Room\n""+
        u9.getCapacity()+"" Capacity""
        );
u9.addWagon(new Wagon(20,35));
u9.addWagon(new Wagon(12, 33));
for(int i=0;i<5;i++) u9.removeWagon();
System.out.println(
        u9.countWagons()+"" Wagons\n""+
        u9.getSeats()+"" Seats\n""+
        u9.getStandingRoom()+"" Standing Room\n""+
        u9.getCapacity()+"" Capacity""
        );
        }


        // write your code here
    }","public Fraction(int numerator, int denominator) {
        this.numerator = numerator*((denominator==0?1:Integer.signum(denominator)));
        this.denominator = (denominator == 0) ? 1 : Math.abs(denominator);
        shorten();
    }


    public int getDenominator() {
        return this.denominator;
    }


    public int getNumerator() {
        return this.numerator;
    }


    public double toDouble() {
        return (double) this.numerator / (double) this.denominator;
    }


    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }


    public void shorten() {
        int z = GCD(this.numerator, this.denominator);
        this.numerator /= z;
        this.denominator /= z;
    }


    public Fraction add(Fraction f) {
        int x = 0;
        if (this.denominator < f.denominator) {
            x = GCD(this.denominator, f.denominator);
        }else{
            x = LCM(this.denominator, f.denominator);
        }

        return new Fraction((int) ((double) this.numerator * ((double) x / this.denominator)) + (int) ((double) f.numerator * ((double) x / f.denominator)), x);
    }


    public Fraction multiply(Fraction f) {
        return new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
    }

    public Fraction reciprocal() {
        if (this.denominator != 0)
            return new Fraction(this.denominator, this.numerator);
        else
            return new Fraction(this.numerator, this.denominator);
    }


    public Fraction divide(Fraction f) {
        return new Fraction(this.numerator * f.denominator, this.denominator * f.numerator);
    }"
Name_241,VName_241,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;

        if (denominator == 0)
            this.denominator = 1;
        else if (denominator < 0) {
            this.denominator = (-1) * denominator;
            this.numerator = (-1) * this.numerator;
        } else
            this.denominator = denominator;

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return this.numerator / ((double) this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (this.getNumerator() + ""/"" + this.getDenominator());
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int x = this.numerator;
        int y = this.denominator;
        if (this.numerator < 0)
            x = this.numerator * (-1);
        if (this.denominator < 0)
            y = this.denominator * (-1);
        int divisor = GCD(x, y);
        this.numerator = this.numerator / divisor;
        this.denominator = this.denominator / divisor;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int rNumerator = f.denominator * this.numerator + this.denominator * f.numerator;
        int rDemoninator = f.denominator * this.denominator;
        Fraction result = new Fraction(rNumerator, rDemoninator);
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int rNumerator = this.numerator * f.numerator;
        int rDemoninator = this.denominator * f.denominator;
        Fraction result = new Fraction(rNumerator, rDemoninator);
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0) {
            return this;
        } else {
            Fraction inverted = new Fraction(this.denominator, this.numerator);
            return inverted;
        }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    }",//Hier soll die Klasse UBahnDemo stehen!
Name_242,VName_242,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_243,VName_243,"public Fraction(int numerator, int denominator) {
        this.numerator = numerator;

        if (denominator == 0) {
            this.denominator = 1;
        }
        else if(denominator < 0) {
            this.numerator *= -1;
            this.denominator = denominator * -1;
        }
        else if (denominator > 0) {
            this.denominator = denominator;
        }

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck. 
     */
    public double toDouble() {
        return this.numerator / (double) this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck. 
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch. 
     */
    public void shorten() {
        int min = LCM(this.numerator, this.denominator);

        int[] primeNumbers = GetPrimeNumbers(min);

        for (int i = 0; i < primeNumbers.length; i++) {

            int prime = primeNumbers[i];
            while (this.numerator % prime == 0 && this.denominator % prime == 0) {
                this.numerator /= prime;
                this.denominator /= prime;
            }
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch. 
     */
    public Fraction add(Fraction f) {
        int newNumerator;
        int newDenominator;

        if (this.denominator % f.denominator == 0) {
            newDenominator = Math.max(this.denominator, f.denominator);
        } else {
            newDenominator = this.denominator * f.denominator;
        }

        if (this.denominator == newDenominator) {
            newNumerator = this.numerator + f.numerator * (newDenominator / f.denominator);
        } else if (f.denominator == newDenominator) {
            newNumerator = this.numerator * (newDenominator / this.denominator) + f.numerator;
        } else {
            newNumerator = this.numerator * f.denominator + f.numerator * this.denominator;
        }

        return new Fraction(newNumerator, newDenominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch. 
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = this.numerator * f.numerator;
        int newDenominator = this.denominator * f.denominator;

        return new Fraction(newNumerator, newDenominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator == 0) {
            return new Fraction(this.numerator, this.numerator);
        }

        return new Fraction(this.denominator, this.numerator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation). 
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }


    private int[] GetPrimeNumbers(int number) {
        //list for result
        boolean[] isPrime = new boolean[Math.abs(number) + 1];

        for (int i = 2; i < isPrime.length; i++) {
            isPrime[i] = true;
        }

        for (int i = 2; i < isPrime.length; i++) {

            if (isPrime[i] == true) {

                if (i * i >= isPrime.length) {
                    break;
                }

                for (int j = i * i; j < isPrime.length; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        int counter = 0;
        for (int i = 2; i < isPrime.length; i++) {

            if (isPrime[i] == true) {
                counter++;
            }
        }

        int[] primeNumbers = new int[counter];
        int index = 0;

        for (int i = 2; i < isPrime.length; i++) {

            if (isPrime[i] == true) {
                primeNumbers[index++] = i;
            }
        }

        return primeNumbers;
    }","public class SubwayTest {
    public static void main(String[] args) {

        Subway u9 = new Subway(3);
        u9.addWagon(new Wagon(25,30));
        u9.addWagon(new Wagon(55,45));
        System.out.println(
                u9.countWagons()+"" Wagons\n""+
                        u9.getSeats()+"" Seats\n""+
                        u9.getStandingRoom()+"" Standing Room\n""+
                        u9.getCapacity()+"" Capacity""
        );
        u9.addWagon(new Wagon(20,35));
        u9.addWagon(new Wagon(12, 33));
        for(int i=0;i<5;i++) u9.removeWagon();
        System.out.println(
                u9.countWagons()+"" Wagons\n""+
                        u9.getSeats()+"" Seats\n""+
                        u9.getStandingRoom()+"" Standing Room\n""+
                        u9.getCapacity()+"" Capacity""
        );
    }
}"
Name_244,VName_244,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	 
	 
	 



	public Fraction(int numerator, int denominator){
		this.numerator = numerator;
		this.denominator = denominator;
		if(denominator == 0){
			this.denominator = 1;
		}
		int teiler = GCD(getNumerator(), getDenominator());
		this.numerator = this.numerator/teiler;
		this.denominator = this.denominator/teiler;
		if(this.denominator < 0){
			this.denominator = this.denominator * -1;
			this.numerator = this.numerator * -1;
		}
	}
    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double b = (double)getNumerator()/(double)getDenominator();
		return b;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch = getNumerator()+""/""+getDenominator();
		return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(getNumerator(), getDenominator());
		this.numerator = this.numerator/teiler;
		this.denominator = this.denominator/teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction summe = new Fraction(3, 5);
	   if(this.denominator == f.denominator){
		   summe.denominator = this.denominator;
		   summe.numerator = this.numerator + f.numerator;
		   summe.shorten();
		   return summe;
	   }
	   int kGV = LCM(this.denominator, f.denominator);
	   int faktor1 = kGV / this.denominator;
	   int faktor2 = kGV / f.denominator;
	   summe.numerator = this.numerator * faktor1 + f.numerator * faktor2;
	   summe.denominator = kGV;
	   summe.shorten();
 	   return summe;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction produkt = new Fraction(3, 5);
		produkt.numerator = f.numerator * this.numerator;
		produkt.denominator = f.denominator * this.denominator;
		produkt.shorten();
		return produkt;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if(this.numerator == 0){
			Fraction kehrwert = new Fraction(this.numerator, this.denominator);
			return kehrwert;
		}
		Fraction kehrwert = new Fraction(3, 5);
		kehrwert.numerator = this.denominator;
		kehrwert.denominator = this.numerator;
		return kehrwert;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction quotient = new Fraction(3, 5);
	   quotient.numerator = this.numerator;
	   quotient.denominator = this.denominator;
	   quotient = quotient.multiply(f.reciprocal());
	   quotient.shorten();
	   return quotient;
    }","public class SubwayTest{
	
	public static void main(String[] args){
		
		Subway ubahn = new Subway(3);
		Wagon a = new Wagon(10, 20);
		ubahn.addWagon(a);
		Wagon b = new Wagon(5, 10);
		ubahn.addWagon(b);
		System.out.println(ubahn.getSeats());
		System.out.println(ubahn.getStandingRoom());
		System.out.println(ubahn.getCapacity());
		Wagon c = new Wagon(5, 10);
		ubahn.addWagon(c);
		Wagon d = new Wagon(5, 10);
		ubahn.addWagon(d);
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
	}
}"
Name_245,VName_245,"public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon w1=new Wagon(25,30);
        u9.addWagon(w1);
        Wagon w2=new Wagon(55,45);
        u9.addWagon(w2);
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagon w3=new Wagon(25,35);
        u9.addWagon(w3);
        Wagon w4=new Wagon(12,33);
        u9.addWagon(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagon();
        }
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }
}","public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }

    public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }"
Name_246,VName_246,"public class SubwayTest{

  public static void main(String[] args) {

    Subway u9 = new Subway(3);
    u9.addWagon(new Wagon(25,30));
    u9.addWagon(new Wagon(55,45));
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

    u9.addWagon(new Wagon(20,35));
    u9.addWagon(new Wagon(12,33));
    for(int i=0;i<5;i++) u9.removeWagon();
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

  }
}","/**
  * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
  * uebergeben bekommt und die entsprechenden Attribute setzt.
  * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
  * auftreten (nicht im ""denominator""-Attribut).
  * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
  * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
  * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
  * und der Wert des Bruchs (die Argumente) unverändert bleibt
  * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
  * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
  * auf Eins gesetzt.
  * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
  */


 public Fraction(int numerator, int denominator) {
   this.numerator = numerator;
   this.denominator = denominator;
   if(this.denominator == 0) this.denominator = 1;
   if(this.denominator<0){
     this.numerator=numerator*(-1);
     this.denominator= denominator*(-1);
   }
   shorten();
 }

 /**
  * Gibt den Nenner zurueck.
  */
 public int getDenominator() {
   return this.denominator;
 }

 /**
  * Gibt den Zaehler zurueck.
  */
 public int getNumerator() {
   return this.numerator;
 }

 /**
  * Gibt den Bruch als Gleitkommazahl zurueck.
  */
 public double toDouble() {
   double gleitK = (double)this.numerator/(double)this.denominator;
   return gleitK;
 }

 /**
  * Gibt einen String im Format
  * ""Zaehler/Nenner"" zurueck.
  */
 public String toString() {
   String str = this.numerator+""/""+this.denominator;
   return str;
 }

 /**
  * Kuerzt (vereinfacht) den Bruch.
  */
 public void shorten() {
   int klGeNe = GCD(this.numerator, this.denominator);
   this.numerator = this.numerator/klGeNe;
   this.denominator = this.denominator/klGeNe;
 }

 /**
  * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
  */
 public Fraction add(Fraction f) {
   int geNe = this.denominator*f.denominator;
   int num = f.numerator*this.denominator + f.denominator*this.numerator;
   int den = geNe;
   Fraction add = new Fraction(num, den);
   add.shorten();
   return add;
 }

 /**
  * Multipliziert mit dem uebergebenen Bruch.
  */
 public Fraction multiply(Fraction f) {
   int num = this.numerator*f.numerator;
   int den = this.denominator*f.denominator;
   Fraction mult = new Fraction(num, den);
   mult.shorten();
   return mult;
 }

 /**
  * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
  * Sonst wird der Bruch unveraendert zurueckgegeben.
  */
  public Fraction reciprocal() {
    Fraction reciproc = new Fraction(0,0);
    if(this.numerator!=0){
      int tmp = this.numerator;
      reciproc.numerator = this.denominator;
      reciproc.denominator = tmp;
      return reciproc;
    }else{
    reciproc.numerator = this.denominator;
    reciproc.denominator = this.numerator;
    return reciproc;
   }
  }

 /**
  * Dividiert durch den uebergebenen Bruch
  * (unter Verwendung von Kehrwert und Multiplikation).
  */
 public Fraction divide(Fraction f) {
   int num = this.numerator*f.denominator;
   int den = this.denominator*f.numerator;
   Fraction teile = new Fraction(num, den);
   teile.shorten();
   return teile;
 }"
Name_247,VName_247,"public class SubwayTest{

  public static void main(String[] args) {

    Subway u9 = new Subway(3);
    u9.addWagon(new Wagon(25,30));
    u9.addWagon(new Wagon(55,45));
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

    u9.addWagon(new Wagon(20,35));
    u9.addWagon(new Wagon(12,33));
    for(int i=0;i<5;i++) u9.removeWagon();
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");

  }
}","/**
  * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
  * uebergeben bekommt und die entsprechenden Attribute setzt.
  * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
  * auftreten (nicht im ""denominator""-Attribut).
  * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
  * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
  * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
  * und der Wert des Bruchs (die Argumente) unverändert bleibt
  * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
  * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
  * auf Eins gesetzt.
  * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
  */


 public Fraction(int numerator, int denominator) {
   this.numerator = numerator;
   this.denominator = denominator;
   if(this.denominator == 0) this.denominator = 1;
   if(this.denominator<0){
     this.numerator=numerator*(-1);
     this.denominator= denominator*(-1);
   }
   shorten();
 }

 /**
  * Gibt den Nenner zurueck.
  */
 public int getDenominator() {
   return this.denominator;
 }

 /**
  * Gibt den Zaehler zurueck.
  */
 public int getNumerator() {
   return this.numerator;
 }

 /**
  * Gibt den Bruch als Gleitkommazahl zurueck.
  */
 public double toDouble() {
   double gleitK = (double)this.numerator/(double)this.denominator;
   return gleitK;
 }

 /**
  * Gibt einen String im Format
  * ""Zaehler/Nenner"" zurueck.
  */
 public String toString() {
   String str = this.numerator+""/""+this.denominator;
   return str;
 }

 /**
  * Kuerzt (vereinfacht) den Bruch.
  */
 public void shorten() {
   int klGeNe = GCD(this.numerator, this.denominator);
   this.numerator = this.numerator/klGeNe;
   this.denominator = this.denominator/klGeNe;
 }

 /**
  * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
  */
 public Fraction add(Fraction f) {
   Fraction addi = new Fraction(0, 0);
   int geNe = this.denominator*f.denominator;
   addi.numerator = f.numerator*this.denominator + f.denominator*this.numerator;
   addi.denominator = geNe;
   addi.shorten();
   return addi;
 }

 /**
  * Multipliziert mit dem uebergebenen Bruch.
  */
 public Fraction multiply(Fraction f) {
   Fraction mult = new Fraction(0, 0);
   mult.numerator = this.numerator*f.numerator;
   mult.denominator = this.denominator*f.denominator;
   mult.shorten();
   return mult;
 }

 /**
  * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
  * Sonst wird der Bruch unveraendert zurueckgegeben.
  */
 public Fraction reciprocal() {
   Fraction reci = new Fraction(0,0);
   if(this.numerator==0){
     reci.numerator = this.denominator;
     reci.denominator = 1;
     return reci;
   }else{
   reci.numerator = this.denominator;
   reci.denominator = this.numerator;
   return reci;
  }
 }

 /**
  * Dividiert durch den uebergebenen Bruch
  * (unter Verwendung von Kehrwert und Multiplikation).
  */
 public Fraction divide(Fraction f) {
   Fraction div = new Fraction(0, 0);
   div.numerator = this.numerator*f.denominator;
   div.denominator = this.denominator*f.numerator;
   div.shorten();
   return div;
 }"
Name_248,VName_248,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		
        if (denominator == 0){
			this.denominator = 1;
		}
		if (denominator < 0){
			this.numerator = -numerator;
            this.denominator = -denominator;
        }
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }
	



    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (((double) this.numerator) / ((double) this.denominator));
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int gcd = GCD(numerator,denominator);
		if(gcd<0){
			gcd=-gcd;
		}
		numerator/=gcd;
		denominator/=gcd;
    
	}

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        Fraction newFraction = new Fraction(1,1);
        int n = this.numerator * f.getDenominator() + f.getNumerator() * this.denominator;
        int d = this.denominator * f.getDenominator();
        newFraction.numerator = n;
        newFraction.denominator = d;
        newFraction.shorten();
		return newFraction;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction newFraction = new Fraction(1,1);
        int n = this.numerator * f.getNumerator();
        int d = this.denominator * f.getDenominator();
        newFraction.numerator = n;
        newFraction.denominator = d;
        return newFraction;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       Fraction newFraction = new Fraction(1,1);
	   if (this.numerator != 0){
		   newFraction.numerator = this.denominator;
           newFraction.denominator =this.numerator;
	       if(this.numerator<0){
			   newFraction.numerator = -this.denominator;
		       newFraction.denominator= -this.numerator;
	        }
		return newFraction;
		}
		return newFraction;
	}
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction newFraction = new Fraction(numerator,denominator);
	   
	   Fraction new1 = f.reciprocal();
	   Fraction new3 = newFraction.multiply(new1);
	   new3.shorten();
	   return new3;
    }","public class SubwayTest{
	
	public static void main (String[] args){
		Subway u1 = new Subway(3);
		u1.addWagon(new Wagon(25,30));
		u1.addWagon(new Wagon(55,45));
		System.out.println(
		u1.countWagons()+"" Wagons\n""+
        u1.getSeats()+"" Seats\n""+
        u1.getStandingRoom()+"" Standing Room\n""+
        u1.getCapacity()+"" Capacity""
		);
		
		u1.addWagon(new Wagon(20,35));
		u1.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++){
		  u1.removeWagon();
		} 
        
		System.out.println(
        u1.countWagons()+"" Wagons\n""+
        u1.getSeats()+"" Seats\n""+
        u1.getStandingRoom()+"" Standing Room\n""+
        u1.getCapacity()+"" Capacity""
		);
	}

}"
Name_249,VName_249,"public class SubwayTest {

    public static void main(String[] args){
        Subway thomas = new Subway(3);
        Wagon a = new Wagon(10, 5);
        Wagon b = new Wagon(20, 10);

        thomas.addWagon(a);
        thomas.addWagon(b);

        System.out.println(thomas.getSeats()+ "" Seats"");
        System.out.println(thomas.getStandingRoom()+ "" Standing Room"");
        System.out.println(thomas.getCapacity()+ "" Capacity"");

        Wagon c = new Wagon(2, 1);
        Wagon d = new Wagon(100, 69);

        thomas.addWagon(c);
        thomas.addWagon(d);

        thomas.removeWagon();
        thomas.removeWagon();
        thomas.removeWagon();
        thomas.removeWagon();
        thomas.removeWagon();
    }
}","public Fraction(int numerator, int denominator){

        if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
            shorten();
        }else if(denominator > 0){
            this.numerator = numerator;
            this.denominator = denominator;
            shorten();
        }else if(denominator < 0){
            this.numerator = -numerator; //wtf is wrong here??
            this.denominator = -denominator;
            shorten();
            if(this.numerator == 1 ){
                this.numerator = -numerator; //wtf is wrong here??
                this.denominator = -denominator;
            }
        }
    }

    public int getDenominator() {
        return this.denominator;
    }

    public int getNumerator() {
        return this.numerator;
    }

    public double toDouble() {
        double a = (double)this.numerator / (double)this.denominator;
        return a;
    }

    public String toString() {
    String a = Integer.toString(numerator);
    String b = Integer.toString(denominator);
    String c = a + ""/"" + b;
    return c;
    }

    public void shorten() {
        int gdc = GCD(this.numerator,this.denominator);
        this.numerator = this.numerator/gdc;
        this.denominator = this.denominator/gdc;
    }

    public Fraction add(Fraction f) {
        int lmc = LCM(this.denominator, f.denominator);
        int num1 = ((lmc/this.denominator)*this.numerator);
        int numf = ((lmc/f.denominator)*f.numerator);
        int a = num1 + numf;
        int b = lmc;
        Fraction x = new Fraction(a,b);
        return x;
    }

    public Fraction multiply(Fraction f) {
        int a = this.numerator * f.numerator;
        int b = this.denominator * f.denominator;
        Fraction x = new Fraction(a,b);
        return x;
    }

    public Fraction reciprocal() {
        if(this.numerator != 0){
            int a = this.denominator;
            int b = this.numerator;
            Fraction x = new Fraction(a,b);
            return x;
        }else{
            Fraction y = new Fraction(this.numerator, this.denominator);
            return y;
        }
    }

    public Fraction divide(Fraction f) {
        Fraction fRep = new Fraction(f.reciprocal().numerator, f.reciprocal().denominator );
        return multiply(fRep);
    }"
Name_250,VName_250,"public class SubwayTest {
public static void main(String[] args) {
	Subway s=new Subway(4);
	s.addWagon(new Wagon(10,15));
	System.out.println(s.countWagons());
	s.removeWagon();
	s.removeWagon();
	s.addWagon(new Wagon(10,15));
	s.addWagon(new Wagon(15,20));
	s.addWagon(new Wagon(20,30));
	s.addWagon(new Wagon(30,40));
	s.addWagon(new Wagon(10,15));
	System.out.println(s.countWagons());

	s.removeWagon();
	System.out.println(s.countWagons());

	System.out.println(s.getSeats());
	System.out.println(s.getStandingRoom());
	System.out.println(s.getCapacity());


}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }else if(denominator==0){
            this.denominator=1;
            this.numerator=numerator;
        }else{
            this.numerator=numerator;
            this.denominator=denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)((double)numerator/(double)denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s=numerator+""/""+denominator;
        return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int i=GCD(numerator,denominator);
        numerator=numerator/i;
        denominator=denominator/i;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int gemNenner=LCM(denominator,f.getDenominator());
       int numerator1=numerator*gemNenner/denominator;
       int numerator2=f.getNumerator()*gemNenner/f.getDenominator();
       Fraction g=new Fraction(numerator1+numerator2,gemNenner);
       g.shorten();
       return g;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction ret=new Fraction(numerator*f.getNumerator(),denominator*f.getDenominator());
        ret.shorten();
        return ret;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if(denominator==0){
           return this;
       }else{
           return new Fraction(denominator,numerator);
       }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        if(f.getNumerator()==0){
            return null;
        }else{
            Fraction u=multiply(f.reciprocal());
            u.shorten();
            return u;
        }
       
    }"
Name_251,VName_251,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","public class SubwayTest{

	public static void main(String[] args){
		Subway U2 = new Subway(3);
		U2.addWagon(20,10);
		U2.addWagon(25,15);
		System.out.println(""Gesamtanzahl Stehplaetze: ""+U2.getSeats()+""\t""+""Gesamtanzahl Sitzplaetze: ""+U2.getStandingRoom()+""\t""+""Gesamtanzahl Plaetze: ""+U2.getCapacity());
		U2.removeWagon();
		U2.removeWagon();
		U2.removeWagon();
		U2.removeWagon();
		U2.removeWagon();
	}
}"
Name_53,VName_53,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_252,VName_252,"public class SubwayTest {
	public static void main(String[] args) {		
		Subway u2 = new Subway(3);
		u2.addWagon(new Wagon(25,30));
		u2.addWagon(new Wagon(45,55));
		System.out.println(u2.getSeats());		
		System.out.println(u2.getStandingRoom());		
		System.out.println(u2.getCapacity());
		u2.addWagon(new Wagon(10,15));
		u2.addWagon(new Wagon(20,25));
		u2.removeWagon();
		u2.removeWagon();
		u2.removeWagon();
		u2.removeWagon();
		u2.removeWagon();
	}
}","public Fraction(int numerator, int denominator) {
		
		if (denominator < 0) {
			this.numerator = numerator*(-1);
			this.denominator = denominator*(-1);
		}
		if (denominator == 0){
			this.numerator = numerator;
			this.denominator = 1;
		}
		if (denominator > 0) {
			this.numerator = numerator; 
			this.denominator = denominator;
		}
		this.shorten(); 
    }
	
    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }
	
	public double toDouble() {
		double a = (double)getNumerator();
		double b = (double)getDenominator();
		double r = a/b;
		return r;
    }
	
	public String toString() { 
		String r = getNumerator()+""/""+getDenominator();
        return r;
    }
	 
	public void shorten() { 
		int t = GCD(getNumerator(),getDenominator());
		while(t != 1){
		this.numerator = getNumerator()/t;
		this.denominator = getDenominator()/t;
		t = GCD(getNumerator(),getDenominator());
		}
    }
	
	public Fraction add(Fraction f) {
	  int x = (this.getNumerator() * f.getDenominator())+(f.getNumerator() * this.getDenominator());
	  int y = this.getDenominator() * f.getDenominator();  
	  Fraction t = new Fraction(x,y);
	  return t;
    }
	
	public Fraction multiply(Fraction f) {
		int x = (this.getNumerator() * f.getNumerator());
		int y = (this.getDenominator() * f.getDenominator());
		Fraction t = new Fraction(x,y);
		return t;
    }
	
	public Fraction reciprocal() {
	   int x,y;
	   
	   if(this.getNumerator() != 0){
		   x = this.getNumerator();
		   y = this.getDenominator();
	   }
	   else {
		   y = this.getNumerator();
		   x = this.getDenominator();
	   }
	   
		Fraction t = new Fraction(y,x);
		return t;	   
    }
	
	public Fraction divide(Fraction f) {
       Fraction t = this.multiply(f.reciprocal());
	   return t;
    }"
Name_253,VName_253,"public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon w1=new Wagon(25,30);
        u9.addWagon(w1);
        Wagon w2=new Wagon(55,45);
        u9.addWagon(w2);
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagon w3=new Wagon(25,35);
        u9.addWagon(w3);
        Wagon w4=new Wagon(12,33);
        u9.addWagon(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagon();
        }

        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }

}","public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

   
    public int getNumerator() {
        return numerator;
    }

   
    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

   
    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }
     public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }"
Name_254,VName_254,"public class SubwayTest {
	public static void main(String[] args){
		Subway u7 = new Subway(3);
		u7.addWagon(new Wagon(20,30));
		u7.addWagon(new Wagon(50,45));
		//System.out.println(u7.countWagons()+"" Wagons\n""+u7.getSeats()+"" Seats\n""+u7.getStandingRoom()+"" Standing Room\n""+u7.getCapacity()+"" Capacity"");
		u7.addWagon(new Wagon(12,35));
		u7.addWagon(new Wagon(20, 33));
		for(int i=0;i<5;i++) u7.removeWagon();
		//System.out.println(u7.countWagons()+"" Wagons\n""+u7.getSeats()+"" Seats\n""+u7.getStandingRoom()+"" Standing Room\n""+u7.getCapacity()+"" Capacity"");	
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if (denominator == 0) {
            this.denominator = 1;
            this.numerator = numerator;
		} else if (denominator < 0) { // doesnt matter if numerator is negative as well
            this.denominator = denominator * -1;
            this.numerator = numerator * -1;
        } else {
            this.numerator = numerator;
            this.denominator = denominator;
		}
		this.shorten(); 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         return ((double) this.numerator) / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int reverse = 1;
        if (numerator < 0) {
            reverse = -1;
            numerator = numerator * -1;
        }
        int divide = 0;
        while (divide != 1) {
            divide = GCD(this.numerator, this.denominator);
            this.denominator = this.denominator / divide;
            this.numerator = this.numerator / divide;
        }
        numerator *= reverse;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       this.numerator = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
		this.denominator = denominator * f.getDenominator();
		return new Fraction(this.numerator, this.denominator);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = numerator * f.numerator;
		int newDenominator = denominator * f.denominator;
		Fraction result = new Fraction(newNumerator, newDenominator);
		return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (getNumerator () != 0) {
		   return new Fraction (denominator,numerator);
		}
		return new Fraction (numerator,denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f = f.reciprocal();
		return this.multiply(f);
    }"
Name_255,VName_255,"public class SubwayTest {
	
	public static void main (String[] args) {
		
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon (30,60));
		u9.addWagon(new Wagon (20,40));
		
		System.out.println( u9.countWagons()+"" Wagons\n""+ u9.getSeats()+"" Seats\n""+u9.getStandingRoom()+"" Standing Room\n""+ u9.getCapacity()+"" Capacity"");
		
		u9.addWagon (new Wagon (15,30));
		u9.addWagon (new Wagon (10,20));
		for (int i=0; i<5; i++) {
			u9.removeWagon();
		}
	}
}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		if (denominator == 0) {
			this.denominator = 1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double numeratorDouble = numerator;
		return numeratorDouble/denominator;
    }

    /**
     * Gibt einen String im Format  
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		shorten();
        return (+numerator+""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator, denominator);
		this.numerator = numerator / gcd;
		this.denominator = denominator / gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */

	public Fraction add(Fraction f) {
		this.numerator = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
		this.denominator = denominator * f.getDenominator();
		Fraction sum = new Fraction(this.numerator, this.denominator);
		sum.shorten();
		return sum;
	}
   	
	

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int multipliedNumerator = numerator * f.numerator;
		int multipliedDenominator = denominator * f.denominator;
		Fraction multiple = new Fraction (multipliedNumerator, multipliedDenominator);
		multiple.shorten();
		return multiple;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		int newNumerator;
		int newDenominator;
	   if (numerator != 0) {
		   newNumerator = denominator;
		   newDenominator = numerator;
	   }
	   else {
		   newNumerator = numerator;
		   newDenominator = denominator;
	   }
	   Fraction reciprocal = new Fraction(newNumerator, newDenominator);
	   reciprocal.shorten();
	   return reciprocal;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction reciprocal = f.reciprocal();
	   Fraction quotient = multiply(reciprocal);
	   quotient.shorten();
	   return quotient;
    }"
Name_17,VName_17,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }",-
Name_256,VName_256,"//Hier soll die Klasse UBahnDemo stehen!
class UBahnDemo {
    public static void main(String[] args) {
        Subway U9 = new Subway(3); 
        
        U9.addWagon(new Wagon(10, 10)); 
        U9.addWagon(new Wagon(20, 20));
        
        //System.out.println(""Wagons: "" + U9.countWagons());
        System.out.println(""Sitzplätze: "" + U9.getSeats());
        System.out.println(""Stehplätze: "" + U9.getStandingRoom());
        System.out.println(""Capacity: "" + U9.getCapacity());
        
        U9.addWagon(new Wagon(5, 5)); 
        U9.addWagon(new Wagon(15, 15)); 
        
        U9.removeWagon(); 
        U9.removeWagon(); 
        U9.removeWagon(); 
        U9.removeWagon(); 
        U9.removeWagon(); 

    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return 
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_257,VName_257,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_258,VName_258,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
        	this.denominator = 1;
        	this.numerator = numerator;
        } else {
        	this.denominator = Math.abs(denominator);
        	this.numerator = numerator * (denominator/Math.abs(denominator));	
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """"+this.numerator+""/""+this.denominator+"""";
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int divider = GCD(numerator,denominator);
        this.numerator = this.numerator/divider;
        this.denominator = this.denominator/divider;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
       return new Fraction(this.numerator*(lcm/this.denominator)+f.getNumerator()*(lcm/f.getDenominator()), lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(f.getNumerator()*this.numerator, f.getDenominator()*this.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator == 0) return new Fraction(this.numerator, this.denominator);
       return new Fraction(this.denominator, this.numerator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return f.reciprocal().multiply(this);
    }","class SubwayTest {

	public static void main(String[] args) {
		Subway s = new Subway(3);
		Wagon w0 = new Wagon(4,5);
		Wagon w1 = new Wagon(10,23);
		s.addWagon(w0);
		s.addWagon(w1);
		System.out.println(
			s.countWagons() + "" Wagons\n"" + 
			s.getSeats() + "" Seats\n"" +
			s.getStandingRoom() + "" Standing Room\n""+
			s.getCapacity() + "" Capacity"");
		Wagon w2 = new Wagon(11,5);
		Wagon w3 = new Wagon(6,33);
		s.addWagon(w2);
		s.addWagon(w3);
		for (int i = 0; i < 5; i++) {
			s.removeWagon();
		}
		System.out.println(
			s.countWagons() + "" Wagons\n"" + 
			s.getSeats() + "" Seats\n"" +
			s.getStandingRoom() + "" Standing Room\n""+
			s.getCapacity() + "" Capacity"");
	}
}"
Name_259,VName_259,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            this.denominator = -1 * denominator;
            this.numerator = -1 * numerator;
        } else if (denominator == 0) {
            this.denominator = 1;
            this.numerator = numerator;
        } else {
            this.denominator = denominator;
            this.numerator = numerator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator / denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = Math.abs(GCD(numerator, denominator));
        numerator /= gcd;
        denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int n1 = this.numerator * f.denominator;
        int n2 = f.numerator * this.denominator;
        int d = this.denominator * f.denominator;
        return new Fraction(n1 + n2, d);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (numerator != 0) {
            return new Fraction(denominator, numerator);
        } else {
            return new Fraction(numerator, denominator);
        }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }","public class SubwayTest {

    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon firstWagon = new Wagon(36, 72);
        Wagon secondWagon = new Wagon(42, 60);
        u9.addWagon(firstWagon);
        u9.addWagon(secondWagon);
        System.out.println(
            u9.countWagons() + "" Wagons\n"" +
            u9.getSeats() + "" Seats\n"" +
            u9.getStandingRoom() + "" Standing Room\n"" +
            u9.getCapacity() + "" Capacity""
        );
        Wagon thirdWagon = new Wagon(42, 60);
        Wagon fourthWagon = new Wagon(36, 72);
        u9.addWagon(thirdWagon);
        u9.addWagon(fourthWagon);
        for (int i = 0; i < 5; i++) {
            u9.removeWagon();
        }
        System.out.println(
            u9.countWagons() + "" Wagons\n"" +
            u9.getSeats() + "" Seats\n"" +
            u9.getStandingRoom() + "" Standing Room\n"" +
            u9.getCapacity() + "" Capacity""
        );
    }
}"
Name_260,VName_260,"public class SubwayTest {

	public static void main (String [] args) {

		Subway u9 = new Subway(3);

		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));

		System.out.println(
   	 	u9.countWagons()+"" Wagons\n""+
 		u9.getSeats()+"" Seats\n""+
  		u9.getStandingRoom()+"" Standing Room\n""+
    	u9.getCapacity()+"" Capacity"");

		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));

		for(int i = 0; i < 5; i++) {
			u9.removeWagon();
		}
			System.out.println(
   			u9.countWagons()+"" Wagons\n""+
   			u9.getSeats()+"" Seats\n""+
    		u9.getStandingRoom()+"" Standing Room\n""+
    		u9.getCapacity()+"" Capacity"");

    }
}","public Fraction(int numerator, int denominator) {
		this.denominator = denominator;
		this.numerator= numerator;
		if (denominator == 0){
			this.denominator = 1;
		}
		shorten();
	}

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         return ((double) this.numerator) / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;

		}

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
	 
	
    public void shorten() {
		int gcd = GCD(numerator, denominator);
		if (denominator < 0){
			int a = -1;
			numerator /= gcd*a;
			denominator /= gcd*a;
		}
		else {
		numerator /= gcd;
		denominator /= gcd;
		}
    }
	
/**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */	
	public Fraction add(Fraction f) {
		this.numerator = (numerator * f.getDenominator()) + (f.getNumerator() * denominator);
		this.denominator = denominator * f.getDenominator();
		return new Fraction(this.numerator, this.denominator);
	}
   	
	 /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int newNumerator = numerator * f.numerator;
		int newDenominator = denominator * f.denominator;
		Fraction result = new Fraction(newNumerator, newDenominator);
		return result; 
    }
 /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (getNumerator () != 0) {
		   return new Fraction (denominator,numerator);
		}
		return new Fraction (numerator,denominator);
	}
	  /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		f = f.reciprocal();
		return this.multiply(f);
	}"
Name_261,VName_261,"/* Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
		if(denominator < 0) {
			denominator = (denominator*(-1));
			numerator = (numerator*(-1));
		
		this.denominator = denominator;
		this.numerator = numerator;
		}	
		
		else if(denominator == 0) {
			denominator = 1;
			numerator = numerator;
		
		this.denominator = denominator;
		this.numerator = numerator;
		}	
		
		else{
		this.denominator = denominator;
		this.numerator = numerator;
		shorten();
		}
		
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double fraction = (double)numerator/(double)denominator;
		return fraction;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = + numerator + ""/"" + denominator;
		return str;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int ggT = GCD(numerator, denominator);
		
		numerator =  numerator/ggT;
		denominator = denominator/ggT;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int kgV = LCM(denominator, f.denominator);
	   
	   numerator = ((kgV/denominator)*numerator);
	   f.numerator = ((kgV/f.denominator) *f.numerator);
	   
	   denominator = kgV;
	   numerator = numerator + f.numerator;
    
	 
		return new Fraction(numerator,denominator);
	}

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        numerator = numerator * f.numerator;
		denominator = denominator * f.denominator;
    
	return new Fraction(numerator,denominator);
	}

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator == 0) {
			numerator = numerator;
			denominator = denominator;
	   } 
	   else if (numerator > 0) {
		   int tmp = numerator;
		   numerator = denominator;
		   denominator = tmp;
	   }
		return new Fraction(numerator,denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		numerator = numerator*f.denominator;
		denominator = denominator*f.numerator;
    
	return new Fraction(numerator,denominator);
	
	}",-
Name_262,VName_262,"public class SubwayTest {
	
	public static void main(String[] args) {
		Subway ubahn = new Subway(3);
		
		ubahn.addWagon(new Wagon(50, 75));
		ubahn.addWagon(new Wagon(40, 100));
		
		System.out.println(ubahn.getSeats() + "" Seats"");
		System.out.println(ubahn.getStandingRoom() + "" Standing Room"");
		System.out.println(ubahn.getCapacity() + "" Capacity"");
		
		ubahn.addWagon(new Wagon(60, 65));
		ubahn.addWagon(new Wagon(30, 110));
		
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
		ubahn.removeWagon();
	}
}","/**
	 * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
	 * uebergeben bekommt und die entsprechenden Attribute setzt. 
	 * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
	 * auftreten (nicht im ""denominator""-Attribut).
	 * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
	 * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
	 * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
	 * und der Wert des Bruchs (die Argumente) unverändert bleibt 
	 * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
	 * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
	 * auf Eins gesetzt.
	 * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
	 */
	public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		if(denominator < 0) {
			this.numerator *= (-1);
			this.denominator *= (-1);
		}
		else if(denominator == 0) {
			this.denominator++;
		}
		this.shorten();
	}

	/**
	 * Gibt den Nenner zurueck.
	 */
	public int getDenominator() {
		return denominator;
	}

	/**
	 * Gibt den Zaehler zurueck.
	 */
	public int getNumerator() {
		return numerator;
	}

	/**
	 * Gibt den Bruch als Gleitkommazahl zurueck.
	 */
	public double toDouble() {
		double d = (double)numerator / (double)denominator;
		return d;
	}

	/**
	 * Gibt einen String im Format
	 * ""Zaehler/Nenner"" zurueck.
	 */
	public String toString() {
		return """" + numerator + ""/"" + denominator + """";
	}

	/**
	 * Kuerzt (vereinfacht) den Bruch.
	 */
	public void shorten() {
		int gcd = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator/gcd;
		this.denominator = this.denominator/gcd;
	}

	/**
	 * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
	 */
	public Fraction add(Fraction f) {
		int numerator = this.numerator;
		int denominator = this.denominator;
		numerator = numerator * f.denominator + f.numerator * denominator;
		denominator = denominator * f.denominator;
		return new Fraction(numerator, denominator);
	}

	/**
	 * Multipliziert mit dem uebergebenen Bruch.
	 */
	public Fraction multiply(Fraction f) {
		int numerator = this.numerator;
		int denominator = this.denominator;
		numerator = numerator * f.numerator;
		denominator = denominator * f.denominator;
		return new Fraction(numerator, denominator);
		}

	/**
	 * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
	 * Sonst wird der Bruch unveraendert zurueckgegeben.
	 */
	public Fraction reciprocal() {
		int numerator = this.numerator;
		int denominator = this.denominator;
		if(numerator != 0) {
		   int num = numerator;
		   numerator = denominator;
		   denominator = num;
	   }
	   return new Fraction(numerator, denominator);
	}

	/**
	 * Dividiert durch den uebergebenen Bruch 
	 * (unter Verwendung von Kehrwert und Multiplikation).
	 */
	public Fraction divide(Fraction f) {
		Fraction bruch = this.multiply(f.reciprocal());
		bruch.shorten();
		return bruch;
	}"
Name_263,VName_263,"public Fraction(int numerator, int denominator) {

    if(denominator<0){
            numerator = numerator * (-1);
            denominator *= -1;
         }
    
  if(numerator==0){
        this.numerator = 1;
      
    }
    this.numerator = numerator;
        this.denominator = denominator;

        shorten();

  }

  /**
   * Gibt den Nenner zurueck.
   */
  public int getDenominator() {
    return denominator;

  }

  /**
   * Gibt den Zaehler zurueck.
   */
  public int getNumerator() {
    int numerator = 0;
    return numerator += this.numerator;

  }

  /**
   * Gibt den Bruch als Gleitkommazahl zurueck.
   */
  public double toDouble() {
      return  (double) numerator / (double) denominator;
  }

  /**
   * Gibt einen String im Format
   * ""Zaehler/Nenner"" zurueck.
   */
  public String toString() {
     return numerator + ""/"" + denominator;

  }

  /**
   * Kuerzt (vereinfacht) den Bruch.
   */
  public void shorten() {
    int x = GCD(numerator, denominator);
        numerator /= x;
        denominator /= x;
    }



  /**
   * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
   */
  public Fraction add(Fraction f) {
    return new Fraction(
                (this.numerator * f.denominator) + (f.numerator * this.denominator),
                this.denominator * f.denominator);

  }

  /**
   * Multipliziert mit dem uebergebenen Bruch.
   */
  public Fraction multiply(Fraction f) {
    return new Fraction(this.numerator * f.numerator,
                  this.denominator * f.denominator );

  }

  /**
   * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
   * Sonst wird der Bruch unveraendert zurueckgegeben.
   */
  public Fraction reciprocal() {
  return new Fraction(denominator,numerator);
}



  /**
   * Dividiert durch den uebergebenen Bruch
   * (unter Verwendung von Kehrwert und Multiplikation).
   */
  public Fraction divide(Fraction f) {

        return multiply(f.reciprocal());

  }","public class SubwayTest {



    public static void main(String [] args) {
      Subway train = new Subway(3);
      train.countWagon(2);
      train.getSeats(25);
      train.getStandingRoom(30);
      train.getCapacity();
      train.addWagons(25,30);
      train.removeWagon(10,20);
      System.out.println(train.countWagon()+"" Wagons\n""+
    train.getSeats()+"" Seats\n""+
    train.getStandingRoom()+"" Standing Room\n""+
    train.getCapacity()+"" Capacity""
);
train.addWagon(25,30);
for(int i=0;i<5;i++) {
  train.removeWagon();
  System.out.println(
    train.countWagons()+"" Wagons\n""+
    train.getSeats()+"" Seats\n""+
    train.getStandingRoom()+"" Standing Room\n""+
    train.getCapacity()+"" Capacity"";
}

    }
}"
Name_264,VName_264,"public class SubwayTest {
    public static void main(String[] args) {
        Subway u5 = new Subway(3);
        u5.addWagon(new Wagon(30, 90));
        u5.addWagon(new Wagon(25, 100));
        System.out.println(u5.countWagons() + "" Wagons\n"" + u5.getSeats() + "" Seats\n"" + u5.getStandingRoom() + "" Standing Room\n"" + u5.getCapacity() + "" Capacity"");

        u5.addWagon(new Wagon(15, 50));
        u5.addWagon(new Wagon(40, 20));

        for (int i = 0; i < 5; i++) u5.removeWagon();
        System.out.println(u5.countWagons() + "" Wagons\n"" + u5.getSeats() + "" Seats\n"" + u5.getStandingRoom() + "" Standing Room\n"" + u5.getCapacity() + "" Capacity"");
        return;
    }

}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
        if (this.denominator < 0) {
            this.numerator *= -1;
            this.denominator *= -1;
        } else if (this.denominator == 0) {
            this.denominator = 1;
        }
        shorten();

//        System.out.println(""getNumerator: "" + this.getNumerator());
//        System.out.println(""getDenominator: "" + this.getDenominator());
//        System.out.println(""toDouble: "" + this.toDouble());
//
//        final int gcd = Fraction.GCD(this.numerator, this.denominator);
//        System.out.println(""GCD: "" + gcd);
//
//        System.out.println(""toString: "" + this.toString());
//        this.shorten();
//        System.out.println(""toString: "" + this.toString());
    }

//    public static void main(String[] args) {
////        final Fraction[] fractions = new Fraction[]{
////                new Fraction(25, 50),
////                new Fraction(25, -50),
////                new Fraction(-25, 50),
////                new Fraction(-25, -50),
////                new Fraction(5, 0),
////                new Fraction(1, 5),
////                new Fraction(2, 7)
////        };
////
////        System.out.println();
////        System.out.println(""----"");
////
////        System.out.println(fractions[5].toString());
////        System.out.println(fractions[6].toString());
////        fractions[5].add(fractions[6]);
////        fractions[5].multiply(fractions[6]);
////
////        System.out.println(new Fraction(1, 1).divide(new Fraction(1, 2)).toString()); // = 2
//        System.out.println(new Fraction(18, 2).toString()); // 9/1
//        System.out.println(new Fraction(2, 7).add(new Fraction(3, 7)).toString()); // = 5/7
//        System.out.println(new Fraction(1, 7).add(new Fraction(-1, 5)).toString()); // = -2/35
//        System.out.println(new Fraction(2, 3).divide(new Fraction(-2, 3)).toString()); // = -1/1
//    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""5/5"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        final int gcd = Fraction.GCD(this.numerator, this.denominator);
        this.numerator /= gcd;
        this.denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        final int lcm = Fraction.LCM(this.denominator, f.denominator);
        final int num1 = lcm / this.denominator * this.numerator;
        final int num2 = lcm / f.denominator * f.numerator;
        final Fraction result = new Fraction(num1 + num2, lcm);
        result.shorten();
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        final Fraction result = new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
        result.shorten();
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator != 0) {
            final Fraction result = new Fraction(this.denominator, this.numerator);
            result.shorten();
            return result;
        } else {
            return new Fraction(this.numerator, this.denominator);
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }"
Name_265,VName_265,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	
	
	
	
    public Fraction(int numerator, int denominator) {
    	if (denominator < 0) { 
    		this.denominator = Math.abs(denominator); 
    		this.numerator = -numerator;
    	} else if (denominator == 0) { 
    		this.denominator = 1; 
    		this.numerator = numerator;
    	} else {
    	    this.numerator = numerator;
            this.denominator = denominator;
    	}
    	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    	int sh = numerator;
    	numerator = numerator/GCD(numerator, denominator);
    	denominator = denominator/GCD(sh, denominator);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int dE = denominator * f.getDenominator();
       int n1E = numerator * f.getDenominator();
       int n2E = f.getNumerator() * denominator;
       return new Fraction(n1E + n2E, dE);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
    }
    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	if (numerator != 0) {
    		int nR = denominator;
    		denominator = numerator;
    		numerator = nR;
    	}
    	return new Fraction(numerator, denominator);
    }
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	f.reciprocal();
    	return this.multiply(f);
    }","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {

	public static void main(String[] args) {

		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity""
		);
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++) u9.removeWagon();
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity""
		);
	}
    }"
Name_266,VName_266,"public class SubwayTest {
	
	public static void main(String[] args) {
		Subway u5 = new Subway(3);
		u5.addWagon(new Wagon(30,70));
		u5.addWagon(new Wagon(15,25));
		System.out.println(u5.getSeats()+"" Seats \n""
				+u5.getStandingRoom()+"" Standing Room \n""
				+ u5.getCapacity()+"" Capacity"");
		u5.addWagon(new Wagon(17,36));
		u5.addWagon(new Wagon(20,40));
		for(int i=0;i<5;i++){
			u5.removeWagon();
		}
	}
	
	
}","public Fraction(int numerator, int denominator) {
        this.numerator=numerator;
		this.denominator=denominator;
		if(denominator==0){
			numerator=numerator;
			denominator=1;
		}
		if(denominator<0){
			numerator= -numerator;
			denominator= -denominator;
		}
		else{
		numerator=numerator;
		denominator=denominator;
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double x;
        return x=(double) numerator / (double) denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator +""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int ggt= GCD(numerator,denominator);
		if(denominator>0){
		numerator/=ggt;
		denominator/=ggt;
		}	
		else if (denominator<0){
			numerator = -numerator;
			denominator = -denominator;
		}
		else if(denominator==0){
			numerator = numerator;
			denominator = 1;
		}
		

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		numerator=numerator*f.getDenominator()+denominator*f.getNumerator();
		denominator= denominator*f.getDenominator();
		Fraction e=new Fraction(numerator,denominator);
		e.shorten();
		return e;

		
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		numerator=numerator*f.getNumerator();
		denominator=denominator*f.getDenominator();
		Fraction d=new Fraction(numerator,denominator);		
		d.shorten();
		return d;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if(numerator!=0){
			int x= numerator;
			numerator=denominator;
			denominator=x;
			Fraction c=new Fraction(numerator,denominator);
			return c;
		}
		else {
			Fraction d=new Fraction(numerator,denominator);
			return d;
		}
		
		
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction kehrwert= new Fraction(f.getNumerator(),f.getDenominator());
		kehrwert=kehrwert.reciprocal();
		Fraction multiplizieren= new Fraction(kehrwert.getNumerator(),kehrwert.getDenominator());
		Fraction g=new Fraction(numerator,denominator);
		multiplizieren=multiplizieren.multiply(g);
		numerator= multiplizieren.getNumerator();
		denominator=multiplizieren.getDenominator();
		Fraction h=new Fraction(numerator,denominator);


					
		h.shorten();
		return h;
	}"
Name_267,VName_267,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator_, int denominator_) {
        this.numerator = numerator_;
		this.denominator = denominator_;
		if (denominator_<0){
			this.denominator = denominator * -1;
			this.numerator *= -1;
		}
		else if (denominator_ == 0){
			this.denominator = 1;
		}
		shorten(numerator, denominator);
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double toDouble = (double)numerator / (double)denominator;
		return toDouble;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
	@Override
    public String toString() {
        String ausgeben;
		ausgeben = numerator+""/""+denominator;
		return ausgeben;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten(int numerator, int denominator) {
        int gcd = GCD(numerator, denominator);
		int numeratorKurz = numerator / gcd;
		int denominatorKurz = denominator / gcd;
		
		this.numerator = numeratorKurz;
		this.denominator = denominatorKurz;
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int nA = this.numerator;
		int nB = f.getNumerator();
		int dA = this.denominator;
		int dB = f.getDenominator();
		
		int lcm = LCM(dA, dB);
		
		int fA = lcm / dA;
		int fB = lcm / dB;
		
		int mA = nA * fA;
		int mB = nB * fB;
		
		int newN = mA + mB;
		
		return new Fraction(newN, lcm);
		
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int nA = this.numerator;
		int nB = f.getNumerator();
		int dA = this.denominator;
		int dB = f.getDenominator();
		
		int neuN = nA * nB;
		int neuD = dA * dB;
		
		return new Fraction (neuN, neuD);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if(this.numerator == 0){	
			return new Fraction( this.numerator, this.denominator);
		}else{
			return new Fraction(this.denominator, this.numerator);
		}
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		return multiply(f.reciprocal());
    }","public class SubwayTest  {
	
	public static void main (String[] args){
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(55,43));
		u9.addWagon(new Wagon(34,65));
		System.out.println(
			u9.countWagons()+"" Wagons\n""+
			u9.getSeats()+"" Seats\n""+
			u9.getStandingRoom()+"" Standing Room\n""+
			u9.getCapacity()+"" Capacity""
			);
		u9.addWagon(new Wagon(45,33));
		u9.addWagon(new Wagon(56,45));
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		System.out.println(
			u9.countWagons()+"" Wagons\n""+
			u9.getSeats()+"" Seats\n""+
			u9.getStandingRoom()+"" Standing Room\n""+
			u9.getCapacity()+"" Capacity""
			);
		
	}
	
	
}"
Name_268,VName_268,"public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }

    public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }","public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon w1=new Wagon(25,30);
        u9.addWagon(w1);
        Wagon w2=new Wagon(55,45);
        u9.addWagon(w2);
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagon w3=new Wagon(25,35);
        u9.addWagon(w3);
        Wagon w4=new Wagon(12,33);
        u9.addWagon(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagon();
        }
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }
}"
Name_269,VName_269,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
   
		
	public Fraction(int numerator, int denominator) {
     if (denominator == 0) {
            this.denominator =1;
            this.numerator = numerator;
		} else if (denominator < 0) { 
            this.denominator =denominator * -1;
            this.numerator =numerator * -1;
        } else {
            this.numerator =numerator;
            this.denominator =denominator;
		}
		this.shorten(); 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) this.numerator)/this.denominator; // (double) wenn von einer form in die andere konvertiert
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.        
     */
    public void shorten() {
              int reverse = 1;
        if (numerator < 0) {
            reverse = -1;
            numerator = numerator * -1;
        }
        int divide = 0;
        while ( divide != 1) {
            divide = GCD (this.numerator, this.denominator);
            this.denominator = this.denominator / divide;
            this.numerator = this.numerator / divide;
        }
        numerator *= reverse;
    }
    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
      
	this.numerator = (numerator*f.getDenominator()) + (f.getNumerator()*denominator);
		this.denominator = denominator*f.getDenominator();
		return new Fraction(this.numerator,this.denominator); // objekt wird erstellt und direkt abgespeichert
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int x = numerator * f.getNumerator();
		int y = denominator * f.getDenominator();
		Fraction g = new Fraction(x,y);
		return g;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		
       if (getNumerator() != 0) {
		   return new Fraction (denominator, numerator);
		}
		return new Fraction (numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
	  f = f.reciprocal() ;
		return this.multiply(f);
	}","public class SubwayTest {
	public static void main (String [] args) {
	Subway u9 = new Subway(3);
u9.addWagon(new Wagon(25,30));
u9.addWagon(new Wagon(55,45));

System.out.println(u9.countWagons()+"" Wagons\n""+u9.getSeats()+"" Seats\n""+u9.getStandingRoom()+"" Standing Room\n""+u9.getCapacity()+"" Capacity"");

u9.addWagon(new Wagon(20,35));
u9.addWagon(new Wagon(12, 33));
for(int i=0;i<5;i++) u9.removeWagon();

System.out.println(u9.countWagons()+"" Wagons\n""+ u9.getSeats()+"" Seats\n""+ u9.getStandingRoom()+"" Standing Room\n""+u9.getCapacity()+"" Capacity"");
	}
}"
Name_270,VName_270,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_271,VName_271,"public class SubwayTest{
	public static void main(String[] args){
		Subway u9 = new Subway(3);
u9.addWagon(new Wagon(25,30));
u9.addWagon(new Wagon(55,45));
System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity""
);
u9.addWagon(new Wagon(20,35));
u9.addWagon(new Wagon(12, 33));
for(int i=0;i<5;i++) u9.removeWagon();
System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity""
);
	
	
	
	
	

	
	
	
	}
	
	
}","public Fraction(int x, int y) {
       
		if(y== 0 ){
			denominator = 1;
			numerator = x;
		}
		if(y<0){
			denominator = y*-1;
			numerator = x*-1;
		}
		if(y>0){
			denominator = y;
			numerator = x;
		}
		shorten();
	} 
	/**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
       
	   return (double)numerator/denominator; 
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return Integer.toString(numerator)+""/""+Integer.toString(denominator);
    }
	 

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
			int nwd = GCD(numerator, denominator);
			numerator = numerator/nwd;
			denominator = denominator/nwd;
			
		
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int nww = LCM(denominator, f.getDenominator() );
	   int nowynumerator1 = numerator*(nww/denominator);
	  int nowynumerator2 = f.getNumerator()*(nww/f.getDenominator());
	   Fraction ulamek = new Fraction(nowynumerator1+nowynumerator2, nww);	
		return ulamek;
	
	}

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
			int nowynumerator = numerator*f.getNumerator();
			int nowydenominator = denominator*f.getDenominator();
		Fraction ulamek = new Fraction(nowynumerator, nowydenominator);
		return ulamek;
	}

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
     Fraction ulamek;
	   if(numerator!=0){
		    ulamek = new Fraction (denominator, numerator);
	   }
	   else{
		   ulamek = new Fraction(numerator,denominator);
			
	   }
	   return ulamek;
   }
	
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
      Fraction ulamek = multiply(f.reciprocal()) ;
	  return ulamek;
    }"
Name_272,VName_272,"public class SubwayTest {
	public static void main(String[] args) {
		Subway u9 = new Subway(3);		
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
			    u9.countWagons()+"" Wagons\n""+
			    u9.getSeats()+"" Seats\n""+
			    u9.getStandingRoom()+"" Standing Room\n""+
			    u9.getCapacity()+"" Capacity"");
		u9.addWagon(new Wagon (20, 35));
		u9.addWagon(new Wagon (12,33));
		for(int i=0; i<5; i++) {
			u9.removeWagon();
		}
		System.out.println(
			    u9.countWagons()+"" Wagons\n""+
			    u9.getSeats()+"" Seats\n""+
			    u9.getStandingRoom()+"" Standing Room\n""+
			    u9.getCapacity()+"" Capacity"");
		
	}

}","public int kürzungszahl;
	public int erweiterungszahl;

	public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
	}
	public int getDenominator() {
		if (denominator < 0) {
			denominator = -denominator;
		} else if (denominator == 0) {
			denominator = 1;
		}
		return denominator;

	}


	public int getNumerator() {
		return numerator;
	}

	
	public double toDouble() {
		double Bruch = numerator / denominator;
		return Bruch;
	}
	public String toString() {
		String Bruch = +numerator + ""/"" + denominator;
		return Bruch;
	}

	public void shorten() {
		numerator /= kürzungszahl;
		denominator /= kürzungszahl;
	}

	public Fraction add(Fraction f) {
		int b= f.denominator % denominator;
		int a = f.numerator + numerator;
		a= a/b;
		return new Fraction(a, b);

	}

	public Fraction multiply(Fraction f) {
		int x = f.numerator * numerator;
		int y = f.denominator * denominator;
		return new Fraction(x, y);
	}
	public Fraction reciprocal() {
		if (numerator != 0) {
			this.denominator = numerator;
			this.numerator = denominator;
			return new Fraction(this.denominator, this.numerator);
		}else {
		return new Fraction(numerator, denominator);
		}

	}
	public Fraction divide(Fraction f) {
		f.reciprocal();
		f.multiply(f);
		return new Fraction (f.numerator, f.denominator);

	}"
Name_273,VName_273,"public class SubwayTest{
	public static void main(String[] args){
		Subway u=new Subway(3);
		Wagon w1=new Wagon(25,30);
		Wagon w2=new Wagon(55,45);
		u.addWagon(w1);
		//System.out.println(u.countWagons());
		u.addWagon(w2);
		//System.out.println(u.countWagons());
		System.out.println(u.countWagons()+"" Wagons\n""+u.getSeats()+"" Seats\n""+u.getStandingRoom()+"" Standing Room\n""+u.getCapacity()+"" Capacity"");
		Wagon w3=new Wagon(100,150);
		Wagon w4=new Wagon(110,160);
		u.addWagon(w3);
		u.addWagon(w4);
		for(int i=0;i<5;i++) u.removeWagon();
		System.out.println(u.countWagons()+"" Wagons\n""+u.getSeats()+"" Seats\n""+u.getStandingRoom()+"" Standing Room\n""+u.getCapacity()+"" Capacity"");
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator<0){
			numerator*=-1;
			denominator*=-1;
		}
		if (denominator==0){
			denominator=1;
		}
		this.numerator=numerator;
		this.denominator=denominator;
		shorten();
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator / (double) denominator;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s= numerator+""/""+denominator;
		return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int common= GCD(numerator,denominator);
		numerator=numerator/common;
		denominator=denominator/common;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        Fraction sum=new Fraction(numerator,denominator);
		sum.denominator=denominator*f.denominator;
		sum.numerator=numerator*f.denominator+denominator*f.numerator;
		sum.shorten();
		return sum;
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction product=new Fraction(numerator,denominator);
		product.numerator=numerator*f.numerator;
		product.denominator=denominator*f.denominator;
		product.shorten();
		return product;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        Fraction inverse=new Fraction(numerator,denominator);
	 
	    if (this.numerator!=0){
		   inverse.numerator=this.denominator;
		   inverse.denominator=this.numerator;
	   }
	   inverse.shorten();
	   return inverse;
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction result=new Fraction(numerator,denominator);
		result=result.multiply(f.reciprocal());
		return result;
       
    }"
Name_274,VName_274,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        //Fall Nenner = 0 abfangen:
        if (denominator == 0)
            denominator = 1;

        //ggf Vorzeichen anpassen: (für Fälle (-/-) & (+/-))
        if ((numerator < 0 && denominator < 0) || (numerator > 0 && denominator < 0)) {
            numerator *= (-1);
            denominator *= (-1);
        }
        
        this.numerator = numerator;
        this.denominator = denominator;
        
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) this.numerator / (double) this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (this.numerator + ""/"" + this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        //ggT bestimmen:
        int ggT = GCD(this.numerator, this.denominator);
        
        //kürzen:
        if (ggT != 1 && ggT != 0) {
            this.numerator /= ggT;
            this.denominator /= ggT;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int nenner1 = this.denominator;
        int nenner2 = f.getDenominator();
        int kgV = LCM(nenner1, nenner2);

        int zaehler1 = this.numerator * (kgV / nenner1);
        int zaehler2 = f.getNumerator() * (kgV / nenner2);
        int sumZaehler = zaehler1 + zaehler2;
        return new Fraction(sumZaehler, kgV);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction((this.numerator * f.getNumerator()), (this.denominator * f.getDenominator()));
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (this.numerator != 0) {
           int s = this.denominator;
           this.denominator = this.numerator;
           this.numerator = s;
       }
       return new Fraction(this.numerator, this.denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f = f.reciprocal();
       return multiply(f);
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {
    public static void main(String[] args) throws Exception {
        Subway uBahn = new Subway(3);
        uBahn.addWagon(new Wagon(5, 10));
        uBahn.addWagon(new Wagon(22, 30));
        p(uBahn.getSeats() + "" Seats"");
        p(uBahn.getStandingRoom() + "" Standing Room"");
        p(uBahn.getCapacity() + "" Capacity"");
        uBahn.addWagon(new Wagon(15, 20));
        uBahn.addWagon(new Wagon(30, 40));
        for (int i = 0; i < 5; i++) {
            uBahn.removeWagon();
        }
    }

    public static void p(String s) {
        System.out.println(s);
    }
}"
Name_275,VName_275,"//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {
	
	public static void main(String[] args) {
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(57, 120));
		u9.addWagon(new Wagon(80, 100));
		System.out.println(u9.getSeats()+"" Seats\n""
			+u9.getStandingRoom()+"" Standing Room\n""+u9.getCapacity()+"" Capacity"");
		u9.addWagon(new Wagon(43, 22));
		u9.addWagon(new Wagon(59, 110));
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
		u9.removeWagon();
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
	 	this.numerator = numerator;
	 	this.denominator = denominator;
	 	this.getNumerator();
	 	this.getDenominator();
	 	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		if (denominator == 0) {
			denominator = 1;
		}
		else if (denominator <= 0) {
			denominator *= -1;
		}
		return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		if (numerator < 0 && denominator < 0) {
		    	 numerator = numerator*-1;
		 } else if (numerator > 0 && denominator < 0) {
		    		numerator = numerator*-1;
		 }
		 return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double gleitkomma = (double)numerator/denominator;
		return gleitkomma;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String stringbruch = this.numerator+""/""+this.denominator;
		return stringbruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int gcd = GCD(this.numerator,this.denominator);
		this.numerator = this.numerator/gcd;
		this.denominator = this.denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int lcm = LCM(this.denominator,f.denominator);
		int denominator2 = lcm;
		int a = lcm/this.denominator;
		int b = lcm/f.denominator;
		int numerator2 = this.numerator*a + f.numerator*b;
		return new Fraction(numerator2,denominator2);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int numerator2 = f.numerator*this.numerator;
		int denominator2 = f.denominator*this.denominator;
		return new Fraction(numerator2, denominator2);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
		if (this.numerator != 0) {
			return new Fraction(this.denominator,this.numerator);
		}
		else{
			return new Fraction(this.numerator,this.denominator);
		}
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction bruch1 = f.reciprocal();
		Fraction bruch2 = this.multiply(bruch1);
     	return new Fraction(bruch2.numerator,bruch2.denominator);
    }"
Name_276,VName_276,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
     * und der Wert des Bruchs (die Argumente) unverändert bleibt
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0){
            denominator = 1;
        }

        if (denominator < 0){
            denominator *= -1;
            numerator *= -1;
        }

        this.numerator = numerator;
        this.denominator = denominator;

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double num = this.numerator;
        double den = this.denominator;

        return num/den;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {

        int gcd = GCD(this.numerator, this.denominator);

        if (gcd != 1){
            this.numerator /= gcd;
            this.denominator /= gcd;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int num = f.getNumerator();
        int den = f.getDenominator();

        int lcm = LCM(this.denominator, den);

        // Ersten Bruch erweitern
        int a = lcm / this.denominator;
        int a_num = a * this.numerator;

        // Zweiten Bruch erweitern
        int b = lcm / den;
        int b_num = b * num;

        int num_final = a_num + b_num;

        return new Fraction(num_final, lcm);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int num = this.numerator * f.getNumerator();
        int den = this.denominator * f.getDenominator();

        return new Fraction(num, den);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator == 0){
            return this;
        }
        return new Fraction(this.denominator, this.numerator);
    }

    /**
     * Dividiert durch den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f = f.reciprocal();

        return this.multiply(f);
    }","public class SubwayTest {

    public static void main(String[] args){

        Subway u2 = new Subway(3);
        u2.addWagon(new Wagon(30, 30));
        u2.addWagon(new Wagon(25, 25));

        System.out.println(u2.getSeats()+"" Seats"");
        System.out.println(u2.getStandingRoom()+"" Standing Room"");
        System.out.println(u2.getCapacity()+"" Capacity"");

        u2.addWagon(new Wagon(10, 10));
        u2.addWagon(new Wagon(15, 15));

        for (int i = 0; i < 5; i ++) u2.removeWagon();
    }
}"
Name_277,VName_277,"public class SubwayTest{
	public static void main (String[] args){
		Subway u9 = new Subway(3);
u9.addWagon(new Wagon(25,30));
u9.addWagon(new Wagon(55,45));
System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity""
);
u9.addWagon(new Wagon(20,35));
u9.addWagon(new Wagon(12, 33));
for(int i=0;i<5;i++) u9.removeWagon();
System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity""
);
	}
}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;

        if (denominator == 0)
            this.denominator = 1;
        else if (denominator < 0) {
            this.denominator = (-1) * denominator;
            this.numerator = (-1) * this.numerator;
        } else
            this.denominator = denominator;

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return this.numerator / ((double) this.denominator);
    }

    /**
     * Gibt einen String im Format ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (this.getNumerator() + ""/"" + this.getDenominator());
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int x = this.numerator;
        int y = this.denominator;
        if (this.numerator < 0)
            x = this.numerator * (-1);
        if (this.denominator < 0)
            y = this.denominator * (-1);
        int divisor = GCD(x, y);
        this.numerator = this.numerator / divisor;
        this.denominator = this.denominator / divisor;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int rNumerator = f.denominator * this.numerator + this.denominator * f.numerator;
        int rDemoninator = f.denominator * this.denominator;
        Fraction result = new Fraction(rNumerator, rDemoninator);
        return result;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int rNumerator = this.numerator * f.numerator;
        int rDemoninator = this.denominator * f.denominator;
        Fraction result = new Fraction(rNumerator, rDemoninator);
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist. Sonst wird der Bruch
     * unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
        if (this.numerator == 0) {
            return this;
        } else {
            Fraction inverted = new Fraction(this.denominator, this.numerator);
            return inverted;
        }
    }

    /**
     * Dividiert durch den uebergebenen Bruch (unter Verwendung von Kehrwert und
     * Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return multiply(f.reciprocal());

    }"
Name_278,VName_278,"//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {
    public static void main(String[] args) {
        Subway u2 = new Subway(3);
        u2.addWagon(new Wagon(25,30));
        u2.addWagon(new Wagon(43,23));
        System.out.println(
            u2.countWagons()+ "" Wagons\n""+
            u2.getSeats()+ "" Seats\n""+
            u2.getStandingRoom()+ "" Standing Room\n""+
            u2.getCapacity()+ "" Capacity""
        );

        u2.addWagon(new Wagon(31,50));
        u2.addWagon(new Wagon(42,46));
        for(int i=0; i<5;i++) u2.removeWagon();
        System.out.println(
            u2.countWagons()+ "" Wagons\n""+
            u2.getSeats()+ "" Seats\n""+
            u2.getStandingRoom()+ "" Standing Room\n""+
            u2.getCapacity()+ "" Capacity""
        );
    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator<0){
            this.numerator= -1*numerator;
            this.denominator= -1*denominator;
        }
        else if(denominator==0){
        
            this.numerator=numerator;
            this.denominator=1;
        }
        else{
            this.numerator = numerator;
            this.denominator = denominator;
        }
            
       shorten() ;
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
       
       
       return (double) numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String b = numerator+""/""+ denominator;
        return b;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int shrt = GCD(numerator, denominator);
        numerator /= shrt;
        denominator /= shrt;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(denominator, f.denominator);
       int d = lcm/denominator;
       int e = lcm/ f.denominator;
       return new Fraction(numerator*d + f.numerator*e, lcm);
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.numerator, denominator*f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       boolean c = numerator != 0;
       if(c)
       return new Fraction(denominator,numerator);
       else
       return this;
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return multiply(f.reciprocal());
    
    }"
Name_279,VName_279,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	
	
	
	
    public Fraction(int numerator, int denominator) {
    	if (denominator < 0) { 
    		this.denominator = Math.abs(denominator); 
    		this.numerator = -numerator;
    	} else if (denominator == 0) { 
    		this.denominator = 1; 
    		this.numerator = numerator;
    	} else {
    	    this.numerator = numerator;
            this.denominator = denominator;
    	}
    	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    	int tmp = numerator;
    	numerator = numerator/GCD(numerator, denominator);
    	denominator = denominator/GCD(tmp, denominator);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int deEx = denominator * f.getDenominator();
       int n1 = numerator * f.getDenominator();
       int n2 = f.getNumerator() * denominator;
       return new Fraction(n1 + n2, deEx);
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator * f.getNumerator(), denominator * f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
    	if (numerator != 0) {
    		int nNew = denominator;
    		denominator = numerator;
    		numerator = nNew;
    	}
    	return new Fraction(numerator, denominator);
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    	f.reciprocal();
    	return this.multiply(f);
    }","//Hier soll die Klasse UBahnDemo stehen!
public class SubwayTest {

	public static void main(String[] args) {

		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity""
		);
		u9.addWagon(new Wagon(20,35));
		u9.addWagon(new Wagon(12, 33));
		for(int i=0;i<5;i++) u9.removeWagon();
		System.out.println(
		u9.countWagons()+"" Wagons\n""+
		u9.getSeats()+"" Seats\n""+
		u9.getStandingRoom()+"" Standing Room\n""+
		u9.getCapacity()+"" Capacity""
		);
	}

}"
Name_280,VName_280,"public class SubwayTest{
    public static void main(String[] args) {
        Subway u9 = new Subway(3);
        Wagon w1=new Wagon(25,30);
        u9.addWagon(w1);
        Wagon w2=new Wagon(55,45);
        u9.addWagon(w2);
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                          u9.getStandingRoom()+"" Standing Room\n""+
                          u9.getCapacity()+"" Capacity\n"");
        Wagon w3=new Wagon(25,35);
        u9.addWagon(w3);
        Wagon w4=new Wagon(12,33);
        u9.addWagon(w4);
                        
        for(int i=0;i<5;i++) {
            u9.removeWagon();
        }
        System.out.print( u9.countWagons()+"" Wagons\n""+
                          u9.getSeats()+"" Seats\n""+
                         u9.getStandingRoom()+"" Standing Room\n""+
                         u9.getCapacity()+"" Capacity"");
    }
}","public Fraction(int numerator, int denominator) {
        if(denominator>0){
            this.numerator=numerator;
            this.denominator=denominator;
        }
        if(denominator<0){
            this.denominator=-denominator;
            this.numerator=-numerator;
        }
        if(denominator == 0){
            this.numerator=numerator;
            this.denominator = 1;
        }
        shorten();
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return(double) numerator / (double) denominator;
    }

    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    public void shorten() {
        if(numerator==0){
            this.numerator=0;
            this.denominator=1;
        }
        else{
            int GCD=GCD(this.numerator,this.denominator);
            this.numerator=this.numerator/GCD;
            this.denominator=this.denominator/GCD;
            if(this.denominator<0){
                this.numerator=-this.numerator;
                this.denominator=-this.denominator;
            }
        }
    }

    public Fraction add(Fraction f) {
       int newNumerator=(numerator*f.denominator)+(f.numerator*denominator);
       int newDenominator=denominator*f.denominator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }

    public Fraction multiply(Fraction f) {
       int newNumerator = numerator * f.numerator;
       int newDenominator = denominator * f.denominator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;
    }

    public Fraction reciprocal() {
       if(numerator!=0){
           return new Fraction(denominator,numerator);
       }
       else{
           return new Fraction(numerator,denominator);
       }
    }
    
    public Fraction divide(Fraction f) {
       int newNumerator=numerator*f.getDenominator();
       int newDenominator=denominator*f.numerator;
       Fraction result=new Fraction(newNumerator,newDenominator);
       return result;
    }"
Name_281,VName_281,"public class SubwayTest {

	public static void main(String[] args) {
		Subway sub = new Subway(3);
		sub.addWagon(new Wagon(23,25));
		sub.addWagon(new Wagon(33,42));
		System.out.println(sub.countWagons()+"" Wagons"");
		System.out.println(sub.getSeats()+"" Seats"");
		System.out.println(sub.getStandingRoom()+"" Standing Room"");
		System.out.println(sub.getCapacity()+"" Capacity"");
		sub.addWagon(new Wagon(54,12));
		sub.addWagon(new Wagon(22,11));
		sub.removeWagon();
		sub.removeWagon();
		sub.removeWagon();
		sub.removeWagon();
		sub.removeWagon();
		System.out.println(sub.countWagons()+"" Wagons"");
		System.out.println(sub.getSeats()+"" Seats"");
		System.out.println(sub.getStandingRoom()+"" Standing Room"");
		System.out.println(sub.getCapacity()+"" Capacity"");
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            this.numerator *= -1;
        }
    	if (denominator == 0) {
    		this.denominator = 1;	    		
    	}	
    	this.numerator = numerator;
    	this.denominator = denominator; 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double) numerator)/((double) denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int i = Math.min(Math.abs(numerator), Math.abs(denominator));
    	
    	   if (i == 0)
    		   return;
    	   
    	   while ((numerator % i != 0) || (denominator % i != 0)) 
    		   i--;
    	   numerator   = numerator  / i; 
    	   denominator = denominator / i;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       Fraction sum = new Fraction(numerator * f.denominator + denominator * f.numerator,denominator * f.denominator); 
    	sum.shorten(); 
    	return sum; 
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction product = new Fraction(numerator * f.numerator, denominator * f.denominator);
        product.shorten();
        return product;  
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       if (numerator != 0) {
    	Fraction temp = new Fraction(denominator, numerator);
		return temp;
    }
    	else return this; 
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f.multiply(reciprocal());
    	 f.shorten();
    	 return f;
    }"
Name_282,VName_282,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if ((denominator < 0)){
			this.denominator = (denominator * (-1));
			this.numerator = (numerator * (-1));
		}
		else{ 
		this.denominator = denominator; 
		this.numerator = numerator;
		}
		if (denominator == 0){ 
		this.denominator = 1; 
		}
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() { 
	double den =  Double.valueOf(this.denominator);
	double num = Double.valueOf(this.numerator);
	double doub = num/den;
	return doub;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = +this.numerator+""/""+this.denominator;
		return str;
		
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		if (gcd == 0){
			this.numerator = this.numerator;
		this.denominator = this.denominator;
		}
		else{ 
		
		if (gcd < 0) {
			gcd = gcd * (-1); 
		}
		this.numerator = this.numerator / gcd;
		this.denominator = this.denominator/ gcd;
    }
	}

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
	   this.numerator = (this.numerator * (lcm/this.denominator)) + (f.numerator * (lcm/f.denominator)); 
	   this.denominator = lcm;
	 this.shorten();
	  int num = this.numerator;
	   int den = this.denominator;
	Fraction g = new Fraction(num, den);
	 return g; 
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator = this.numerator *  f.numerator; 
	   this.denominator = this.denominator * f.denominator;
	   this.shorten();
	   int num = this.numerator;
	   int den = this.denominator;
	Fraction g = new Fraction(num, den);
	 return g; 
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		 int num = this.numerator; 
		 int den = this.denominator;
		 if (this.numerator == 0){
		 }
		 else { 
			this.numerator = den; 
			this.denominator = num;
		 }
	 num = this.numerator;
	 den = this.denominator;
	Fraction g = new Fraction(num, den);
	 return g; 
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		f.reciprocal();
        this.numerator = this.numerator *  f.numerator; 
	   this.denominator = this.denominator * f.denominator;
	   this.shorten();
	   int num = this.numerator;
	   int den = this.denominator;
	Fraction g = new Fraction(num, den);
	 return g; 
    }","//Hier soll die Klasse UBahnDemo stehen!\
public class SubwayTest{
	public static void main (String[]args){
	Subway a =  new Subway(3); 
	Wagon x = new Wagon(5,10);
	Wagon y = new Wagon(3,4);
	a.addWagon(x); 
	a.addWagon(y);
	System.out.println(+a.getSeats()+ ""\n"" + a.getStandingRoom() + ""\n"" + a.getCapacity());
	Wagon z1 = new Wagon(4,6);
	Wagon z2 = new Wagon(1,1);
	a.addWagon(z1);
	a.addWagon(z2);
	System.out.println(a.countWagons());
	
		for (int i=0; i<5; i++){
		a.removeWagon();
		}
	 
	}
}"
Name_283,VName_283,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator=numerator;
		this.denominator=denominator;
        if(this.denominator==0){
			this.denominator=1;
		}
		if(this.denominator<0){
			this.denominator=this.denominator*(-1);
			this.numerator=this.numerator*(-1);
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double a = this.numerator;
		double b = this.denominator;
		return a/b;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch;
		bruch = numerator+""/""+denominator;
        return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int t;
		t=GCD(this.numerator,this.denominator);
		this.numerator=this.numerator/t;
		this.denominator=this.denominator/t;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int v;
	   int a;
	   int b;
       v=LCM(this.denominator,f.getDenominator());
	   a=v/this.denominator;
	   b=v/f.getDenominator();
	   this.numerator=a*this.numerator+b*f.getNumerator();
	   this.denominator=a*this.denominator;
	   Fraction c = new Fraction(this.numerator, this.denominator);
	   return c;
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator=this.numerator*f.getNumerator();
		this.denominator=this.denominator*f.getDenominator();
		Fraction b = new Fraction(this.numerator, this.denominator);
		return b;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       int n;
		int d;
		n=this.numerator;
		d=this.denominator;
       if(this.numerator==0){
		   Fraction b = new Fraction(this.numerator, this.denominator);
		   return b;
	   }
	   else{
		   this.numerator=d;
		   this.denominator=n;
		   Fraction b = new Fraction(this.numerator, this.denominator);
		   return b;
	   }
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       multiply(f.reciprocal());
	   Fraction b = new Fraction(this.numerator, this.denominator);
	   return b;
    }","class SubwayTest{
	public static void main (String[] args){
		Subway u1 = new Subway(3);
		u1.addWagon(new Wagon(25,30));
		u1.addWagon(new Wagon(55,45));
		System.out.println(
			u1.countWagons()+"" Wagons\n""+
			u1.getSeats()+"" Seats\n""+
			u1.getStandingRoom()+"" Standing Room\n""+
			u1.getCapacity()+"" Capacity""
		);
		u1.addWagon(new Wagon(20,35));
		u1.addWagon(new Wagon(12,33));
		for(int i=0; i<5;i++) u1.removeWagon();
		System.out.println(
			u1.countWagons()+"" Wagons\n""+
			u1.getSeats()+"" Seats\n""+
			u1.getStandingRoom()+"" Standing Room\n""+
			u1.getCapacity()+"" Capacity""
		);
	}
}"
Name_284,VName_284,"public class SubwayTest {


    public static void main(String[] args) {

        Subway sub1 = new Subway(3);

        sub1.addWagon(new Wagon(3, 4));
        sub1.addWagon(new Wagon(5,6));

        System.out.println(sub1.getSeats());
        System.out.println(sub1.getStandingRoom());
        System.out.println(sub1.getCapacity());

        sub1.addWagon(new Wagon(1,1));
        sub1.addWagon(new Wagon(2,2));

        sub1.removeWagon();
        sub1.removeWagon();
        sub1.removeWagon();
        sub1.removeWagon();
        sub1.removeWagon();


    }

}","public Fraction(int numerator, int denominator) {
        
        if(denominator<0){
          
        numerator=0-numerator;
        denominator=0-denominator;
            
        }
        else if(denominator==0){
            denominator=1;
        }
        this.numerator=numerator;
        this.denominator=denominator;
        this.shorten();
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    	
    	double n= this.numerator;
    	double d= this.denominator;
    	return (n/d);
    	
    	
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
       return new String(String.valueOf(this.numerator)+""/""+String.valueOf(this.denominator));
    	
    	
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator,this.denominator);
        if(gcd<0) {
        	gcd=0-gcd;
        }
        
        this.numerator=this.numerator/gcd;
        this.denominator=this.denominator/gcd;
    	
    	
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    	if(this.denominator==f.denominator) {
    		Fraction r=new Fraction(this.numerator+f.numerator,this.denominator);
    	    return r;
    	}
    
    	
    	else {
    		int lcm= LCM(this.denominator, f.denominator);
    		Fraction r=new Fraction(this.numerator*f.denominator+f.numerator*this.denominator,lcm);
    		
    		
    		return r;
    		
    	}
    
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    	Fraction r=new Fraction(this.numerator*f.numerator,this.denominator*f.denominator);
       	return r;
    	
    	
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    	if(this.numerator==0) {
    		return this;
    	}
    	Fraction r= new Fraction(this.denominator,this.numerator);
    	return r;
    	
    	
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    	Fraction r= this.multiply(f.reciprocal());
    	return r;
    	
    	
    }"
Name_285,VName_285,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","public class SubwayTest {
	
	public static void main (String[] args) {
		Subway u9 = new Subway(3);
		u9.addWagon(new Wagon(25,30));
		u9.addWagon(new Wagon(55,45));
		System.out.println(u9.getSeats());
		System.out.println(u9.getStandingRoom());
		System.out.println(u9.getCapacity());
		u9.addWagon(new Wagon(0,0));
		u9.addWagon(new Wagon(0,0));
		
		for (int i=0;i<5;i++) {
			u9.removeWagon();
		}
		
	}
	
}"
Name_286,VName_286,"public class SubwayTest{
	
	public static void main(String[] args){
		Subway U1 = new Subway(3);
		Wagon N1 = new Wagon(10, 20);
		Wagon N2 = new Wagon(15, 20);
		Wagon N3 = new Wagon(5, 10);
		Wagon N4 = new Wagon(30, 50);
		
		U1.addWagon(N1);
		U1.addWagon(N2);
		
		System.out.println(U1.getSeats());
		System.out.println(U1.getStandingRoom());
		System.out.println(U1.getCapacity());
		
		U1.addWagon(N3);
		U1.addWagon(N4);
		
		U1.removeWagon();
		U1.removeWagon();
		U1.removeWagon();
		U1.removeWagon();
		U1.removeWagon();
	}
	
	
	
	
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_287,VName_287,"/**
  * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
  * uebergeben bekommt und die entsprechenden Attribute setzt.
  * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
  * auftreten (nicht im ""denominator""-Attribut).
  * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
  * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
  * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt
  * und der Wert des Bruchs (die Argumente) unverändert bleibt
  * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
  * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
  * auf Eins gesetzt.
  * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
  */
public Fraction(int numerator, int denominator) {
   this.numerator = numerator;
   this.denominator = denominator;
   if(this.denominator == 0) this.denominator = 1;
   if(this.denominator<0){
     this.numerator=numerator*(-1);
     this.denominator= denominator*(-1);
   }
   shorten();
 }
 /**
  * Gibt den Nenner zurueck.
  */
 public int getDenominator() {
   return this.denominator;
 }
/**
  * Gibt den Zaehler zurueck.
  */
 public int getNumerator() {
   return this.numerator;
 }
/**
  * Gibt den Bruch als Gleitkommazahl zurueck.
  */
 public double toDouble() {
   double gleitK = (double)this.numerator/(double)this.denominator;
   return gleitK;
 }
/**
  * Gibt einen String im Format
  * ""Zaehler/Nenner"" zurueck.
  */
 public String toString() {
   String str = this.numerator+""/""+this.denominator;
   return str;
 }
/**
  * Kuerzt (vereinfacht) den Bruch.
  */
 public void shorten() {
   int klGeNe = GCD(this.numerator, this.denominator);
   this.numerator = this.numerator/klGeNe;
   this.denominator = this.denominator/klGeNe;
 }
/**
  * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
  */
 public Fraction add(Fraction f) {
   int geNe = this.denominator*f.denominator;
   int num = f.numerator*this.denominator + f.denominator*this.numerator;
   int den = geNe;
   Fraction add = new Fraction(num, den);
   add.shorten();
   return add;
 }
/**
  * Multipliziert mit dem uebergebenen Bruch.
  */
 public Fraction multiply(Fraction f) {
   int num = this.numerator*f.numerator;
   int den = this.denominator*f.denominator;
   Fraction mult = new Fraction(num, den);
   mult.shorten();
   return mult;
 }
/**
  * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
  * Sonst wird der Bruch unveraendert zurueckgegeben.
  */
  public Fraction reciprocal() {
    Fraction reciproc = new Fraction(0,0);
    if(this.numerator!=0){
      int tmp = this.numerator;
      reciproc.numerator = this.denominator;
      reciproc.denominator = tmp;
      return reciproc;
    }else{
    reciproc.numerator = this.denominator;
    reciproc.denominator = this.numerator;
    return reciproc;
   }
  }
 /**
  * Dividiert durch den uebergebenen Bruch
  * (unter Verwendung von Kehrwert und Multiplikation).
  */
 public Fraction divide(Fraction f) {
   int num = this.numerator*f.denominator;
   int den = this.denominator*f.numerator;
   Fraction teile = new Fraction(num, den);
   teile.shorten();
   return teile;
 }","public class SubwayTest{

  public static void main(String[] args) {

    Subway u9 = new Subway(3);
    u9.addWagon(new Wagon(25,30));
    u9.addWagon(new Wagon(55,45));
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");
u9.addWagon(new Wagon(20,35));
    u9.addWagon(new Wagon(12,33));
    for(int i=0;i<5;i++) u9.removeWagon();
    System.out.println(
    u9.countWagons()+"" Wagons\n""+
    u9.getSeats()+"" Seats\n""+
    u9.getStandingRoom()+"" Standing Room\n""+
    u9.getCapacity()+"" Capacity"");
}
}"
Name_288,VName_288,"public Fraction(int numerator, int denominator) {
        if(denominator == 0){
			this.denominator = 1;
			this.numerator = numerator;
		}
		else if(denominator < 0){
			this.denominator = denominator * (-1);
			this.numerator = numerator*(-1);
		}
		else {
		this.numerator = numerator;
		this.denominator = denominator;
		shorten();
		}
    }


    public int getDenominator() {
        return denominator;
    }


    public int getNumerator() {
		return numerator;
    }


    public double toDouble() {
        return ((double)numerator / (double)denominator);
    }


    public String toString() {
		String str = numerator + ""/"" + denominator;
		return str;
    } 


    public void shorten() {
		int temp = 0;
		while (GCD(numerator, denominator) != 1){
			temp = GCD(numerator, denominator);
			numerator /= temp;
			denominator /= temp;
		}
    }


    public Fraction add(Fraction f) {
		int exp = LCM(f.denominator, denominator);
		numerator *= (exp/denominator);
		f.numerator *= (exp/f.denominator);
		numerator += f.numerator;
		denominator = exp;
		Fraction res = new Fraction (numerator, denominator);
		return res;
    }


    public Fraction multiply(Fraction f) {
      numerator *= f.numerator;
	  denominator *= f.denominator;
	   Fraction res = new Fraction (numerator, denominator);
		return res;
    }


    public Fraction reciprocal() {
		int temp = 0;
       if(numerator != 0)
		temp = numerator;
		numerator = denominator;
		denominator = temp;
		Fraction res = new Fraction (numerator, denominator);
		return res;
    }
    

    public Fraction divide(Fraction f) {
		Fraction temp = f.reciprocal();
		Fraction res = multiply(temp);
		return res;
    }","public class SubwayTest {
	
	public static void main (String[] args) {
		Subway newyork = new Subway (3);
		newyork.addWagon(new Wagon(12, 36));
		newyork.addWagon(new Wagon(112, 333));
				
		System.out.println(newyork.getSeats()+ "" Seats\n""
							+ newyork.getStandingRoom()+ "" Standing Room\n""
							+newyork.getCapacity()+ "" Capacity"");
							
		newyork.addWagon(new Wagon(4, 5));
		newyork.addWagon(new Wagon(20, 32));
		
		for(int i=0; i<5; i++) {
			newyork.removeWagon();
		}
	}
}"
Name_71,VName_71,-,-
Name_289,VName_289,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_62,VName_62,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten (nicht im ""denominator""-Attribut).
     * Die Uebergabe eines negativen Nenners (""denominator""-Argument) an den Konstruktor ist jedoch zulaessig.
     * Der Konstruktor muss also den uebergebenen Nenner pruefen und sein Vorzeichen so behandeln,
     * dass der resultierende Bruch (die Attribute) die genannte Restriktion erfüllt 
     * und der Wert des Bruchs (die Argumente) unverändert bleibt 
     * (ein negatives Vorzeichen im Nenner muss also methematisch korrekt beseitigt werden).
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert mit dem uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     * Sonst wird der Bruch unveraendert zurueckgegeben.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert durch den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_290,VName_290,-,-
Name_46,VName_46,-,-
