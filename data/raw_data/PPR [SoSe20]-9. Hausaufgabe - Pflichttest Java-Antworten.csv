Nachname,Vorname,Antwort 8,Antwort 9
Name_359,VName_359,"//Hier soll die Klasse UBahnDemo stehen!class UBahnDemo {
class UBahnDemo{
  public static void main (String [] args){
  
    UBahn u1 = new UBahn();
    u1.addWagen(new Wagen(2,3));
    u1.addWagen(new Wagen(4,5));
    System.out.println(u1.getSitzPlaetze());
    System.out.println(u1.getStehPlaetze());
    System.out.println(u1.getAllePlaetze());
    
    u1.addWagen(new Wagen(3,3));
    u1.addWagen(new Wagen(1,5));
    
    u1.removeWagen();
    u1.removeWagen();
    u1.removeWagen();
    u1.removeWagen();
    u1.removeWagen();
    
    }
  }","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

       if (denominator<0) {
          this.numerator = -numerator;
          this.denominator = -denominator;  
       } // end of if 
       else if (denominator == 0) {
            this.denominator = 1;
            this.numerator = numerator;
        }
       else if (denominator>0){
        this.numerator = numerator;
        this.denominator = denominator;   
       } // end of if-else 
       this.shorten();
    }

    public int getDenominator() {
           return denominator;    
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
           return numerator;    
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
       return (double) numerator / (double) denominator; 
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
   public String toString() {
           return  numerator+""/""+denominator;  
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
           int gcd = GCD(numerator,denominator);
           denominator = denominator/gcd ;
           numerator = numerator/gcd ;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lmc = LCM(f.denominator, denominator);
        Fraction th = new Fraction(numerator,denominator);
        Fraction fnew = new Fraction(f.numerator,f.denominator);
        
        fnew.numerator *= lmc/f.denominator;
        th.numerator *= lmc/denominator;
        fnew.denominator = lmc;
        th.denominator = lmc;
        //System.out.println(f.toString());
        //System.out.println(this.toString());
        th.numerator += fnew.numerator;
        return new Fraction(th.numerator,th.denominator);
    }

    /**
     * Multipliziert den uebergebenen Bruch.                  
     */
    public Fraction multiply(Fraction f) {
       Fraction th = new Fraction(numerator,denominator);
       th.denominator *= f.denominator;
       th.numerator *= f.numerator;
       
       return new Fraction(th.numerator,th.denominator);         
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if (numerator != 0) {
         Fraction th = new Fraction(numerator,denominator);
         th.numerator = denominator;
         th.denominator = numerator;
         return new Fraction(th.numerator,th.denominator);
       } // end of if
    return this;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
           Fraction th = new Fraction(numerator,denominator);
           return th.multiply(f.reciprocal());
    }"
Name_360,VName_360,"public class UBahnDemo {

    public static void main(String [] args){
        UBahn peter = new UBahn();
        peter.addWagen(new Wagen(10,20));
        peter.addWagen(new Wagen(15,25));
        peter.getSitzPlaetze();
        peter.getStehPlaetze();
        peter.getAllePlaetze();
        peter.addWagen(new Wagen(12,22));
        peter.addWagen(new Wagen(10,15));
        peter.removeWagen();
        peter.removeWagen();
        peter.removeWagen();
        peter.removeWagen();
        peter.removeWagen();
    }
    
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_361,VName_361,"public class UBahnDemo{
	public static void main(String[] args){
		UBahn gelb = new UBahn();
		Wagen w = new Wagen(5,6);
		Wagen z = new Wagen(7,8);
		gelb.addWagen(w);
		gelb.addWagen(z);
		gelb.getSitzPlaetze();
		gelb.getStehPlaetze();
		gelb.getAllePlaetze();
		Wagen a = new Wagen(3,2);
		Wagen b = new Wagen(1,4);
		gelb.addWagen(a);
		gelb.addWagen(b);
		gelb.removeWagen();
		gelb.removeWagen();
		gelb.removeWagen();
		gelb.removeWagen();
		gelb.removeWagen();
	}
	
	
	
	
	
	
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_362,VName_362,"public class Fraction {
	
	private int numerator, denominator;
	
    public static int GCD (int x, int y) {
		
		if (x < 0){
			x = x*-1;
		}
		
		if (y < 0){
			y = y * -1;
		}
		
		if (y==0) return x;
		
		return GCD(y, x%y);
	}
	
	public static int LCM(int x, int y) {
		
		return x * (y / GCD(x, y));
	}
	
	public Fraction(int numerator, int denominator) {
				
		if (numerator < 0 && denominator < 0) {
			numerator = numerator * -1;
			denominator = denominator * -1;
		}
		if (denominator < 0 ){
			numerator = numerator * -1;
			denominator = denominator * -1;
		}
		
		this.numerator = numerator;
		this.denominator = denominator;
		
		if(denominator == 0) {
			this.denominator = 1;
		}
		
		this.shorten();
    }

    public int getDenominator() {
        return this.denominator;
    }

    public int getNumerator() {
        return this.numerator;
    }

    public double toDouble() {
        double gleitKommaZahl = (double)this.numerator / (double)this.denominator;
		return gleitKommaZahl;
    }

    public String toString() {
        String fractionAsString = this.numerator + ""/"" + this.denominator;
		return fractionAsString;
    }

    public void shorten() {

        int gcd = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator / gcd;
		this.denominator = this.denominator / gcd;		
    }

	 public Fraction add(Fraction f) {
       Fraction f1 = new Fraction(this.numerator, this.denominator);
	   Fraction f2 = new Fraction(f.numerator, f.denominator);
	   
	   int lcm = LCM(f1.denominator, f2.denominator);
	   
	   int multNumF1 = lcm / f1.denominator;
	   int multNumF2 = lcm / f2.denominator;
	   
	   f1.numerator = f1.numerator * multNumF1;
	   
	   f2.numerator = f2.numerator * multNumF2;
	   
	   Fraction fAdd = new Fraction((f1.numerator + f2.numerator), lcm);
	   
	   return fAdd;	   
    }

    public Fraction multiply(Fraction f) {
		
		Fraction fMult = new Fraction(this.numerator, this.denominator);
		
		fMult.numerator = this.numerator * f.numerator;
		fMult.denominator = this.denominator * f.denominator;
		
		return fMult;
    }

    public Fraction reciprocal() {
			Fraction fRec = new Fraction(this.numerator, this.denominator);
		if (this.numerator != 0) {
		
		    fRec.numerator = this.denominator;
			fRec.denominator = this.numerator;
		   
	   }
		    return fRec;
    }
    
    public Fraction divide(Fraction f) {
		
		Fraction fDiv1 = new Fraction(this.numerator, this.denominator);
        Fraction fKehrwert = f.reciprocal();
		Fraction fDivResult = fDiv1.multiply(fKehrwert);
		return new Fraction(fDivResult.numerator, fDivResult.denominator);
    }
}",//Hier soll die Klasse UBahnDemo stehen!
Name_363,VName_363,"public class UBahnDemo {

    public static void main(String[] args){

        UBahn ubahnA = new UBahn();

        Wagen wagenA = new Wagen(22, 43);
        Wagen wagenB = new Wagen(9, 32);
        ubahnA.addWagen(wagenA);
        ubahnA.addWagen(wagenB);

        System.out.printf(""Sitzplätze: %d \t Stehplätze: %d \t Alle Plätze: %d %n"",
                ubahnA.getSitzPlaetze(), ubahnA.getStehPlaetze(), ubahnA.getAllePlaetze());
        
        Wagen wagenC = new Wagen (18, 04);
        Wagen wagenD = new Wagen (345, 34);
        ubahnA.addWagen(wagenC);
        ubahnA.addWagen(wagenD);
        
        for (int i = 0; i < 5; i++){
            ubahnA.removeWagen();
            
        }

    }

}","// int numerator,denominator; // <--- löschen!! -----------------------------------------

    /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt.
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if (denominator == 0){
            this.denominator = 1;
        }
        else if (denominator < 0){
            this.numerator = 0 - numerator;
            this.denominator = Math.abs(denominator);
        }
        else {
            this.denominator = denominator;
        }
        this.shorten();

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)(this.numerator)/(double)(this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str1 = """" + this.numerator;
        String str2 = """" + this.denominator;
        return str1 + ""/"" + str2;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int i = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/i;
        this.denominator = this.denominator/i;
        }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int i = LCM(this.denominator, f.denominator);
        int num = (this.numerator * (i/this.denominator)) + (f.numerator * (i/f.denominator));
        Fraction sum = new Fraction(num,i);
        return sum;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction mult = new Fraction(this.numerator * f.numerator,
                this.denominator * f.denominator);
        return mult;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        if (this.numerator != 0){
            Fraction reci = new Fraction(this.denominator, this.numerator);
            return reci;
        }
        else {
            return this;
        }
    }

    /**
     * Dividiert den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction a = f.reciprocal();
        Fraction b = this.multiply(a);
        return b;
    }


    //_--_____________----

 /*   public static int GCD(int x, int y) { // <--- löschen!! -----------------------------------------
        int gcd = 1;
        int x2 = Math.abs(x);
        for (int i = 1; i <= x2 && i <= y; i++) {
            if (x2 % i == 0 && y % i == 0) {
                gcd = i;
            }
        }
        return gcd;
    } // <--- löschen!! -----------------------------------------

    public static int LCM(int x, int y) { // <--- löschen!! -----------------------------------------
        if (x == 0 || y == 0) {
            return 0;
        }
        int absNumber1 = Math.abs(x);
        int absNumber2 = Math.abs(y);
        int absHigherNumber = Math.max(absNumber1, absNumber2);
        int absLowerNumber = Math.min(absNumber1, absNumber2);
        int lcm = absHigherNumber;
        while (lcm % absLowerNumber != 0) {
            lcm += absHigherNumber;
        }        return lcm;
    } // <--- löschen!! -----------------------------------------

*/"
Name_299,VName_299,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
   public Fraction(int numerator, int denominator) {
        if (denominator != 0) {
            this.numerator = numerator;
            this.denominator = denominator;
        } else {
            this.numerator = numerator;
            this.denominator = 1;
        }
        if (this.denominator < 0) {
            this.numerator *= -1;
            this.denominator *= -1;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double)numerator/(double)denominator);

    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (Integer.toString(this.numerator)+""/""+Integer.toString(this.denominator));

    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator,this.denominator);

        this.numerator/=gcd;
        this.denominator/=gcd;

        if(this.numerator<0&&this.denominator<0){
            this.numerator*=-1;
            this.denominator*=-1;
        }

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(this.denominator,f.denominator);
        int num = this.numerator*(lcm/this.denominator)+f.numerator*(lcm/f.denominator);
        Fraction fra  = new Fraction(num,lcm);
        fra.shorten();
        return fra;


    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction fra = new Fraction(this.numerator*f.numerator,this.denominator*f.denominator);
        return fra;

    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        if (this.numerator!=0){
            int num = this.denominator;
            int deno = this.numerator;
            Fraction fra = new Fraction(num,deno);
            return fra;
        }
        else return null;

    }

    /**
     * Dividiert den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction inverse = f.reciprocal();
        Fraction fra = this.multiply(inverse);
        return fra;

    }","public class UBahnDemo {
    public static void main(String[] args) {
        UBahn ub = new UBahn();
        Wagen wg1 = new Wagen(11,2);
        Wagen wg2 = new Wagen(14,14);
        Wagen wg3 = new Wagen(17,4);
        Wagen wg4 = new Wagen(4,14);
        ub.addWagen(wg1);
        ub.addWagen(wg2);
        System.out.println(ub.getSitzPlaetze());
        System.out.println(ub.getStehPlaetze());
        System.out.println(ub.getAllePlaetze());
        ub.addWagen(wg3);
        ub.addWagen(wg4);
        ub.removeWagen();
        ub.removeWagen();
        ub.removeWagen();
        ub.removeWagen();
        ub.removeWagen();

    }
}"
Name_296,VName_296,"public class UBahnDemo{
    public static void main(String[] args) {
    	UBahn u=new UBahn();
    	Wagen a=new Wagen(24, 32);
    	Wagen b=new Wagen(13, 25);
    	u.addWagen(a);
    	u.addWagen(b);
    	System.out.println(""Die Gesamtzahl der Sitzplatze ist: ""+u.getSitzPlaetze()+""\n""
                +""Die Gesamtzahl der Stehplatze ist: ""+u.getStehPlaetze()+""\n""
                +""Die Gesamtzahl der aller Platze ist: ""+u.getAllePlaetze()+""."");
    	Wagen c=new Wagen(4, 7);
    	Wagen d=new Wagen(7, 15);
    	u.addWagen(c);
    	u.addWagen(d);
    	for(int i=0;i<5;i++) {
    		u.removeWagen();
    	}
    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
     
    public Fraction(int numerator, int denominator) {
        if(denominator<0) {
    		this.numerator=-numerator;
    		this.denominator=-denominator;
    	}else if(denominator==0) {
    		this.numerator=numerator;
            this.denominator=1;
    	}else {
    		this.numerator=numerator;
            this.denominator=denominator;
    	}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double bruch=(double)this.numerator/this.denominator;
        return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        this.shorten();
        String s=this.numerator+""/""+this.denominator;
        return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int t=GCD(this.numerator, this.denominator);
        if(t<0) {
        	this.numerator/=-t;
            this.denominator/=-t;
        }else {
        	this.numerator/=t;
            this.denominator/=t;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int zaehler=this.numerator*f.denominator+this.denominator*f.numerator;
       int nenner=this.denominator*f.denominator;
       Fraction d=new Fraction(zaehler,nenner);
       d.shorten();
       return d;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int zaehler=this.numerator*f.numerator;
        int nenner=this.denominator*f.denominator;
        Fraction e=new Fraction(zaehler,nenner);
        e.shorten();
        return e;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       Fraction r=new Fraction(this.denominator, this.numerator);
       r.shorten();
       return r;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction r=new Fraction(f.numerator,f.denominator);
    	r=r.reciprocal();
        r=this.multiply(r);
        r.shorten();
        return r;
    }"
Name_364,VName_364,"public Fraction(int numerator, int denominator) {
    if (denominator>0) {
        this.numerator = numerator; 
        this.denominator = denominator;
    }
    else if (denominator ==0) {
        this.denominator = 1;
        this.numerator = numerator;
    }
    else if (denominator <0) {
        this.numerator = -numerator;
        this.denominator = -denominator;
    }
    this.shorten();
}

/*
public static int GCD (int x, int y) {
    if (y==0){
        return x;
    }
    return GCD(y, x%y);
}

public static int LCM (int x, int y) {
    return (x*y)/GCD(x,y);
}

/**
 * Gibt den Nenner zurueck.
 */
public int getDenominator() {
    return denominator;        
}

/**
 * Gibt den Zaehler zurueck.
 */
public int getNumerator() {
    return numerator;
}

/**
 * Gibt den Bruch als Gleitkommazahl zurueck.
 */
public double toDouble() {
    return (double) this.numerator/this.denominator;
}

/**
 * Gibt einen String im Format
 * ""Zaehler/Nenner"" zurueck.
 */
public String toString() {
    return (numerator+""/""+denominator);
}

/**
 * Kuerzt (vereinfacht) den Bruch.
 */
public void shorten() {
    int s = Math.abs(GCD (numerator, denominator));
    this.numerator /= s;
    this.denominator /= s;
}

/**
 * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
 */
public Fraction add (Fraction f) {
    int k = LCM (this.denominator, f.denominator);
    int k1 = k/this.denominator;
    int k2 = k/f.denominator;
    Fraction a = new Fraction(this.numerator*k1 + f.numerator*k2, k);
    return a;
}

/**
 * Multipliziert den uebergebenen Bruch.
 */
public Fraction multiply(Fraction f) {
    Fraction g = new Fraction(this.numerator*f.numerator, this.denominator*f.denominator);
    return g;
}

/**
 * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
 */
public Fraction reciprocal() {
    if (numerator==0) {
        System.out.println(""Fehler: kein Kehrwert möglich da Zähler 0!"");
    }
    return (new Fraction(this.denominator, this.numerator));
}

/**
 * Dividiert den uebergebenen Bruch 
 * (unter Verwendung von Kehrwert und Multiplikation).
 */
public Fraction divide(Fraction f) {
    Fraction f_1 = f.reciprocal();
    return (this.multiply(f_1));    
}","class UBahnDemo {

    public static void main (String[] args) {
        UBahn u1 = new UBahn ();
        u1.addWagen(new Wagen(2, 2));
        u1.addWagen(new Wagen(3, 1));

        System.out.println(u1.getSitzPlaetze());
        System.out.println(u1.getStehPlaetze());
        System.out.println(u1.getAllePlaetze());

        u1.addWagen(new Wagen(1, 1));
        u1.addWagen(new Wagen(5, 5));

        for (int i=0; i<5; i++) {
            u1.removeWagen();
        }
    }
}"
Name_365,VName_365,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator > 0){
            this.numerator = numerator;
            this.denominator = denominator;
        }
        if(denominator == 0){
            this.numerator = numerator;
            this.denominator = 1;
        }
        if(denominator < 0){
            this.numerator = (-1)*numerator;
            this.denominator = (-1)*denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","public class UBahnDemo{
	public static void main(String[] args){
		UBahn u1 = new UBahn();
		Wagen w1 = new Wagen(5,10);
		Wagen w2 = new Wagen(7,4);
		Wagen w3 = new Wagen(8,3);
		Wagen w4 = new Wagen(1,3);
		
		u1.addWagen(w1);
		u1.addWagen(w2);
		System.out.println(""Sitzplätze: ""+u1.getSitzPlaetze()+"" Stehplätze: ""+u1.getStehPlaetze()+"" Gesamtplätze: ""+u1.getAllePlaetze());
		u1.addWagen(w3);
		u1.addWagen(w4);
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
	}
}"
Name_366,VName_366,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(denominator == 0){
            denominator=1;
        }

        if(denominator<0){
            numerator = -numerator;
            denominator = -denominator;
        }

        this.numerator = numerator;
        this.denominator = denominator;

        shorten();

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double x = this.numerator;
        x = x/this.denominator;
        return x;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator+""/""+ this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        double ggT = GCD(this.numerator,this.denominator);
        this.numerator = (int) (this.numerator/ggT);
        this.denominator = (int) (this.denominator/ggT);
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int kgV = LCM(this.denominator,f.denominator);

        int k1 = kgV/this.denominator;
        int k2 = kgV/f.denominator;

        int nenner = this.numerator*k1 + f.numerator*k2;

        Fraction frac = new Fraction(nenner, kgV);
        return frac;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int nenner= this.numerator*f.numerator;
        int zaehler= this.denominator*f.denominator;
        Fraction frac = new Fraction(nenner, zaehler);
        return frac;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        if(this.numerator != 0){
            int nenner = this.denominator;
            int zaehler = this.numerator;
            Fraction frac = new Fraction(nenner, zaehler);
            return frac;
        }
        else{
            int nenner = this.numerator;
            int zaehler = this.denominator;
            Fraction frac = new Fraction(nenner, zaehler);
            return frac;
        }
    }

    /**
     * Dividiert den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return reciprocal().multiply(f);
    }","public class UBahnDemo {

    public static void main(String[] args) {
        UBahn ub = new UBahn();
        Wagen w1 = new Wagen(20, 33);
        Wagen w2 = new Wagen(60, 1);
        Wagen w3 = new Wagen(0, 5);
        Wagen w4 = new Wagen(99, 2);
        ub.addWagen(w1);
        ub.addWagen(w2);
        System.out.println(ub.getSitzPlaetze());
        System.out.println(ub.getStehPlaetze());
        System.out.println(ub.getAllePlaetze());
        ub.addWagen(w3);
        ub.addWagen(w4);
        for(int i = 0; i<5; i++){
            ub.removeWagen();
        }
    }
}"
Name_294,VName_294,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator < 0){
            this.numerator = numerator*(-1);
            this.denominator = denominator*(-1);
        }else if(denominator==0){
            this.numerator = numerator;
            this.denominator = 1;
        }else{
            this.denominator = denominator;
            this.numerator = numerator;
        }
        
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (Integer.toString(this.numerator)+""/""+Integer.toString(this.denominator));
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
        int gcd = GCD(this.numerator,this.denominator);
        this.numerator/=gcd;
        this.denominator/=gcd;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int dem = LCM(this.denominator, f.denominator);
        int num = this.numerator*(dem/this.denominator)+f.numerator*(dem/f.denominator);
        Fraction fn  = new Fraction(num,dem);
        fn.shorten();
        return fn;
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int num = this.numerator*f.numerator;
        int dem = this.denominator*f.denominator;
        Fraction fn = new Fraction(num,dem);
        fn.shorten();
        return fn;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if (this.numerator!=0){
           
           int num = this.denominator;
           int den = this.numerator;
           Fraction fra = new Fraction(num,den);
           return fra;
        }else return null;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        f.reciprocal();
        Fraction fn = this.multiply(f);
        return fn;
    }","public class UBahnDemo {
    public static void main(String[] args) {
        UBahn uBahn = new UBahn();
        Wagen w1 = new Wagen(20,30);
        Wagen w2 = new Wagen(10,40);
        uBahn.addWagen(w1);
        uBahn.addWagen(w2);
        System.out.println(uBahn.getSitzPlaetze());
        System.out.println(uBahn.getStehPlaetze());
        System.out.println(uBahn.getAllePlaetze());
        Wagen w3 = new Wagen(30,20);
        Wagen w4 = new Wagen(40,10);
        uBahn.addWagen(w3);
        uBahn.addWagen(w4);
        uBahn.removeWagen();
        uBahn.removeWagen();
        uBahn.removeWagen();
        uBahn.removeWagen();
        uBahn.removeWagen();
    }
}"
Name_367,VName_367,"public class UBahnDemo{

    public static void main(String[] args){
    
   	 UBahn ub = new UBahn();
   	 Wagen w1 = new Wagen(3, 5);
   	 Wagen w2 = new Wagen(10, 13);
   	 ub.addWagen(w1);
   	 ub.addWagen(w2);
   	 System.out.println(ub.getSitzPlaetze());
   	 System.out.println(ub.getStehPlaetze());
   	 System.out.println(ub.getAllePlaetze());
   	 
   	 Wagen w3 = new Wagen(5, 4);
   	 Wagen w4 = new Wagen(13, 13);
   	 ub.addWagen(w3);
   	 ub.addWagen(w4);
   	 ub.removeWagen();
   	 ub.removeWagen();
   	 ub.removeWagen();
   	 ub.removeWagen();
   	 ub.removeWagen();
    }


}","public Fraction(int numerator, int denominator) {
   	 if(denominator==0){
   		 this.numerator = numerator;
   		 this.denominator = 1;
   	 }   	 
   	 else if(denominator<0){
   		 this.numerator =  -(numerator);
   		 this.denominator = -(denominator);
   	 }
   	 else{
   		 this.numerator =  numerator;
   		 this.denominator = denominator;
   	 }
   	 
   	 this.shorten();  
	}

	/**
 	* Gibt den Nenner zurueck.
 	*/
	public int getDenominator() {
    	return this.denominator;
	}

	/**
 	* Gibt den Zaehler zurueck.
 	*/
	public int getNumerator() {
    	return this.numerator;
	}

	/**
 	* Gibt den Bruch als Gleitkommazahl zurueck.
 	*/
	public double toDouble() {
    	return (double)this.numerator/this.denominator;
	}

	/**
 	* Gibt einen String im Format
 	* ""Zaehler/Nenner"" zurueck.
 	*/
    
	public String toString() {
   	 String a = """";
   	 a = this.getNumerator() + ""/"" + this.getDenominator();
    	return a;
	}

	/**
 	* Kuerzt (vereinfacht) den Bruch.
 	*/
	public void shorten() {
   	 int k = GCD(this.numerator, this.denominator);
   	 if(this.numerator != 0){
  			 this.numerator /= k;
   		 this.denominator /= k;
   	 }
	}

	/**
 	* Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
 	*/
	public Fraction add(Fraction f) {
   	 Fraction bruch = new Fraction(0,0);
   	 int k = LCM(this.denominator, f.denominator);
   	 bruch.denominator = k;
   	 bruch.numerator = f.numerator * k/f.denominator + this.numerator * k/this.denominator;
   	 bruch.shorten();
    	return bruch;   
	}

	/**
 	* Multipliziert den uebergebenen Bruch.
 	*/
	public Fraction multiply(Fraction f) {
    	Fraction multi = new Fraction(0,1);
    	multi.denominator = f.denominator * this.denominator;
    	multi.numerator = f.numerator * this.numerator;
    	multi.shorten();
    	return multi;
	}

	/**
 	* Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
 	*/
	public Fraction reciprocal() {
   	 Fraction reci = new Fraction(0,1);
   	 if (this.numerator != 0){
   		 reci.numerator = this.denominator;
   		 reci.denominator = this.numerator;
   		 reci.shorten();
   		 return reci;
    	}
    	return null;
	}
    
	/**
 	* Dividiert den uebergebenen Bruch
 	* (unter Verwendung von Kehrwert und Multiplikation).
 	*/
	public Fraction divide(Fraction f) {
   	 Fraction divi = new Fraction(0,1);
   	 Fraction reciprocal = f.reciprocal();
   	 this.multiply(reciprocal).shorten();
   	 return this.multiply(reciprocal);
	}"
Name_368,VName_368,"public Fraction(int numerator, int denominator) {
    	if (denominator == 0) {
    		this.denominator = 1;
    		this.numerator = numerator;
    		return;
    	}
        if (denominator < 0) {
        	this.denominator = -1*denominator;
        	this.numerator = -1*numerator;
        	return;
        }
        else { this.denominator = denominator;
		       this.numerator = numerator;}
        shorten();	
        
        }
  
    public int getNumerator() {
		return numerator;
	}
    
	public void setNumerator(int numerator) {
		this.numerator = numerator;
	}
	
	public int getDenominator() {
		return denominator;
	}
	
	public void setDenominator(int denominator) {
		this.denominator = denominator;
	}
	
	public double toDouble() {
       return numerator/denominator;
    }

    public String toString() {
        return numerator+""/""+denominator;
    }

    public void shorten() {
       int gcd = GCD(numerator, denominator);
       denominator/=gcd;
       numerator/=gcd;
    	}

    public Fraction add(Fraction f) {   
    	int numer = (this.numerator * f.getDenominator())+
    					(f.getNumerator() * denominator);
    	int denr = denominator * f.getDenominator();
	return new Fraction(numer, denr);
    }

    public Fraction multiply(Fraction f) {
        int newNumerator = numerator * f.getNumerator();
        int newDenominator = denominator * f.getDenominator();
        Fraction result = new Fraction (newNumerator, newDenominator);
        return result;
    }

    public Fraction reciprocal() {
       if (numerator != 0) {
    	   int newNumerator = getDenominator();
    	   int newDenominator = getNumerator();
    	   Fraction result = new Fraction (newNumerator, newDenominator);
           return result;
       }
	return null;
    	        
    }

    public Fraction divide(Fraction f) {
        int newNumerator = numerator * f.getDenominator();
        int newDenominator = denominator * f.getNumerator();
        Fraction result = new Fraction (newNumerator, newDenominator);
        return result;
    }","public class UBahnDemo {

	public static void main(String[] args) {
		
		UBahn u1 = new UBahn();
				
		Wagen wagen1 = new Wagen(25,50);
		UBahn.addWagen(wagen1);
		
		Wagen wagen2 =new Wagen(30,60);
		UBahn.addWagen(wagen2);
	
		System.out.println(""Gesamt Zahl der Sitzplätze: ""+ UBahn.getSitzPlaetze());
		System.out.println(""Gesamt Zahl der Stehplätze: ""+ UBahn.getStehPlaetze());
		System.out.println(""Gesamt Zahl aller Plätz: ""+ UBahn.getAllePlaetze());
		
		Wagen wagen3 = new Wagen(40,80);
		UBahn.addWagen(wagen3);
		Wagen wagen4 = new Wagen(45,90);
		UBahn.addWagen(wagen4);
		
		for(int i = 0; i < 5; i++) {
			UBahn.removeWagen();
		}	
	}	
}"
Name_369,VName_369,"public class UBahnDemo{

	public static void main(String [] args){
	
	UBahn berlin = new UBahn();
	Wagen wagen1 = new Wagen(6,10);
	Wagen wagen2 = new Wagen(7,5);
	Wagen wagen3 = new Wagen(6,15);
	Wagen wagen4 = new Wagen(9,4);	

	berlin.addWagen(wagen1);		
	berlin.addWagen(wagen2);	
	
		
	System.out.println(berlin.getSitzPlaetze());
	System.out.println(berlin.getStehPlaetze());
	System.out.println(berlin.getAllePlaetze());


	berlin.addWagen(wagen3);		
	berlin.addWagen(wagen4);

	berlin.removeWagen();	
	berlin.removeWagen();	
	berlin.removeWagen();	
	berlin.removeWagen();	
	berlin.removeWagen();		
}
}","/**

     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner

     * uebergeben bekommt und die entsprechenden Attribute setzt. 

     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 

     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und

     * wird mathematisch korrekt behandelt. 

     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 

     * auf Eins gesetzt.

     * Jeder erzeugte Bruch wird gekuerzt 

     * (dazu soll die entsprechende Mehode s.u. verwendet werden).

     */

    public Fraction(int numerator, int denominator) {

         if(denominator<0){

            numerator = -numerator;

            denominator = -denominator;

        }

        if(denominator == 0){

            denominator = 1;

        }

this.numerator = numerator;

this.denominator = denominator;

    }



    /**

     * Gibt den Nenner zurueck.

     */

    public int getDenominator() {

        return denominator;

    }



    /**

     * Gibt den Zaehler zurueck.

     */

    public int getNumerator() {

        return numerator;

    }



    /**

     * Gibt den Bruch als Gleitkommazahl zurueck.

     */

    public double toDouble() {

        double fraction = numerator/denominator;

return fraction;

    }



    /**

     * Gibt einen String im Format

     * ""Zaehler/Nenner"" zurueck.

     */

    public String toString() {

        String fracttion = (numerator + ""/""  + denominator);

return fracttion;  

  }



    /**

     * Kuerzt (vereinfacht) den Bruch.

     */

    public void shorten() {

        int factor = GCD(numerator, denominator);

numerator = numerator/factor;

denominator = denominator/factor;

    }



    /**

     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.

     */

    public Fraction add(Fraction f) {

       numerator = numerator * f.denominator + f.numerator * denominator;

denominator = denominator * f.denominator;

return new Fraction(numerator,denominator);

    }



    /**

     * Multipliziert den uebergebenen Bruch.

     */

    public Fraction multiply(Fraction f) {

        numerator = numerator * f.numerator;

denominator = denominator * f.denominator;

return new Fraction(numerator,denominator);

    }



    /**

     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.

     */

    public Fraction reciprocal() {

       if(denominator<0){

            numerator = -numerator;

            denominator = -denominator;

        }

        if(denominator != 0){

            int newNumerator = numerator;

            int newDenominator = denominator;

            numerator = newDenominator;

            denominator = newNumerator;

            

        }

return new Fraction(numerator,denominator);

    }

    

    /**

     * Dividiert den uebergebenen Bruch 

     * (unter Verwendung von Kehrwert und Multiplikation).

     */

    public Fraction divide(Fraction f) {

       numerator = numerator * f.denominator;

        denominator = denominator * f.numerator;

return new Fraction(numerator,denominator);

    }"
Name_370,VName_370,"public class UBahnDemo {
    public static void main(String[] args){
UBahn u = new UBahn();
Wagen l = new Wagen (25, 49);
Wagen a = new Wagen (20,19);
u.addWagen(l);
u.addWagen(a);
System.out.println(u.getSitzPlaetze());
System.out.println(u.getStehPlaetze());
System.out.println(u.getAllePlaetze());
Wagen b = new Wagen (12,13);
Wagen c = new Wagen (12,40);
u.removeWagen();
u.removeWagen();
u.removeWagen();
u.removeWagen();
u.removeWagen();


    }

}","public class Fraction  {
    private int numerator, denominator;
    
    
   /**
  * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
  * uebergeben bekommt und die entsprechenden Attribute setzt. 
  * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
  * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
  * wird mathematisch korrekt behandelt. 
  * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
  * auf Eins gesetzt.
  * Jeder erzeugte Bruch wird gekuerzt 
  * (dazu soll die entsprechende Mehode s.u. verwendet werden).
  */
 public Fraction(int numerator, int denominator) {
   if (denominator == 0){
       denominator = 1;
       
   }  
   else{
   this.numerator=numerator;
   this.denominator=denominator;
   }
 }

 /**
  * Gibt den Nenner zurueck.
  */
 public int getDenominator() {
     return denominator;
     
 }

 /**
  * Gibt den Zaehler zurueck.
  */
 public int getNumerator() {
     return numerator;
     
 }

 /**
  * Gibt den Bruch als Gleitkommazahl zurueck.
  */
 public double toDouble() {
     float f = denominator/numerator;
     return f;
 }

 /**
  * Gibt einen String im Format
  * ""Zaehler/Nenner"" zurueck.
  */
 public String toString() {
     String s = denominator+""/""+numerator;
     return s;
 }

 public Fraction multiply(Fracti on f) {
    int x = denominator * f.getDenominator();
    int y = numerator * f.getNumerator();
    
    Fraction c = new Fraction(x,y);
    
    return c;
    
}
}"
Name_371,VName_371,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
            this.denominator = 1;
            this.numerator = numerator;
        }
        else if (denominator < 0){
            this.numerator = -1*numerator;
            this.denominator = -1*denominator;
        }
        else {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """" + numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int shortened = GCD(numerator, denominator);
        if (shortened < 0){
            shortened = -1*shortened;
        }
        numerator /= shortened;
        denominator /= shortened;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int commonDenominator = LCM(this.denominator, f.denominator);
        Fraction commonA = new Fraction(this.numerator, this.denominator);
        commonA.numerator = this.numerator*(commonDenominator/this.denominator);
        commonA.denominator = commonDenominator;
        Fraction commonB = new Fraction(f.getNumerator(), f.getDenominator());
        commonB.numerator = f.numerator*(commonDenominator/f.denominator);
        commonB.denominator = commonDenominator;
        Fraction sum = new Fraction(commonA.numerator + commonB.numerator, commonDenominator);
        return sum;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newNumerator = numerator * f.getNumerator();
        int newDenominator = denominator * f.getDenominator();
        Fraction result = new Fraction(newNumerator, newDenominator);
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       Fraction reciprocal = new Fraction (this.denominator, this.numerator);
        return reciprocal;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        int newNumerator = this.numerator * f.getDenominator();
        int newDenominator = this.denominator * f.getNumerator();
        Fraction result = new Fraction(newNumerator, newDenominator);
        return result;
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {

    public static void main(String[] args) {
        UBahn u = new UBahn();
        Wagen first = new Wagen(25, 20);
        u.addWagen(first);
        Wagen second = new Wagen(50, 80);
        u.addWagen(second);
        System.out.println (u.getSitzPlaetze());
        System.out.println(u.getStehPlaetze());
        System.out.println(u.getAllePlaetze());
        Wagen third = new Wagen(10, 15);
        u.addWagen(third);
        Wagen fourth = new Wagen(80, 7);
        u.addWagen(fourth);
        u.removeWagen();
        u.removeWagen();
        u.removeWagen();
        u.removeWagen();
        u.removeWagen();
    }
}"
Name_372,VName_372,"public class UBahnDemo{



	public static void main(String [] args){

	

	UBahn berlin = new UBahn();

	Wagen wagen1 = new Wagen(6,10);

	Wagen wagen2 = new Wagen(7,5);

	Wagen wagen3 = new Wagen(6,15);

	Wagen wagen4 = new Wagen(9,4);	



	berlin.addWagen(wagen1);		

	berlin.addWagen(wagen2);	

	

		

	System.out.println(berlin.getSitzPlaetze());

	System.out.println(berlin.getStehPlaetze());

	System.out.println(berlin.getAllePlaetze());





	berlin.addWagen(wagen3);		

	berlin.addWagen(wagen4);



	berlin.removeWagen();	

	berlin.removeWagen();	

	berlin.removeWagen();	

	berlin.removeWagen();	

	berlin.removeWagen();		

}

}","/**

     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner

     * uebergeben bekommt und die entsprechenden Attribute setzt. 

     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 

     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und

     * wird mathematisch korrekt behandelt. 

     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 

     * auf Eins gesetzt.

     * Jeder erzeugte Bruch wird gekuerzt 

     * (dazu soll die entsprechende Mehode s.u. verwendet werden).

     */

    public Fraction(int numerator, int denominator) {

         if(denominator<0){

            numerator = -numerator;

            denominator = -denominator;

        }

        if(denominator == 0){

            denominator = 1;

        }

	this.numerator = numerator;

	this.denominator = denominator;

    }



    /**

     * Gibt den Nenner zurueck.

     */

    public int getDenominator() {

        return denominator;

    }



    /**

     * Gibt den Zaehler zurueck.

     */

    public int getNumerator() {

        return numerator;

    }



    /**

     * Gibt den Bruch als Gleitkommazahl zurueck.

     */

    public double toDouble() {

        double fraction = numerator/denominator;

	return fraction;

    }



    /**

     * Gibt einen String im Format

     * ""Zaehler/Nenner"" zurueck.

     */

    public String toString() {

        String fracttion = (numerator + ""/""  + denominator);

	return fracttion;  

  }



    /**

     * Kuerzt (vereinfacht) den Bruch.

     */

    public void shorten() {

        int factor = GCD(numerator, denominator);

	numerator = numerator/factor;

	denominator = denominator/factor;

    }



    /**

     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.

     */

    public Fraction add(Fraction f) {

       numerator = numerator * f.denominator + f.numerator * denominator;

	denominator = denominator * f.denominator;

	return new Fraction(numerator,denominator);

    }



    /**

     * Multipliziert den uebergebenen Bruch.

     */

    public Fraction multiply(Fraction f) {

        numerator = numerator * f.numerator;

	denominator = denominator * f.denominator;

	return new Fraction(numerator,denominator);

    }



    /**

     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.

     */

    public Fraction reciprocal() {

       if(denominator<0){

            numerator = -numerator;

            denominator = -denominator;

        }

        if(denominator != 0){

            int newNumerator = numerator;

            int newDenominator = denominator;

            numerator = newDenominator;

            denominator = newNumerator;

            

        }

	return new Fraction(numerator,denominator);

    }

    

    /**

     * Dividiert den uebergebenen Bruch 

     * (unter Verwendung von Kehrwert und Multiplikation).

     */

    public Fraction divide(Fraction f) {

       numerator = numerator * f.denominator;

        denominator = denominator * f.numerator;

	return new Fraction(numerator,denominator);

    }"
Name_373,VName_373,"public class UBahnDemo {

	public static void main(String[] args) {

		UBahn ubahn = new UBahn();

		Wagen wagen1 = new Wagen(10, 50);
		Wagen wagen2 = new Wagen(20, 60);
		Wagen wagen3 = new Wagen(30,70);
		Wagen wagen4 = new Wagen(40,80);
	
		ubahn.addWagen(wagen1);
		ubahn.addWagen(wagen2);
	

		System.out.println(ubahn.getSitzPlaetze());
		System.out.println(ubahn.getStehPlaetze());
		System.out.println(ubahn.getAllePlaetze());
		
		ubahn.addWagen(wagen3);
		ubahn.addWagen(wagen4);

		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();

	}

}","/**
	 * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
	 * uebergeben bekommt und die entsprechenden Attribute setzt.
	 * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
	 * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
	 * wird mathematisch korrekt behandelt.
	 * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
	 * auf Eins gesetzt.
	 * Jeder erzeugte Bruch wird gekuerzt
	 * (dazu soll die entsprechende Mehode s.u. verwendet werden).
	 */
	public Fraction(int numerator, int denominator) {

		if(denominator == 0) {
			this.numerator = numerator;
			this.denominator = 1;
		}
		else if(denominator < 0) {
			this.numerator = -numerator;
			this.denominator = -denominator;
		}
		else {
			this.numerator = numerator;
			this.denominator = denominator;
		}

		shorten();

	}

	/**
	 * Gibt den Nenner zurueck.
	 */
	public int getDenominator() {
		return denominator;
	}

	/**
	 * Gibt den Zaehler zurueck.
	 */
	public int getNumerator() {
		return numerator;
	}

	/**
	 * Gibt den Bruch als Gleitkommazahl zurueck.
	 */
	public double toDouble() {
		return (double) numerator / (double) denominator;
	}

	/**
	 * Gibt einen String im Format
	 * ""Zaehler/Nenner"" zurueck.
	 */
	public String toString() {
		return String.valueOf(numerator) + ""/"" + String.valueOf(denominator);
	}

	/**
	 * Kuerzt (vereinfacht) den Bruch.
	 */
	public void shorten() {

		int gcd = GCD(this.numerator, this.denominator);                    // Größter gemeinsamer Teiler

		this.numerator = this.numerator / gcd;                              // Gekürzter Zähler
		this.denominator = this.denominator / gcd;                          // Gekürzter Nenner

	}

	/**
	 * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
	 */
	public Fraction add(Fraction f) {

		Fraction temp = new Fraction(this.numerator, this.denominator);     // Neues Objekt

		int commonDenominator = LCM(temp.denominator, f.denominator);       // Kleinstes gemeinsames Vielfaches

		int expansionNumberTemp = commonDenominator / temp.denominator;     // Erweiterungszahlen
		int expansionNumberF = commonDenominator / f.denominator;

		temp.numerator = expansionNumberTemp * temp.numerator;              // Erweiterte Zähler
		f.numerator = expansionNumberF * f.numerator;

		temp.denominator = expansionNumberTemp * temp.denominator;          // Erweiterte Nenner
		f.denominator = expansionNumberF * f.denominator;

		temp.numerator = temp.numerator + f.numerator;                      // Addition des Zählers

		return temp;
	}

	/**
	 * Multipliziert den uebergebenen Bruch.
	 */
	public Fraction multiply(Fraction f) {

		Fraction temp = new Fraction(this.numerator, this.denominator);     // Neues Objekt

		temp.numerator = temp.numerator * f.numerator;                      // Multiplikation der Zähler
		temp.denominator = temp.denominator * f.denominator;                // Multiplikation der Nenner

		return temp;

	}

	/**
	 * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
	 */
	public Fraction reciprocal() {

		Fraction temp = new Fraction(this.numerator, this.denominator);     // Neues Objekt

		if(this.numerator != 0) {                                           // Falls Zähler ungleich Null

			temp.numerator = this.denominator;                              // Austausch von Zähler und Nenner
			temp.denominator = this.numerator;

			return temp;

		}
		else {                                                              // Falls Zähler gleich Null

			return temp;

		}

	}

	/**
	 * Dividiert den uebergebenen Bruch
	 * (unter Verwendung von Kehrwert und Multiplikation).
	 */
	public Fraction divide(Fraction f) {

		Fraction temp = new Fraction(this.numerator, this.denominator);
		Fraction reciprocal = reciprocal();

		temp.numerator = temp.numerator * reciprocal.numerator;
		temp.denominator = temp.denominator * reciprocal.denominator;

		return temp;

	}"
Name_59,VName_59,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_374,VName_374,"public class UBahnDemo {
	public static void main (String [] args) {
		UBahn u1 = new UBahn ();
		Wagen nr1 = new Wagen (30,50);
		Wagen nr2 = new Wagen (20,60);
		Wagen nr3 = new Wagen (30, 80);
		Wagen nr4 = new Wagen (20,20);
		
		System.out.print (""Wagen Nr. 1: "");
		u1.addWagen (nr1);
		System.out.print (""Wagen Nr. 2: "");
		u1.addWagen (nr2);
		
		System.out.println (""Sitzplaetze: ""+u1.getSitzPlaetze ());
		System.out.println (""Stehplaetze: ""+u1.getStehPlaetze ());
		System.out.println (""Alle Plaetze: ""+u1.getAllePlaetze ()+""\n"");
		
		
		System.out.print (""Wagen Nr. 3: "");
		u1.addWagen (nr3);
		System.out.print (""Wagen Nr. 4: "");
		u1.addWagen (nr4);
		System.out.println();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();	
	}
	
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator > 0) {
			this.numerator = numerator;
			this.denominator = denominator;
        }
		if (denominator == 0) {
			this.numerator = numerator;
			this.denominator = 1;
		}
		if (denominator < 0) {
			this.numerator -= numerator;
			this.denominator -= denominator;
		}
		this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double d = (double) this.getNumerator()/ this.getDenominator();
		return d;        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = this.numerator+""/""+ this.denominator ;
		return str;        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int k = Fraction.GCD (this.numerator, this.denominator);
		this.numerator = this.numerator / k;
		this.denominator = this.denominator / k;        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int kgV = Fraction.LCM(this.denominator, f.denominator);
		int zaehler1erweitert = this.numerator * kgV / this.denominator;
		int zaehler2erweitert = f.numerator * kgV / f.denominator;
		Fraction neu = new Fraction (zaehler1erweitert+zaehler2erweitert, kgV);
		return neu;       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		Fraction neu = new Fraction (this.numerator* f.numerator, this.denominator * f.denominator);
		return neu;        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if (this.numerator != 0) {
			Fraction neu = new Fraction (this.denominator, this.numerator);
			return neu;
	   }
	   return null;       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction division = this.multiply(f.reciprocal ());
		return division;       
    }"
Name_251,VName_251,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","public class UBahnDemo{
	public static void main(String[] args){
		UBahn b = new UBahn();
		Wagen w1 = new Wagen(3,1);
		Wagen w2 = new Wagen(2,5);
		b.addWagen(w1);
		b.addWagen(w2);
		System.out.println(""Sitzplaetze gesamt: ""+b.getSitzPlaetze()+"" Stehplaetze gesamt: ""+b.getStehPlaetze()+"" Alle Plaetze gesamt :""+b.getAllePlaetze());
		Wagen w3 = new Wagen(1,1);
		Wagen w4 = new Wagen(2,1);
		b.addWagen(w3);
		b.addWagen(w4);
		for(int i = 0; i < 5; i++){
		b.removeWagen();
		}
	}
}"
Name_375,VName_375,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner as Null) duerfen nur im Zaehler
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
     

    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
    	this.denominator = denominator; 
        
        if((numerator < 0 && denominator < 0) || denominator < 0 ) {
            numerator *= -1;
            denominator *= -1;
        }
    	if(denominator == 0){
    		this.denominator = 1;
    	}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator; 
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double)numerator)/((double)denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int grt = GCD(numerator, denominator);
        numerator = numerator/grt;
        denominator = denominator/grt;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int num = this.numerator*f.denominator + this.denominator*f.numerator;
       int den = this.denominator*f.denominator;
       shorten();
       return new Fraction(num, den);
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int num = this.numerator*f.numerator;
  		int den = this.denominator*f.denominator;
  		shorten();
  		return new Fraction(num, den);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       Fraction temp = new Fraction(denominator, numerator);
       shorten();
		return temp;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction tmp = f.reciprocal();
       shorten();
  	return this.multiply(tmp);
    }","public class UBahnDemo {

	public static void main(String[] args) {
		
		UBahn u = new UBahn();
		
		u.addWagen(new Wagen(50, 20));
		u.addWagen(new Wagen(45, 10));
		
		
		System.out.println(u.getSitzPlaetze());
		System.out.println(u.getStehPlaetze());
		System.out.println(u.getAllePlaetze());
		
		
		u.addWagen(new Wagen(20, 5));
		u.addWagen(new Wagen(30, 20));
		
		
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
		
	}

}"
Name_7,VName_7,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		
        if (denominator == 0) { 
			denominator = 1; // !
			this.numerator = numerator;
		}
		if (denominator < 0) {
			this.numerator = numerator*(-1); // !
			this.denominator = denominator*(-1);
		}
		else {
		this.numerator = numerator;
		this.denominator = denominator;
		}
		// String a = toString();
		// System.out.println(a);
		
		shorten();
		
		// String b = toString();
		// System.out.println(b);
		
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
		return this.numerator;
		
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		
		double g = numerator/denominator;
		return g;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		
		String ts = numerator+""/""+denominator;
        return ts;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		
		int p = GCD(numerator, denominator);
		numerator /= p;
		denominator /= p;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		
		int lcm = LCM(f.denominator, denominator);
		int z1 = (lcm/f.denominator)*f.numerator;
		int z2 = (lcm/denominator)*numerator;
		int a = z1 + z2;
		Fraction g = new Fraction(a, lcm);
		return g;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
      
		int zn = numerator*f.numerator;
		int nn = denominator*f.denominator;
		Fraction h = new Fraction(zn, nn);
		return h;
	  
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		
		int a = numerator;
		int b = denominator;
		if (numerator != 0) {
			Fraction i = new Fraction(b, a);
			return i; }
		else { Fraction i = new Fraction(a, b);
		return i; }
	
	}
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
		Fraction y = new Fraction (f.numerator, f.denominator);
		y = y.reciprocal();
		int a2 = y.numerator; int b2 = y.denominator;
		Fraction x = new Fraction(numerator*a2, denominator*b2);
		return x;
	   
    }","//Hier soll die Klasse UBahnDemo stehen!

public class UBahnDemo {
    public static void main(String[] args) {

        UBahn uBahn = new UBahn();
        Wagen w1 = new Wagen( 1, 2);
        Wagen w2 = new Wagen( 5, 7);

        uBahn.addWagen(w1);
        uBahn.addWagen(w2);

        System.out.println(""Sitzplätze gesamt: ""+ uBahn.getSitzPlaetze() + "", Stehplätze gesamt: "" + uBahn.getStehPlaetze() +"", Plätze gesamt: "" + uBahn.getAllePlaetze());

        uBahn.addWagen(new Wagen( 3, 4));
        uBahn.addWagen(new Wagen( 6, 8));

        for (int i = 0; i < 5; i++){
            uBahn.removeWagen();
        }
    }
}"
Name_376,VName_376,"public class Fraction {
	
	private int numerator, denominator;
	
	public static int GCD(int x, int y) {
		if(y == 0) {
			return x;
		}
		return GCD(y, x % y);
	}
	
	public static int LCM(int x, int y) {
		
		return (x * y) / GCD(x, y);
	} 
	
	
	public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
		
		if(denominator < 0 ) {
		    this.numerator = -numerator;
			this.denominator = -denominator;
		}
		if(denominator == 0) {
			this.denominator = 1;
		}
	}
	
	public int getDenominator() {
		return this.denominator;
	}
	
	public int getNumerator() {
		return this.numerator;
		
	}
	
	public double toDouble() {
		double fraction = (double)this.numerator / this.denominator;
		return fraction;
		
		
	}
	
	public String toString() {
		return this.numerator + ""/"" + this.denominator;
	}
	
	public void shorten() {
		int m = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator/m;
		this.denominator = this.denominator / m;
		
	}
	public Fraction add(Fraction f) {
		int x = this.numerator * f.denominator + f.numerator * this.denominator;
		int y = this.denominator * f.denominator;
		
		Fraction b = new Fraction(x, y);
		b.shorten();
		return b;
	}
	
	public Fraction multiply(Fraction f) {
		int d = this.numerator * f.numerator;
		int e = this.denominator * f.denominator;
		
		Fraction h = new Fraction(d, e);
		
		h.shorten();
		
		return h;
	}
	
	public Fraction reciprocal() {
		if(denominator != 0) {
			Fraction g = new Fraction(this.denominator, this.numerator);
			g.shorten();
			return g;
			
		}else {
			return this;
		}
	}
	
	
	public Fraction divide(Fraction f) {
		Fraction rec = f.reciprocal();
		Fraction res = this.multiply(rec);
		res.shorten();
		return res;
	}
}","public class UBahnDemo {
	
	public static void main(String[] args) {
		
		UBahn u1 = new UBahn();
		Wagen w1 = new Wagen(50, 20);
		Wagen w2 = new Wagen(45, 15);
		
		u1.addWagen(w1);
		u1.addWagen(w2);
		
		System.out.println(""Gesamtzahl der Sitzplaetze: "" + u1.getSitzPlaetze() + ""\n"" + ""Gesamt zahl der Stehplaetze: "" + u1.getStehPlaetze() + ""\n"" + ""Gesamtzahl aller Plaetze: ""+ u1.getAllePlaetze());
		
		u1.addWagen(new Wagen(39,22));
		u1.addWagen(new Wagen(35,47));
		
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		
	}

}"
Name_377,VName_377,"public Fraction(int numerator, int denominator) {
        if(denominator == 0) {
        	this.denominator = 1;
        	this.numerator = numerator;
        }
        if(denominator < 0) {
        	this.numerator = numerator * -1;
        	this.denominator = denominator * -1;
        }
        if(denominator > 0) {
		this.numerator = numerator;
		this.denominator = denominator;        
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.getNumerator() / this.getDenominator();
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.getNumerator() + ""/"" + this.getDenominator();
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int GCD = GCD(this.getNumerator(),this.getDenominator());
        int z = this.getNumerator() / GCD;
        int n = this.getDenominator() / GCD;
        this.numerator = z;
        this.denominator = n;
       
        
        //this.numerator = this.getNumerator() / GCD(this.getNumerator(),this.getDenominator());
        //this.denominator = this.getDenominator() / GCD(this.getNumerator(),this.getDenominator());  
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    	int zn1 = f.getNumerator() * this.getDenominator();
    	int zn2 = this.getNumerator() * f.getDenominator();
    	int nn = this.getDenominator() * f.getDenominator();
    	int zn = zn1 + zn2;
    	Fraction g = new Fraction(zn, nn);
    
	//Fraction fn = new Fraction(f.getNumerator() * a, f.getDenominator() * a);
	//Fraction thisn = new Fraction(this.getNumerator() * a, this.getDenominator() * a);
	//Fraction g = new Fraction(fn.getNumerator() + thisn.getNumerator(), fn.getDenominator() + thisn.getDenominator());
	g.shorten();
	return g; 
	
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
	int a = this.getNumerator() * f.getNumerator();
	
	int b = this.getDenominator() * f.getDenominator();
	
	Fraction g = new Fraction(a, b);
	
	//Fraction g = new Fraction(this.getNumerator() * f.getNumerator(), this.getDenominator() * f.getDenominator());
	g.shorten();
	return g;        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
	if(this.getNumerator() == 0) {
		return this;
	}
	else {
	Fraction g = new Fraction(this.getDenominator(), this.getNumerator());
	g.shorten();
	return g;
	}	        
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
	
	Fraction g = this.multiply(f.reciprocal());
	g.shorten();
	return g;
		       
    }","public class UBahnDemo {
	
	public static void main(String[] args) {
		UBahn U = new UBahn();		
		Wagen A = new Wagen(10, 20);
		Wagen B = new Wagen(1, 2);
		Wagen C = new Wagen(3, 7);
		Wagen D = new Wagen(6, 2);
		
		U.addWagen(A);
		U.addWagen(B);
		System.out.println(U.getSitzPlaetze());
		System.out.println(U.getStehPlaetze());
		System.out.println(U.getAllePlaetze());
		
		U.addWagen(C);
		U.addWagen(D);
		
		U.removeWagen();
		U.removeWagen();
		U.removeWagen();
		U.removeWagen();
		U.removeWagen();
		
	}
}"
Name_378,VName_378,"public class UBahnDemo {
    public static void main(String[] args){ 
    UBahn U = new UBahn();
    Wagen one = new Wagen(15, 20);
    Wagen two = new Wagen(25, 30);
    U.addWagen(one);
    U.addWagen(two);
    System.out.println(""Anzahlsitzplaetze: "" + U.getSitzPlaetze());
    System.out.println(""Anzahlstehplaetze: "" + U.getStehPlaetze());
    System.out.println(""Anzahlalleplaetze: "" + U.getAllePlaetze());
    Wagen three = new Wagen(9, 16);
    Wagen four = new Wagen(9, 16);
    U.addWagen(three);
    U.addWagen(four);
    U.removeWagen();
    U.removeWagen();
    U.removeWagen();
    U.removeWagen();
    U.removeWagen();
    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        }
        if (denominator < 0){
            this.denominator = -denominator;
            this.numerator = numerator;
        }
        if (denominator > 0){
            this.denominator = denominator;
            this.numerator = numerator;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double bruch = (double)this.numerator/this.denominator;
        return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s = this.numerator +""/""+ this.denominator;
        return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(this.numerator, this.denominator);
        this.numerator/=teiler;
        this.denominator/=teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int z = f.denominator*this.numerator + f.numerator*this.denominator;
        int n = f.denominator*this.denominator;
        Fraction a = new Fraction(z,n);
        a.shorten();
        return a;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int z = this.numerator*f.numerator;
        int n = this.denominator*f.denominator;
        Fraction m = new Fraction(z,n);
        m.shorten();
        return m;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        Fraction r = new Fraction(this.denominator,this.numerator);
        r.shorten();
        if(this.numerator != 0) return r;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction b= new Fraction(f.numerator, f.denominator);
        b= b.reciprocal();
        b = this.multiply(b);
        b.shorten();
        return b;
    }"
Name_379,VName_379,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator==0) {
            denominator++;
        }
        if(denominator<0){
            numerator = numerator*(-1);
            denominator = denominator*(-1);
        }
        this.numerator=numerator;
        this.denominator=denominator;
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;

    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
       return numerator;

    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double a = numerator;
        double b = denominator;
        return a/b;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """"+numerator+""/""+denominator+"""";
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(numerator,denominator);
        if (gcd<0){
            gcd= gcd*(-1);
        }
        numerator = numerator/gcd;
        denominator = denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       return new Fraction (numerator*f.denominator+denominator*f.numerator,denominator*f.denominator);
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.numerator,denominator*f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if (numerator != 0) {
            return new Fraction(denominator, numerator);
        }
        return new Fraction(0, denominator);
    
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction s;
        s = multiply(f.reciprocal());
        return s;
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {
    public static void main(String[] args){
        UBahn u = new UBahn();
        Wagen w1 = new Wagen(12,4);
        Wagen w2 = new Wagen (3,77);
        u.addWagen(w1);
        u.addWagen(w2);
        System.out.println(u.getSitzPlaetze()+"""");
        System.out.println(u.getStehPlaetze()+"""");
        System.out.println(u.getAllePlaetze()+"""");
        Wagen w3 = new Wagen (4,5);
        Wagen w4 = new Wagen (2,5);
        u.addWagen(w3);
        u.addWagen(w4);
        for(int i= 0;i<5;i++) {
            u.removeWagen();
        }



    }

}"
Name_380,VName_380,"class UBahnDemo{

	// alle Attribute müssen privat sein

	public static void main(String[] args) {
		// U-Bahn erzeugen
		UBahn U1 = new UBahn();

		// 2 Wagen anhängen
		Wagen W1 = new Wagen(30, 40);
		Wagen W2 = new Wagen(60, 80);
		U1.addWagen(W1);
		U1.addWagen(W2);


		// Plätze ausgeben
		System.out.println(""Sitzplaetze: "" + U1.getSitzPlaetze());
		System.out.println(""Stehplaetze: "" + U1.getStehPlaetze());
		System.out.println(""alle Plaetze: "" + U1.getAllePlaetze());


		// 2 Wagen anhängen
		Wagen W3 = new Wagen(40, 60);
		Wagen W4 = new Wagen(20, 80);
		U1.addWagen(W3);
		U1.addWagen(W4);

		// 5 Wagen entfernen
		U1.removeWagen();
		U1.removeWagen();
		U1.removeWagen();
		U1.removeWagen();
		U1.removeWagen();
	}
}
//Hier soll die Klasse UBahnDemo stehen!","public Fraction(int numerator, int denominator) {
       if (denominator == 0){
            denominator = 1;
       }else if (denominator <= -1){
            numerator = numerator * -1;
            denominator = denominator * -1;
       }
       this.denominator = denominator;
       this.numerator = numerator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getNumerator() {
        //die Uebergabe eines negativen Nenners ist zulaessig und wird mathematisch korrekt behandelt.
        return numerator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double gleitkommazahl =  Double.valueOf(numerator) / Double.valueOf(denominator);
        return gleitkommazahl;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String string = (numerator + ""/"" + denominator);
        return string;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(numerator, denominator);
        numerator = numerator / teiler;
        denominator = denominator / teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.

    Fraction x = new Fraction(1,2);
    Fraction y = new Fraction(1,3);
    Fraction z = x.add(y);

     */
    public Fraction add(Fraction f) {
       int newdenominator = LCM(denominator, f.denominator);
       int dedenominator1 = (newdenominator / denominator) * numerator;
       int dedenominator2 = (newdenominator / f.denominator) * f.numerator;
       int newnumerator = dedenominator1 + dedenominator2;
       Fraction n = new Fraction(newdenominator, newnumerator);
       n.shorten();
       return n;
    }

    /**
     * Multipliziert den uebergebenen Bruch.

     */
    public Fraction multiply(Fraction f) {
        int newdenominator = denominator * f.denominator;
        int newnumerator = numerator * f.numerator;
        Fraction n = new Fraction(newdenominator, newnumerator);
        n.shorten();
        return n;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        if (denominator != 0){
            int newnumerator = denominator;  // Zwischenspeicher? Typ?
            int newdenominator = numerator;
            Fraction n = new Fraction(newdenominator, newnumerator);
            n.shorten();
            return n;
        }
        return null;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction kerwert = reciprocal();
        Fraction division = kerwert.multiply(f);
        return division;
    }"
Name_381,VName_381,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = Math.abs(numerator);
        this.denominator = Math.abs(denominator);
        if( denominator == 0) {
            this.denominator = 1;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return this.numerator * this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator +""/""+ this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        Fraction Bruchadd = new Fraction( numerator, denominator);
        int d = LCM(this.denominator, f.denominator);
        int c = GCD(this.denominator, f.denominator);
        int n = c * this.numerator + c * f.numerator;
        Bruchadd.numerator = n;
        Bruchadd.denominator = d;
        return Bruchadd;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
          Fraction Bruchmulti = new Fraction( numerator, denominator);
          int n = this.numerator * f.numerator;
          int d = this.denominator * f.denominator;
          Bruchmulti.numerator = n;
          Bruchmulti.denominator = d;
          return Bruchmulti;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       Fraction Bruchreci = new Fraction( numerator, denominator);
       if(this.numerator != 0) {
           this.numerator = Bruchreci.denominator;
           this.denominator = Bruchreci.numerator;
       }
       return Bruchreci;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction Bruchdiv = new Fraction( numerator, denominator);
       Bruchdiv = f.reciprocal();
       return this.multiply(Bruchdiv);
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {
	
	public static void main(String[] args) {
		UBahn ub = new UBahn();
		Wagen[] wg = new Wagen[5];
		wg[0] = new Wagen(25,35);
		wg[1] = new Wagen(15,28);
		wg[2] = new Wagen(25,35);
		wg[3] = new Wagen(35,21);
		wg[4] = new Wagen(15,23);
		ub.addWagen(wg[0]);
		ub.addWagen(wg[1]);
		ub.getSitzPlaetze();
		System.out.println(ub.getSitzPlaetze());
		ub.getStehPlaetze();
		System.out.println(ub.getStehPlaetze());
		ub.getAllePlaetze();
		System.out.println(ub.getAllePlaetze());
		ub.addWagen(wg[2]);
		ub.addWagen(wg[3]);
		ub.removeWagen();
		ub.removeWagen();
		ub.removeWagen();
		ub.removeWagen();
		ub.removeWagen();
	}
	
}"
Name_382,VName_382,"public class UBahnDemo {
	
	public static void main(String[] args) {
		
		UBahn u = new UBahn();
		Wagen w = new Wagen(2,5);
		Wagen w1 = new Wagen(1,7);
		
		
		
		u.addWagen(w);
		u.addWagen(w1);
		
		System.out.println(""Sitzplaetze: ""+u.getSitzPlaetze());
		System.out.println(""Stehplaetze: ""+u.getStehPlaetze());
		System.out.println(""Gesamt: ""+u.getAllePlaetze());
		
		Wagen w2 = new Wagen(3,8);
		Wagen w3 = new Wagen(9,10);
		
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
		u.removeWagen();
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		
		if (denominator == 0)
			denominator = 1;
			
		if ((denominator < 0) && (numerator < 0)){
			denominator = denominator - denominator - denominator;
			numerator = numerator - numerator - numerator;
			}
		
		if (denominator < 0)
			denominator = denominator - denominator - denominator;
		
		
		
		this.numerator = numerator;
		this.denominator = denominator;
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return this.numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double z = 0;
		z = (double) this.numerator / this.denominator;
		return z;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s;
		s = this.numerator+""/""+this.denominator;
		return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
			//Berechnung des ggT
			int z=this.numerator;
			int n=this.denominator;
			int r=this.numerator%this.denominator;
			 
			while(r>0){
			z=n;
			n=r;
			r=z%n;
			}
			 
			//Kürzen des Bruches
			this.numerator /= n;
			this.denominator /= n;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int z = 0;
	   int n = 0;
	   
	   z = this.numerator * f.denominator + this.denominator * f.numerator;
	   n = this.denominator * f.denominator;
	   
	   Fraction f1 = new Fraction(z,n);
	   
	   return f1;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int n = 0;
		int z = 0;
		
		z = this.numerator * f.numerator;
		n = this.denominator * f.denominator;
		
		Fraction f1 = new Fraction(z,n);
		
		return f1;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		int z = this.numerator;
		int n = this.denominator;
		
		if (z != 0) {
			z = this.denominator;
			n = this.numerator;
		}
			
			Fraction f1 = new Fraction(z,n);
		
		
		
		return f1;
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		
		Fraction f1 = new Fraction(reciprocal().multiply(f).numerator,reciprocal().multiply(f).denominator);
		
		return f1;
       
    }"
Name_2,VName_2,"//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {
public static void main(String []args) {
	UBahn u = new UBahn();
	Wagen w1 = new Wagen(12,13);
	u.addWagen(w1);
	Wagen w2 = new Wagen(69,69);
	u.addWagen(w2);
	System.out.println(u.getSitzPlaetze());
	System.out.println(u.getStehPlaetze());
	System.out.println(u.getAllePlaetze());
	Wagen w3 = new Wagen(0,0);
	u.addWagen(w3);
	Wagen w4 = new Wagen(0,0);
	u.addWagen(w4);
	for(int i=0; i<5;i++) {
	u.removeWagen();
	}
}	
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_383,VName_383,"public class UBahnDemo {
	
	public static void main(String[] args) {
		
		UBahn u = new UBahn();
		Wagen w = new Wagen(2,5);
		Wagen w1 = new Wagen(1,7);
		
		
		
		System.out.println(u.addWagen(w));
		System.out.println(u.addWagen(w1));
		//System.out.println(u.addWagen(w2));
		//System.out.println(u.addWagen(w3));
		
		//System.out.println(u.getSitzPlaetze());//+""/""+u.getStehPlaetze()+""/""+u.getAllePlaetze());
		//System.out.println(w.getSitzPlaetze()+""/""+w.getStehPlaetze());
		//System.out.println(w1.getSitzPlaetze()+""/""+w1.getStehPlaetze());
		
		Wagen w2 = new Wagen(5,8);
		Wagen w3 = new Wagen(9,9);
		System.out.println(u.removeWagen());
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */

    public Fraction(int numerator, int denominator) {
		if (denominator == 0)
			denominator = 1;
			
		if ((denominator < 0) && (numerator < 0)){
			denominator = denominator - denominator - denominator;
			numerator = numerator - numerator - numerator;
			}
		
		if (denominator < 0)
			denominator = denominator - denominator - denominator;
		
		this.numerator = numerator;
		this.denominator = denominator;
        
	}	
    
    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator; 
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return this.numerator;   
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double z = 0;
		z = (double) this.numerator / this.denominator;
		return z;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s;
		s = this.numerator+""/""+this.denominator;
		return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
			//Berechnung des ggT
    	int ggt = GCD(this.numerator, this.denominator);
			
			//Kürzen des Bruches
		this.numerator /= ggt;
		this.denominator /= ggt;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    	int lm = LCM(f.denominator, this.denominator);
    	this.numerator *= (lm / this.denominator);
    	f.numerator *= (lm / f.denominator);
    	this.numerator += f.numerator;
    	this.denominator = lm;
    	Fraction f2 = new Fraction(this.numerator, this.denominator);
    	return f2;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int n = 0;
		int z = 0;
		
		z = this.numerator * f.numerator;
		n = this.denominator * f.denominator;
		
		Fraction f1 = new Fraction(z,n);
		
		return f1;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		int z = this.numerator;
		int n = this.denominator;
		
		if (z != 0) {
			z = this.denominator;
			n = this.numerator;
		}
			
			Fraction f1 = new Fraction(z,n);	
		return f1;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		
		Fraction f1 = new Fraction(reciprocal().multiply(f).numerator,reciprocal().multiply(f).denominator);
		
		return f1; 
    }"
Name_384,VName_384,"public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            denominator *= -1;
            numerator *= -1;
        }
        else if (denominator == 0) {
            denominator = 1;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();
    }


    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return numerator/(double) denominator;
    }

    public String toString() {
        return ("""" + numerator + ""/"" + denominator);
    }

    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    public Fraction add(Fraction f) {
        int lcm = LCM(f.getDenominator(), this.denominator);
        int n = (lcm/this.denominator) * this.numerator + (lcm/f.getDenominator()) * f.getNumerator();
        Fraction result = new Fraction(n, lcm);
        return result;
    }

    public Fraction multiply(Fraction f) {
        Fraction result = new Fraction(f.getNumerator()*this.numerator, f.getDenominator()*this.denominator);
        return result;
    }

    public Fraction reciprocal() {
        return new Fraction(denominator, numerator);
    }

    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }","public class UBahnDemo {
    public static void main(String[] args) {
        UBahn u9 = new UBahn();
        Wagen u9_w1 = new Wagen(20, 30);
        u9.addWagen(u9_w1);
        Wagen u9_w2 = new Wagen(10, 40);
        u9.addWagen(u9_w2);
        System.out.println(""Sitzplaetze in der U9: "" + u9.getSitzPlaetze());
        System.out.println(""Stehplaetze in der U9: "" + u9.getStehPlaetze());
        System.out.println(""Alle Plaetze in der U9: "" + u9.getAllePlaetze());
        u9.addWagen(u9_w1);
        u9.addWagen(u9_w2);
        for (int i=0; i<5; i++)
            u9.removeWagen();
    }
}"
Name_385,VName_385,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
	 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
	 
	
    public Fraction(int numerator, int denominator) {
        if(denominator == 0){
			denominator = 1;
		}
		if((numerator >= 0 && denominator < 0)||(numerator < 0 && denominator < 0)){
			this.numerator = numerator * -1;
			this.denominator = denominator * -1;
		}else {
			this.numerator = numerator;
			this.denominator = denominator;
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return ((double)numerator/denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String x = Integer.toString(numerator) + ""/"" + Integer.toString(denominator);
		return x;
    }
	

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int gCD = GCD(numerator, denominator);
		this.numerator = this.numerator/gCD;
		this.denominator = this.denominator/gCD;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int lCM = LCM(this.denominator, f.getDenominator());
		int newNumerator = (lCM/this.denominator)*this.numerator + (lCM/f.getDenominator()*f.getNumerator());
		Fraction sum = new Fraction(newNumerator, lCM);
       return sum;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		int newNumerator = this.numerator * f.getNumerator();
		int newDenominator = this.denominator * f.getDenominator();
		Fraction prod = new Fraction (newNumerator, newDenominator);
        return prod;
    }

    /*
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		if(this.numerator != 0){
		Fraction reci = new Fraction(this.denominator, this.numerator);
		return reci;
		}else {
			return null;
		}
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		reciprocal();
		return multiply(f);
    }","public class UBahnDemo{
	public static void main (String[] args){
		UBahn u6 = new UBahn();
		Wagen first = new Wagen(2,1);
		Wagen second = new Wagen(1,4);
		u6.addWagen(first);
		u6.addWagen(second);
		System.out.println(u6.getSitzPlaetze());
		System.out.println(u6.getStehPlaetze());
		System.out.println(u6.getAllePlaetze());
		u6.addWagen(first);
		u6.addWagen(second);
		for (int i = 0; i < 5; i++){
			u6.removeWagen();
		}
	}
}"
Name_386,VName_386,"public class UBahnDemo {

	public static void main(String[] args) {
	UBahn ub = new UBahn();
	Wagen wag1 = new Wagen(3,10);
	Wagen wag2 = new Wagen(3,13);
	Wagen wag3 = new Wagen(3,12);
	Wagen wag4 = new Wagen(3,11);
	ub.addWagen(wag1);
	ub.addWagen(wag4);
	
	System.out.println(ub.getSitzPlaetze());
	System.out.println(ub.getStehPlaetze());
	System.out.println(ub.getAllePlaetze());
	ub.addWagen(wag2);
	ub.addWagen(wag3);
	ub.removeWagen();
	ub.removeWagen();
	ub.removeWagen();	
	ub.removeWagen();
	ub.removeWagen();
	
	}

}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
       	
    	this.numerator = numerator;
    	this.denominator = denominator;
    	this.getNumerator();
    	this.getDenominator();
    	this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        if(denominator==0) {
    		denominator = 1;
    	}
    	else if(denominator<0) {
    		denominator*=-1;
    	}
        return  denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
       if(numerator<0&&denominator<0) {
    	 numerator = numerator*-1;
    	 }
    	else if(numerator>0&&denominator<0) {
    		numerator = numerator*-1;
    	}
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
          double gleitz = (double)numerator/denominator;
      
    	return gleitz;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String bruch = this.numerator + ""/"" + this.denominator;
    	return bruch;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
         int teiler = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/teiler;
        this.denominator = this.denominator/teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int fach = LCM(this.denominator,f.denominator);
    	int neudenominator = fach;
    	int zahl1 = fach/this.denominator;
    	int zahl2 = fach/f.denominator;
    	int neunumerator = this.numerator*zahl1 + f.numerator*zahl2;
    	return new Fraction(neunumerator,neudenominator);
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int neunumerator = f.numerator*this.numerator;
    	int neudenominator = f.denominator*this.denominator;
    	return new Fraction(neunumerator, neudenominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if(this.numerator!=0) {
    		return new Fraction(this.denominator, this.numerator);	
    	}
    	else {
    		return new Fraction(this.numerator, this.denominator);
    }
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
     Fraction g = this.reciprocal();
    	Fraction c = g.multiply(f);
   
     	return new Fraction(c.numerator,c.denominator);
    }"
Name_387,VName_387,"public class UBahnDemo {
	public static void main(String[] args) {
		UBahn ubahn = new UBahn();
		Wagen w1 = new Wagen(35, 25);
		ubahn.addWagen(w1);
		Wagen w2 = new Wagen(12, 18);
		ubahn.addWagen(w2);
		System.out.println(ubahn.getSitzPlaetze());
		System.out.println(ubahn.getStehPlaetze());
		System.out.println(ubahn.getAllePlaetze());
		Wagen w3 = new Wagen(12, 18);
		ubahn.addWagen(w3);
		Wagen w4 = new Wagen(12, 18);
		ubahn.addWagen(w4);
		for(int i = 5; i > 0; i-- ) {
		ubahn.removeWagen();
		}
	}
}","/**
  * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
  * uebergeben bekommt und die entsprechenden Attribute setzt. 
  * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
  * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
  * wird mathematisch korrekt behandelt. 
  * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
  * auf Eins gesetzt.
  * Jeder erzeugte Bruch wird gekuerzt 
  * (dazu soll die entsprechende Mehode s.u. verwendet werden).
  */
 public Fraction(int numerator, int denominator) {
	 if(denominator < 0) {
		 denominator *=-1;
		 numerator *=-1;
	 }else if (denominator == 0) {
		 denominator = 1;
	 }
     this.numerator = numerator;
     this.denominator = denominator;
     
 }

 /**
  * Gibt den Nenner zurueck.
  */
 public int getDenominator() {
     return denominator;
 }

 /**
  * Gibt den Zaehler zurueck.
  */
 public int getNumerator() {
     return numerator;
 }

 /**
  * Gibt den Bruch als Gleitkommazahl zurueck.
  */
 public double toDouble() {
     return (double) numerator/denominator;
 }

 /**
  * Gibt einen String im Format
  * ""Zaehler/Nenner"" zurueck.
  */
 public String toString() {
     return numerator +""/""+ denominator;
 }

 /**
  * Kuerzt (vereinfacht) den Bruch.
  */
 public void shorten() {
 		int d = GCD(numerator, denominator);
 		numerator = numerator/d;
 		denominator = denominator/d;
 		
 }
 

 /**
  * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
  */
 public Fraction add(Fraction f) {
    int newDenominator;
    int newNumerator;
    newNumerator = numerator * f.getDenominator() + f.getNumerator() * denominator;
    newDenominator = denominator * f.getDenominator();
    Fraction s = new Fraction(newNumerator, newDenominator);
    s.shorten();
    return s;

   
 }

 /**
  * Multipliziert den uebergebenen Bruch.
  */
 public Fraction multiply(Fraction f) {
     int newDenominator;
     int newNumerator;
     newNumerator = numerator * f.getNumerator();
     newDenominator = denominator * f.getDenominator();
     Fraction s = new Fraction(newNumerator, newDenominator);
     s.shorten();
     return s;
 }

 /**
  * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
  */
 public Fraction reciprocal() {
    if(numerator != 0) {
 	   int newNumerator = denominator;
 	   int newDenominator = numerator;
 	  Fraction s = new Fraction(newNumerator, newDenominator);
 	    s.shorten();
 	    return s;    }
    return new Fraction (denominator, numerator);
 }

	
 
 /**
  * Dividiert den uebergebenen Bruch 
  * (unter Verwendung von Kehrwert und Multiplikation).
  */
 public Fraction divide(Fraction f) {
    Fraction kehrwert = f.reciprocal();
    Fraction multi = kehrwert.multiply(this);
    return multi;
 }"
Name_388,VName_388,"/**
    }
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
     public Fraction(int numerator, int denominator) {
            if (denominator == 0){
                this.denominator = 1;
                this.numerator = numerator;
             }
            else {
                if (denominator > 0) {
                this.denominator = denominator;
                this.numerator = numerator;
                 }
              else {
                if (denominator < 0 && numerator > 0) {
                this.numerator = numerator * (-1);
                }
                else {
                this.denominator = denominator * (-1);
                this.numerator = numerator * (-1);
                }
             }
                this.denominator = denominator * (-1);
         }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double komma = (numerator/denominator);
        return komma;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s = String.valueOf(numerator) +""/"" + String.valueOf(denominator);
        return s;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
       numerator = numerator/GCD (getNumerator(), getDenominator());
       denominator = denominator/ GCD (getNumerator(), getDenominator());
	}
    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int nu = getNumerator() * LCM (getNumerator(), f.getNumerator());
       int nu2 = f.getNumerator() * LCM (getNumerator(), f.getNumerator());
		int de = getDenominator() * LCM (getDenominator(), f.getDenominator());
		int de2 = f.getDenominator() * LCM (getDenominator(), f.getDenominator());
		Fraction a = new Fraction ((nu+nu2),(de+de2));
		return a;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int n  = getNumerator() * f.getNumerator();
        int d = getDenominator () *f.getDenominator();
        Fraction m = new Fraction (n,d);
        return m;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
      public Fraction reciprocal() {
     int n;
     int d;
     if( numerator != 0) {
        n = getDenominator();
        d = getNumerator();
       }
      else {
        n = getNumerator();
        d = getDenominator();
       }
      Fraction r = new Fraction (n, d);
        return r;
    }

    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction d = new Fraction (1,1);
        d = multiply(f.reciprocal()); 
        return d;
        }","public class UBahnDemo {

	public static void main (String [] args) {
		UBahn ub = new UBahn ();
		Wagen w = new Wagen(4,6);
		ub.addWagen(w);
		Wagen r = new Wagen(5,2);
		ub.addWagen(r);
		System.out.println(ub.getSitzPlaetze());
		System.out.println(ub.getStehPlaetze());
		System.out.println(ub.getAllePlaetze());
		Wagen t = new Wagen(2,7);
		ub.addWagen(t);
		Wagen d = new Wagen(6,9);
		ub.addWagen(d);
		ub.removeWagen();
		ub.removeWagen();
		ub.removeWagen();
		ub.removeWagen();
		ub.removeWagen();
	}
}"
Name_389,VName_389,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }",-
Name_390,VName_390,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }",-
Name_391,VName_391,"public class UBahnDemo  {
    public static void main(String[]    args)   {
    UBahn u1 = new UBahn();
    Wagen w1 = new Wagen(20,50);
    Wagen w2 = new Wagen(30,40);
    Wagen w3 = new Wagen(12,21);
    Wagen w4 = new Wagen(15,80);
    u1.addWagen(w1);
    u1.addWagen(w2);
    int sip = u1.getSitzPlaetze();
    int stp = u1.getStehPlaetze();
    int ap = u1.getAllePlaetze();
    System.out.println(""Sitzplaetze: ""+sip+""\n"" +
                       ""Stehplaetze: ""+stp+""\n"" +
                       ""Plaetze insgesamt: ""+ap+""\n"");
    u1.addWagen(w3);
    u1.addWagen(w4);
    u1.removeWagen();
    u1.removeWagen();
    u1.removeWagen();
    u1.removeWagen();
    u1.removeWagen();   
    }
}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double d = (double)numerator/(double)denominator;
        return d;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        if(denominator == 0)
            denominator = 1;
        return Math.abs(numerator)+""/""+Math.abs(denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int i = Math.min(Math.abs(numerator), Math.abs(denominator));
        if(i==0)
            return;
        while((numerator %i != 0) || (denominator % i != 0))
            i--;
            numerator = numerator / i;
            denominator = denominator / i;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int denom = denominator * f.denominator;
       int num = numerator * f.denominator;
       int num2 = f.numerator * denominator;
       
       Fraction ergebnis = new Fraction(num + num2, denom);
       return ergebnis;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction ergebnis = new Fraction(numerator*f.getNumerator(),denominator * f.getDenominator());
        ergebnis.shorten();
        return ergebnis;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       Fraction ergebnis = new Fraction(denominator, numerator);
       return ergebnis;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction ergebnis = new Fraction(numerator*f.getDenominator(),denominator*f.getNumerator());
       ergebnis.shorten();
       return ergebnis;
    }"
Name_392,VName_392,"public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		
		if(denominator == 0){	
			this.denominator = 1;
		}
		if(denominator < 0){
			this.denominator = denominator;
			shorten();
			this.denominator = -this.denominator;
			this.numerator = -this.numerator;
		}
		if(denominator > 0){
			this.denominator = denominator;
		}
	}


	public int getNumerator(){
		return numerator;
	}

	public int getDenominator(){
		return denominator;
	}

	public double toDouble(){
		double dezimal = (double) numerator/denominator;
		return dezimal;
	}

	public String toString(){
		String alsString = new String (numerator + ""/"" + denominator);
		return alsString;
	}
	
	public void shorten(){
			int i = GCD(this.numerator, this.denominator);
			this.numerator = this.numerator/i;
			this.denominator = this.denominator/i;
			
	}
			
		
	
	public Fraction add(Fraction f){
		int i = LCM(this.denominator, f.denominator);
		int j = i/this.denominator;
		int k = i/f.denominator;
		int addNumerator = this.numerator*j + f.numerator*k;
		int addDenominator = this.denominator*j;
		Fraction added = new Fraction(addNumerator, addDenominator);
		added.shorten();
		return added;
	}
	
	public Fraction multiply(Fraction f) {
        int mulNumerator = this.numerator*f.numerator;
		int mulDenominator = this.denominator*f.denominator;
		Fraction multiplied = new Fraction(mulNumerator, mulDenominator);
		multiplied.shorten();
		if(multiplied.denominator < 0){
			multiplied.denominator = -multiplied.denominator;
			multiplied.numerator = -multiplied.numerator;
		}
		return multiplied;
    }
	
	public Fraction reciprocal() {
		if(this.numerator ==0){
			return null;
		}
       int newDenominator = this.numerator;
	   int newNumerator = this.denominator;
	   Fraction reciprocated = new Fraction(newNumerator, newDenominator);
			reciprocated.shorten();
	   		if(reciprocated.denominator < 0){
			reciprocated.denominator = -reciprocated.denominator;
			reciprocated.numerator = -reciprocated.numerator;
			}
	   return reciprocated;
	   
    }
	
	 public Fraction divide(Fraction f) {
       Fraction div = f.reciprocal();
	   if(div == null){
		return null;
	   }
	   Fraction divided = multiply(div);
	   divided.shorten();
	   return divided;
    }","public class UBahnDemo{

	public static void main(String [] args){
		UBahn u7 = new UBahn();
		u7.addWagen(new Wagen(40, 60));
		u7.addWagen(new Wagen(50, 50));
		System.out.println(u7.getSitzPlaetze() + ""Sitzplaetze"");
		System.out.println(u7.getStehPlaetze() + ""Stehplaetze"");
		System.out.println(u7.getAllePlaetze() + ""Plaetze"");
		u7.addWagen(new Wagen(60, 40));
		u7.addWagen(new Wagen(70, 30));
		u7.removeWagen();
		u7.removeWagen();
		u7.removeWagen();
		u7.removeWagen();
		u7.removeWagen();
		
		
	}

}"
Name_393,VName_393,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator == 0) {
            this.denominator = 1;
            this.numerator = numerator;
        }
        else if (denominator < 0){
            this.numerator = -1*numerator;
            this.denominator = -1*denominator;
        }
        else {
            this.numerator = numerator;
            this.denominator = denominator;
        }

        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return """" + numerator + ""/"" + denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int shortened = GCD(numerator, denominator);
        if (shortened < 0){
            shortened = -1*shortened;
        }
        numerator /= shortened;
        denominator /= shortened;
    
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int plainDenominator = LCM(this.denominator, f.denominator);

        
        Fraction plainA = new Fraction(this.numerator, this.denominator);
        plainA.numerator = this.numerator*(plainDenominator/this.denominator);
        plainA.denominator = plainDenominator;
        Fraction plainB = new Fraction(f.getNumerator(), f.getDenominator());
        plainB.numerator = f.numerator*(plainDenominator/f.denominator);
        plainB.denominator = plainDenominator;

        
        Fraction sum = new Fraction(plainA.numerator + plainB.numerator, plainDenominator);
        return sum;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newN = numerator * f.getNumerator();
        int newD = denominator * f.getDenominator();
        Fraction result = new Fraction(newN, newD);
        return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       Fraction reciprocal = new Fraction (this.denominator, this.numerator);
        return reciprocal;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       int newN = this.numerator * f.getDenominator();
        int newD = this.denominator * f.getNumerator();
        Fraction result = new Fraction(newN, newD);
        return result;
    }"
Name_394,VName_394,"public class Fraction{

    private int numerator,denominator;
   /**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return numerator/denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.denominator*f.denominator, this.numerator*f.numerator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        
       if(this.numerator != 0) return new Fraction(this.denominator,this.numerator);
       else return null;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }
}","public class UBahnDemo{
	public static void main(String[] args) {
		UBahn u1 = new UBahn();

		Wagen a = new Wagen(15,30);

		u1.addWagen(a);
		u1.addWagen(new Wagen(20,20));

		System.out.println(""Anzahl der Sitzplätze: ""+u1.getSitzPlaetze());		
		System.out.println(""Anzahl der Stehplätze: ""+u1.getStehPlaetze());
		System.out.println(""Anzahl aller Plätze:   ""+u1.getAllePlaetze());

		u1.addWagen(new Wagen(30,5));
		u1.addWagen(new Wagen(25,20));

		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();

	}
}"
Name_395,VName_395,"public class UBahnDemo {

    public static void main(String[] args) {
        
       UBahn ubahn=new UBahn();
        
        ubahn.addWagen(new Wagen(3,5));
        ubahn.addWagen(new Wagen(1,2));
        
        System.out.println(""Total Sitzplaetze: ""+ubahn.getSitzPlaetze());
        System.out.println(""Total Stehplaetze: ""+ubahn.getStehPlaetze());
        System.out.println(""Total Plaetze: ""+ubahn.getAllePlaetze());
        
        ubahn.addWagen(new Wagen(1,6));
        ubahn.addWagen(new Wagen(4,8));
        
        for(int i=0;i<5;i++)
            ubahn.removeWagen();
        
        
    }
    
}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
         if( denominator == 0) {
           denominator = 1;
           }
          if (denominator < 0) {
            numerator = numerator * -1;
            denominator = denominator * -1;
          }
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return (double) numerator / denominator ;
        
    }

  public String toString() {
     String buffer = numerator + ""/"" + denominator;
       return buffer;
    }

    public void shorten() {
           int result ;
           int common = 0;
           int num = Math.abs(numerator);
           int den = Math.abs(denominator);
          if (num > den) {
         common = GCD(num, den);
          }
          else if (num < den) {
         common = GCD(den, num); 
          }
         else  {
         common = num; 
         }
          result.numerator = numerator / common;
           result.denominator = denominator / common;
             return result;
      }

    public Fraction add(Fraction f) {
             int common = LCM(denominator, f.denominator);
             Fraction commonA = new Fraction(1 , 1);
             Fraction commonB = new Fraction(1 , 1);
               commonA = reciprocal(common);
               commonB = f.reciprocal(common);
             Fraction summe = new Fraction(1 , 1);
              summe.numerator = commonA.numerator + commonB.numerator;
              summe.denominator = common;
              summe = summe.shorten();
           return summe;
    }

   public Fraction multiply(Fraction f) {
           Fraction produkt = new Fraction(1 , 1);
           produkt.numerator = numerator * f.numerator;
            produkt.denominator = denominator * f.denominator;
              produkt = produkt.shorten();
               return produkt;
  }

        public Fraction reciprocal() {
         Fraction resultt = new Fraction(1 , 1);
         int factor = common / denominator;
         resultt.numerator = numerator * factor;
         resultt.denominator = common;
         resultt = resultt.shorten();
         return resultt;
        }
    
     public Fraction divide(Fraction f) {
      Fraction division = new Fraction(1 , 1);
       division.numerator = numerator * f.denominator;
       division.denominator = denominator * f.numerator;
       division = division.shorten();
       return division;
     }"
Name_396,VName_396,"public class UBahnDemo {
	public static void main (String [] args){
		
		Wagen wagenEins= new Wagen (20,30);
		Wagen wagenZwei=new Wagen (25, 40);
		UBahn uBahn =new UBahn ();
		uBahn.addWagen (wagenEins);
		uBahn.addWagen (wagenZwei);
		System.out.println(uBahn.getSitzPlaetze ());
		System.out.println(uBahn.getStehPlaetze ());
		System.out.println(uBahn.getAllePlaetze ());
		Wagen wagenDrei=new Wagen (32,45);
		Wagen wagenVier=new Wagen (22,33);
		uBahn.addWagen (wagenDrei);
		uBahn.addWagen (wagenVier);
		uBahn.removeWagen ();
		uBahn.removeWagen ();
		uBahn.removeWagen ();
		uBahn.removeWagen ();
		uBahn.removeWagen ();
}
}","public Fraction(int numerator, int denominator) {

        if (denominator<0) {
            this.numerator=numerator*(-1);
            this.denominator=denominator*(-1);
        }

         if (denominator==0) {
            this.numerator=numerator;
            this.denominator=1;
        }

        else {
            this.numerator=numerator;
            this.denominator=denominator;
        }
        shorten ();
    }

    //Nenner
    public int getDenominator() {
        return this.denominator;
    }
    //Zähler
    public int getNumerator() {
        return this.numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double n = (double) this.numerator;
        double d = (double) this.denominator;
        double gleitkomma= n/d;
        return gleitkomma;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (this.numerator+""/""+this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
       int gcd= GCD (this.numerator, this.denominator);
       this.numerator=this.numerator/gcd;
       this.denominator=this.denominator/gcd;

    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add (Fraction f) {
        int lcm= LCM (this.denominator, f.getDenominator());
        int deno=lcm;
        int fDeno=lcm;
        int numero= this.numerator * (lcm/this.denominator);
        int fNumero=f.getNumerator() * (lcm/f.getDenominator());
        numero+=fNumero;
        Fraction addFraction = new Fraction (numero, deno);
        return addFraction;

    }
    //3/4  4/5 -> lcm=20 -> 3/4 *5 ; 4/5 * 4 -> 15/20  16/20

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int deno=this.denominator;
        int numero=this.numerator;
        int fDeno= f.getDenominator();
        int fNumero= f.getNumerator();
        numero= numero * fNumero;
        deno= deno*fDeno;
        Fraction multiplyFraction =new Fraction (numero, deno);
        return multiplyFraction;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        if (this.numerator!=0) {
            int numero = this.numerator;
            int deno= this.denominator;
            Fraction reciprocalFraction =new Fraction (deno, numero);
            return reciprocalFraction;
        }
        else {
            Fraction reciprocalFraction=new Fraction (this.numerator, this.denominator);
            return reciprocalFraction;
        }
        
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        int deno = this.denominator * f.getNumerator();
        int numero= this.numerator* f.getDenominator();
        Fraction divideFraction =new Fraction (numero, deno);
        return divideFraction;
       
    }"
Name_397,VName_397,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator == 0){
            denominator = 1;
        }
        if (denominator < 0){
          numerator = -numerator;
          denominator = -denominator;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)(this.numerator/this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int f = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator / f;
        this.denominator = this.denominator / f;
        if (this.denominator < 0){
          this.numerator = -this.numerator;
          this.denominator = -this.denominator;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.denominator, f.denominator);
       this.numerator = (((lcm/this.denominator)*this.numerator) + (((lcm/f.denominator)*(f.numerator))));
       this.denominator = lcm;
       return this;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator = this.numerator*f.numerator;
        this.denominator = this.denominator*f.denominator;
        if (this.denominator < 0){
          this.numerator = -this.numerator;
          this.denominator = -this.denominator;
        }
        return this;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if(this.numerator != 0){
           int s = this.denominator;
           this.denominator = this.numerator;
           this.numerator = s;
       }
       return this;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        this.multiply(f.reciprocal());
        return this;
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {

	public static void main(String[] args) {
		UBahn ubahn = new UBahn();
		ubahn.addWagen(new Wagen(3, 4));
		ubahn.addWagen(new Wagen(2, 1));
		System.out.println(ubahn.getSitzPlaetze());
		System.out.println(ubahn.getStehPlaetze());
		System.out.println(ubahn.getAllePlaetze());
		ubahn.addWagen(new Wagen(4, 4));
		ubahn.addWagen(new Wagen(2, 1));
		for(int i = 0; i<5; i++){
			ubahn.removeWagen();
		}
	}
}"
Name_96,VName_96,"//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		UBahn ub = new UBahn();
		ub.addWagen(new Wagen (3,4));
		ub.addWagen(new Wagen (2,1));
		System.out.println(ub.getSitzPlaetze());
		System.out.println(ub.getStehPlaetze());
		System.out.println(ub.getAllePlaetze());
		ub.addWagen(new Wagen (4,4));
		ub.addWagen(new Wagen (2,1));
		int i = 0;
		while(i < 5) {
			ub.removeWagen();
			i++;
		}

	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(denominator == 0){
            denominator = 1;
        }
        if (denominator < 0){
            numerator = -numerator;
            denominator = -denominator;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() { 
        return numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)(this.numerator/this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int zwischen = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator / zwischen;
        this.denominator = this.denominator / zwischen;
        if (this.denominator < 0){
        this.numerator = -this.numerator;
        this.denominator = -this.denominator;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int kgv = LCM(this.denominator, f.denominator);
       int zw = kgv/this.denominator;
       this.numerator = (zw*this.numerator) + (zw*f.numerator);
       this.denominator = kgv;
       
       return this;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator = this.numerator*f.numerator;
        this.denominator = this.denominator*f.denominator;
        if (this.denominator < 0){
        this.numerator = -this.numerator;
        this.denominator = -this.denominator;
        }
        return this;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if(this.numerator != 0){
           int k = this.numerator;
           this.numerator = this.denominator;
           this.denominator = k;
       }
       return this;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        this.multiply(f.reciprocal());
        return this;
    }"
Name_398,VName_398,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		this.numerator = numerator;
		this.denominator = denominator;
			if(denominator < 0) {
				this.denominator *= -1;
				this.numerator *= -1;
			}
			if(denominator == 0) {
				this.denominator = 1;
			}
		shorten();
		
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return denominator;  
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
		double num = this.numerator;
		double den = this.denominator;
		return num/den;     
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		String num = String.valueOf(this.numerator);
		String den = String.valueOf(this.denominator);
		return num+""/""+den;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
		int a = GCD(this.numerator, this.denominator);
		this.numerator /= a;
		this.denominator /= a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int a = LCM(this.denominator, f.denominator);
		this.numerator *= f.denominator;
		f.numerator *= this.denominator;
		this.denominator = a;
		this.numerator += f.numerator;
		Fraction g = new Fraction(this.numerator, this.denominator);
		return g;   
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		this.numerator *= f.numerator;
		this.denominator *= f.denominator;
		Fraction g = new Fraction(this.numerator, this.denominator);
		return g; 
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		if(numerator != 0) {
			this.numerator = denominator;
			this.denominator = numerator;
		}
		Fraction g = new Fraction(this.numerator, this.denominator);
		return g; 
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction g = new Fraction(this.numerator, this.denominator);
		g.reciprocal();
		g.multiply(f);
		return g;        
    }","public class UBahnDemo {
	
	public static void main(String[] args) {
		UBahn u = new UBahn();
		Wagen w1 = new Wagen(30,45);
		Wagen w2 = new Wagen(50,30);
		u.addWagen(w1);
		u.addWagen(w2);

		System.out.println(""Gesamte Sitzplätze: ""+u.getSitzPlaetze()+""\nGesamte Stehplätze: ""+u.getStehPlaetze()+""\nAlle Plätze: ""+u.getAllePlaetze());
		
		Wagen w3 = new Wagen(53,235);
		Wagen w4 = new Wagen(34,1);
		u.addWagen(w3);
		u.addWagen(w4);
		u.removeWagen(5);
	}
}"
Name_399,VName_399,"//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {

	public static void main(String[] args) {
	 
		int anzahlWagen = 0;
	    int sitzPlaetze; 
		int stehplaetze;
		int allePlaetze; 
		
		
		UBahn uBahn = new UBahn();
		
		Wagen[] w= new Wagen[anzahlWagen];
		Wagen w1 = new Wagen(40, 100);
		Wagen w2 = new Wagen(20, 80);
		Wagen w3 = new Wagen (110, 90);
		Wagen w4 = new Wagen (60, 40);
	
		
		uBahn.addWagen(w1);	
		uBahn.addWagen(w2);
	
		
		System.out.println(""Gesamtzahl der Sitzplätze: ""+ uBahn.getSitzPlaetze()); 
		System.out.println(""Gesamtzahl der Stehplätze: "" + uBahn.getStehPlaetze());
		System.out.println(""Gesamtzahl aller Plätze: "" + uBahn.getAllePlaetze());
		
		uBahn.addWagen(w3);
		uBahn.addWagen(w4);
		
		System.out.println(""Gesamtzahl der Sitzplätze: ""+ uBahn.getSitzPlaetze()); 
		System.out.println(""Gesamtzahl der Stehplätze: "" + uBahn.getStehPlaetze());
		System.out.println(""Gesamtzahl aller Plätze: "" + uBahn.getAllePlaetze());
		
		
		uBahn.removeWagen(1); 
		uBahn.removeWagen(1); 
		uBahn.removeWagen(1); 
		uBahn.removeWagen(1); 
		uBahn.removeWagen(1); 
		
		}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
  
   
	
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator; 
        this.denominator = denominator; 
        
        if (denominator < 0) {
        	System.out.println(""ungültiger Wert"");  	//nenner darf nicht negativ sein, IST ABER ERLAUBT?! WTF
        }
       
        if (denominator == 0) {
        	this.denominator = 1;
        }
        
        shorten(); 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator; 
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
    	return ((double) this.numerator / this.denominator);        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = this.numerator+""/""+this.denominator;
        return str; 
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
      int m = Math.abs(numerator);
      int n = Math.abs(denominator);
      
      int r; 
      do {
    	  r = m % n;
    	  m = n;
    	  n = r;    	  
      }
      while (n != 0); 
      
      if (m > 1) {
    	  numerator /= m; 
    	  denominator /= m;     	  
      }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) { 
       
       int zaehler = this.numerator  + f.getNumerator();
       int nenner = this.denominator + f.getDenominator();       
      
       GCD(zaehler, nenner);
       LCM(zaehler, nenner); 
       
       return new Fraction(zaehler, nenner); 
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
       
        int zaehler = this.numerator * f.getNumerator();
        int nenner = this.denominator * f.getDenominator(); 

        return new Fraction(zaehler, nenner);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {    	
    	Fraction neuerBruch = new Fraction(denominator, numerator); 
       	return neuerBruch;    
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {       
       reciprocal();
       multiply(f);
       return new Fraction(numerator, denominator);
    }"
Name_400,VName_400,"//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo{
	public static void main (String[] args){
		UBahn u1 = new UBahn ();
		Wagen w1 = new Wagen (27, 94);
		u1.addWagen (w1);

		Wagen w2 = new Wagen (78, 100);
		u1.addWagen (w2);
		System.out.println (u1.getSitzPlaetze());
		System.out.println (u1.getStehPlaetze());
		System.out.println (u1.getAllePlaetze());

		Wagen w3 = new Wagen (55, 55);
		u1.addWagen (w3);
		Wagen w4 = new Wagen (55, 77);
		u1.addWagen (w4);

		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
	} 

}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    	public Fraction(int numerator, int denominator) {
        	this.numerator = numerator;
		this.denominator = denominator;
		if (denominator < 0){
			this.numerator = numerator *-1;
			this.denominator =denominator *-1;
		}
		
		if (denominator == 0){
			this.denominator = 1;
		}
		shorten();				
	}

/**
* Gibt den Nenner zurueck.
*/
	public int getDenominator() {
		return this.denominator;
	}

/**
* Gibt den Zaehler zurueck.
*/
	public int getNumerator() {
		return this.numerator;
	}

/**
* Gibt den Bruch als Gleitkommazahl zurueck.
*/
	public double toDouble() {
		return (double)numerator/(double)denominator;
	}

/**
* Gibt einen String im Format
* ""Zaehler/Nenner"" zurueck.
*/
	public String toString() {
		return (numerator + ""/"" + denominator);
	}

/**
* Kuerzt (vereinfacht) den Bruch.
*/
	public void shorten() {
		numerator = numerator/GCD(numerator, denominator);
		denominator = denominator/GCD(numerator, denominator);
	}

/**
* Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
*/
	public Fraction add(Fraction f) {
		int lcm= LCM(this.denominator, f.getDenominator());
		int x = (lcm/this.denominator)*this.numerator + (lcm/f.getDenominator())*f.getNumerator();
		int y = lcm;
		return new Fraction (x, y);

	}

/**
* Multipliziert den uebergebenen Bruch.
*/
	public Fraction multiply(Fraction f) {
		return new Fraction (this.numerator*f.getNumerator() ,this.denominator* f.getDenominator());
	}

/**
* Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
*/
	public Fraction reciprocal() {
		return new Fraction (this.denominator, this.numerator);
	}

/**
* Dividiert den uebergebenen Bruch 
* (unter Verwendung von Kehrwert und Multiplikation).
*/
	public Fraction divide(Fraction f) {
		return this.multiply(f.reciprocal());
	}"
Name_401,VName_401,"public class UBahnDemo {
	
	public static void main(String[] args) {
		UBahn u1 = new UBahn();
		Wagen w1 = new Wagen(20,15);
		Wagen w2 = new Wagen(60,60);
		Wagen w3 = new Wagen(10,11);
		Wagen w4 = new Wagen(50,33);
		u1.addWagen(w1);
		u1.addWagen(w2);
		System.out.println(u1.getSitzPlaetze()+"" Sitzplaetze"");
		System.out.println(u1.getStehPlaetze()+"" Stehplaetze"");
		System.out.println(u1.getAllePlaetze()+"" Plaetze insgesamt"");
		u1.addWagen(w3);
		u1.addWagen(w4);
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();

	}
	
}//Hier soll die Klasse UBahnDemo stehen!","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if( denominator < 0) {
			numerator = -numerator;
			denominator = -denominator;
		}
		if(denominator == 0) denominator = 1;
		this.numerator = numerator;
		this.denominator = denominator;
		this.shorten(); 
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
            return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (numerator+""/""+denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator / a;
		this.denominator = this.denominator / a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int a = LCM(this.denominator, f.denominator);
       return new Fraction(this.numerator*(a/this.denominator)+f.numerator*(a/f.denominator),a);
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int a = this.numerator * f.numerator;
		int b = this.denominator * f.denominator;
		return new Fraction(a,b);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
      if(this.numerator != 0) return new Fraction(this.denominator, this.numerator);
      else return this;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       	return this.multiply(f.reciprocal());
    }"
Name_402,VName_402,"public class UBahnDemo{
    public static void main(String[] args){
        UBahn u7 = new UBahn();
        Wagen w1 = new Wagen(20,30);
        Wagen w2 = new Wagen(25,40);
        u7.addWagen(w1);
        u7.addWagen(w2);
        System.out.println(""Anzahl Sitzplaetze: .""+u7.getSitzPlaetze()+
        "".\nAnzahl der Stehplaetze: .""+u7.getStehPlaetze()+
        "".\nAnzahl aller Plaetze: .""+u7.getAllePlaetze()+""."");
        Wagen w3 = new Wagen(15,24);
        Wagen w4 = new Wagen(30,50);
        u7.addWagen(w3);
        u7.addWagen(w4);
        u7.removeWagen();
        u7.removeWagen();
        u7.removeWagen();
        u7.removeWagen();
        u7.removeWagen();
    }
}","public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		
		if(this.denominator < 0){
			this.denominator = this.denominator * (-1);
			this.numerator = this.numerator * (-1);
		}
		else if(this.denominator == 0){
			this.denominator = 1;
		}
		else{
			this.numerator = numerator;
			this.denominator = denominator;
		}
		shorten();
    }

    
    public int getDenominator() {
        return this.denominator;
        
    }

    public int getNumerator() {
        return this.numerator;
        
    }

    
    public double toDouble() {
        double x = (double)this.numerator;
	double y = (double)this.denominator;
	double gk = x/y;
	return gk;
        
    }

    
    public String toString() {
        return this.numerator+""/""+this.denominator;
        
    }

    
    public void shorten() {
        int factor = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator / factor;
		this.denominator = this.denominator / factor;
		if(this.denominator < 0){
			this.numerator = this.numerator *(-1);
			this.denominator = this.denominator *(-1);
		}
        
    }

   
    public Fraction add(Fraction f) {
        Fraction addiert = new Fraction(this.getNumerator(),this.getDenominator());
		int lcm = LCM(f.getDenominator(), addiert.getDenominator());
		int faktorf = lcm / f.getDenominator();
		f.numerator = f.getNumerator() * faktorf;
		f.denominator = f.getDenominator() * faktorf;
		int faktora = lcm / addiert.getDenominator();
		addiert.denominator = addiert.getDenominator() * faktora;
		addiert.numerator = addiert.getNumerator() * faktora;
		addiert.numerator = addiert.getNumerator() + f.getNumerator();
		addiert.denominator = addiert.getDenominator();
		addiert.shorten();
		return addiert;
       
    }

   
    public Fraction multiply(Fraction f) {
        Fraction multi = new Fraction(this.getNumerator(),this.getDenominator());
		multi.numerator = multi.getNumerator() * f.getNumerator();
		multi.denominator = multi.getDenominator() * f.getDenominator();
		multi.shorten();
		return multi;
        
    }

    
    public Fraction reciprocal() {
        Fraction recip = new Fraction(this.getNumerator(),this.getDenominator());
		if(recip.numerator == 0){
			return this;
		}
		else if(recip.numerator != 0){
			int x = this.getNumerator();
			recip.numerator = this.getDenominator();
			recip.denominator = x;
			recip.shorten();
			
		}
		return recip;
       
    }
    
   
    public Fraction divide(Fraction f) {
        Fraction div = new Fraction(this.getNumerator(),this.getDenominator());
			return div.multiply(f.reciprocal());
       
    }"
Name_403,VName_403,"public class UBahnDemo{
	public static void main(String[] args){
		UBahn linie1 = new UBahn();
		Wagen w1 = new Wagen(1,2);
		Wagen w2 = new Wagen (2,2);
		Wagen w3 = new Wagen (2,4);
		Wagen w4 = new Wagen (3,5);
		linie1.addWagen(w1);
		linie1.addWagen(w2);
		Terminal.println(linie1.getSitzPlaetze());
		Terminal.println(linie1.getStehPlaetze());
		Terminal.println(linie1.getAllePlaetze());
		linie1.addWagen(w3);
		linie1.addWagen(w4);
		linie1.removeWagen(w1);
		linie1.removeWagen(w4);
		linie1.removeWagen(w2);
		linie1.removeWagen(w3);
		linie1.removeWagen(w1);
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
//public class Fraction{
//	private int numerator;
//	private int denominator;
	private double bruch;
	private int gekuerzt;
   public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		this.denominator = denominator;
		if(denominator < 0){
			this.numerator = 0-numerator;
			this.denominator = denominator*(-1);
		}
		if(denominator == 0){
			this.denominator = 1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        bruch = (double)numerator/(double)denominator;
		return bruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = ""\n"" + this.numerator
		+ ""/"" + this.denominator;
		return str;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int kunu = numerator/(GCD(numerator, denominator));
		int kude = denominator/(GCD(numerator, denominator));
		Terminal.println(kunu+ ""/"" + kude);
    }
	
//	public static int GCD(int x, int y) {
//    if (y == 0) {
//        return x;
		}
//    return GCD(y, x % y);
//	}

//	public static int LCM(int x, int y) {
//    return (x * y) / GCD(x, y);
//	}


    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
   public Fraction add(Fraction f) {
	int erweitern = LCM(this.denominator, f.denominator);
	int numf = erweitern/f.denominator;
	int numthis = erweitern/this.denominator;
	//Terminal.println(""erweitere mit: ""+ erweitern);
	//Terminal.println(""numf: ""+numf);
	//Terminal.println(""numthis: ""+numthis);
	int addnum = numf*this.numerator+numthis*f.numerator;
	int addden = erweitern;
	Fraction add = new Fraction(addnum, addden);
  return add;
   }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
	//Terminal.println(""f.num: ""+f.numerator
	//	+""\n f.den: "" +f.denominator
	//	+""\n this.num: "" +this.numerator
	//	+""\n this.den: "" +this.denominator);
	int mulnum = f.numerator*this.numerator;
	int mulden = f.denominator*this.denominator;
	Fraction multiply = new Fraction(mulnum, mulden);
return multiply;	
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if(this.numerator !=0){
		   int numalt = this.numerator;
		   this.numerator = this.denominator;
		   this.denominator = numalt;
		   Fraction reci = new Fraction(this.numerator, this.denominator);
		   return reci;
	   } 
	   return null;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
	  Fraction divide =  multiply(f.reciprocal());
	  return divide;
    }
//}"
Name_404,VName_404,"public class UBahnDemo{
	
	public static void main(String[] args){
	
	Wagen a = new Wagen(50,80);
	Wagen b = new Wagen(30,100);
	
	UBahn gelb = new UBahn();
	
	gelb.addWagen(a);
	gelb.addWagen(b);
	System.out.println(gelb.getSitzPlaetze());
	System.out.println(gelb.getStehPlaetze());
	System.out.println(gelb.getAllePlaetze());
	gelb.addWagen(a);
	gelb.addWagen(b);
	gelb.removeWagen();
	gelb.removeWagen();
	gelb.removeWagen();
	gelb.removeWagen();
	gelb.removeWagen();
	
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */




    public Fraction(int numerator, int denominator) {
        
        this.numerator = numerator;
		
		if(denominator < 0){
		   this.numerator = -numerator;
		   this.denominator = -denominator;
	   }
        
        if(denominator > 0 ){
        this.denominator = denominator;
        }
        if(denominator == 0 ){  
			this.denominator = 1;
        }
        
        this.shorten();
        
        }
    

  
  
    public int getDenominator() {
        return this.denominator;
    }

 
    
    public int getNumerator() {
        return this.numerator;
    }


    
    public double toDouble() {
      
		return (double) this.numerator/this.denominator;
    }

   
    
    public String toString() {
       String s = this.numerator+""/""+this.denominator;
	   return s;
    }


    
     
    public void shorten() {
      int x = GCD(this.numerator,this.denominator);
      this.numerator = this.numerator/x;
      this.denominator = this.denominator/x;
       if(denominator < 0){
		   this.numerator = -numerator;
		   this.denominator = -denominator;
	   }
        
        
    }
	
    
    public Fraction add(Fraction f) {
       
	   int x = LCM(this.denominator,f.denominator);
	   this.numerator = this.numerator * x/this.denominator + f.numerator * x/f.denominator;
	   this.denominator = x;
	   return this;
	   
	   
    }

    
    public Fraction multiply(Fraction f) {
		this.denominator = this.denominator * f.denominator;
		this.numerator = this.numerator * f.numerator;
		return this;
		
       
		
    }

   
    
    public Fraction reciprocal() {
		if(numerator != 0){
		int r = numerator;
		numerator = denominator;
		denominator = r;
		
		if(denominator < 0){
		   this.numerator = -numerator;
		   this.denominator = -denominator;
	    }
		}
		
		return this;
       
    }
    
    
 
    public Fraction divide(Fraction f) {
		
		this.multiply(f.reciprocal());
		f.reciprocal();
		return this;
	}"
Name_405,VName_405,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator =numerator;
        this.denominator=denominator;
        if (denominator==0){
            this.denominator=1;
        }
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         double d = (double) this.numerator/this.denominator;
        return d;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
         String s= this.numerator+""/""+this.denominator;
        return s;
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt = GCD(this.numerator, this.denominator);
        this.denominator=this.denominator/ggt;
        this.numerator=this.numerator/ggt;

        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
         int kgv = LCM(this.denominator, f.denominator);
        int a = this.denominator/kgv;
        int b = f.denominator/kgv;

        int a_oben = this.numerator*a;
        int b_oben= f.numerator*a;

        Fraction r = new Fraction(a_oben+b_oben, kgv);
        r.shorten();
        return r;
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
         Fraction r= new Fraction(this.numerator*f.numerator, this.denominator*f.denominator);
        r.shorten();
        return r;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        if (this.numerator!=0) {
            Fraction r = new Fraction(this.denominator, this.numerator);
            r.shorten();
            return r;

        }
        else{
            return this;
        }

       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
         Fraction reci  = f.reciprocal();
        Fraction r = this.multiply(reci);
        r.shorten();
        return r;
       
    }"
Name_406,VName_406,"public Fraction(int numerator, int denominator) {
		if (denominator < 0) 
		{denominator = denominator*(-1);
	numerator = numerator*(-1);
	}
	
		else if (denominator == 0 ) 
		{denominator = 1;}
		
        this.numerator = numerator ;
		this.denominator = denominator ;
		int fraction = numerator / denominator ;
    }

//nenner
    public int getDenominator() {
        return denominator ;
    }

//zaeler
    public int getNumerator() {
        return numerator ;
    }


    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double m =  numerator / denominator ;
		return m;
    }




    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String s = (getNumerator() + ""/"" + getDenominator()) ;
		return s ;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
	int wertGCD = GCD (getNumerator(), getDenominator()) ;
       numerator = getNumerator() / wertGCD ;
	   denominator = getDenominator() / wertGCD ;
    }



    
     // Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
    
    public Fraction add(Fraction f) {
		
		Fraction r = new Fraction (getNumerator(), getDenominator ()); 
       int c = LCM (f.denominator,r.denominator) ;
	   int c1 = c / r.denominator ;
	   int c2 = c / f.denominator  ;
	   
	   r.numerator = c1 * r.numerator ;
       r.denominator = c1* r.denominator ;
	   
	   f.numerator = c2 * f.numerator ;
	   f.denominator = c2* f.denominator ;
	   
	   int a = r.numerator + f.numerator;
	   r.numerator = a ;
	   r.denominator = c;
	   r.shorten ();
	   
	   return (r) ;
    }

    
     // Multipliziert den uebergebenen Bruch.
     
    public Fraction multiply(Fraction f) {
		Fraction r = new Fraction (getNumerator(), getDenominator ()); 

        r.numerator = r.numerator * f.numerator ;
		r.denominator = r.denominator * f.denominator ;
		r.shorten();
		return r ;
    }

    
     // Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     
    public Fraction reciprocal() {
		Fraction r = new Fraction (getNumerator(), getDenominator());

       if (r.numerator > 0) {
		   int h = r.numerator ;
		   r.numerator = r.denominator ;
		   r.denominator = h ;
	   }
	   
	   else if (r.numerator < 0) {
		   int h = r.numerator ;
		   r.numerator = -1*r.denominator ;
		   r.denominator = -1*h ;
    }
		   	   return r ;

	}
    
    
     //Dividiert den uebergebenen Bruch Kehrwert + Multiplikation
     
    public Fraction divide (Fraction f) {
	   Fraction k = new Fraction (getNumerator(), getDenominator());
	   Fraction p = new Fraction (f.numerator, f.denominator);
       p = p.reciprocal ();
	   k = k.multiply (p);
	   k.shorten ();
	   return k ;
    }","public class UBahnDemo {

public static void main (String [] args) {
	
        UBahn U9 = new UBahn();

        Wagen W1 = new Wagen(50, 120);
        Wagen W2 = new Wagen(30, 75);
		
		U9.addWagen (W1);
		U9.addWagen (W2);
		
		System.out.println (U9.getSitzPlaetze());
	    System.out.println (U9.getStehPlaetze());
	    System.out.println (U9.getAllePlaetze());
		
		Wagen W3 = new Wagen(60, 110);
        Wagen W4 = new Wagen(20, 45);

        U9.addWagen (W3);
		U9.addWagen (W4);

        U9.removeWagen ();
		U9.removeWagen ();
        U9.removeWagen ();
        U9.removeWagen ();
        U9.removeWagen ();

}


}"
Name_107,VName_107,"public class UBahnDemo {
	
	public static void main(String[] args) {
		UBahn ubahn = new UBahn();
		Wagen wagen1 = new Wagen(5, 10);
		Wagen wagen2 = new Wagen(3, 2);
		
		ubahn.addWagen(wagen1);
		ubahn.addWagen(wagen2);
		
		System.out.println(ubahn.getSitzPlaetze());
		System.out.println(ubahn.getStehPlaetze());
		System.out.println(ubahn.getAllePlaetze());
		
		ubahn.addWagen(wagen1);
		ubahn.addWagen(wagen2);
		
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
		ubahn.removeWagen();
	}
}","/**
    * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
    * uebergeben bekommt und die entsprechenden Attribute setzt. 
    * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
    * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
    * wird mathematisch korrekt behandelt. 
    * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
    * auf Eins gesetzt.
    * Jeder erzeugte Bruch wird gekuerzt 
    * (dazu soll die entsprechende Mehode s.u. verwendet werden).
    */
   public Fraction(int numerator, int denominator) {
	   
	   if (denominator < 0) {
       	this.numerator = - numerator;
	   	this.denominator = denominator;
		} else if (denominator == 0) {
			this.denominator = 1;
		} else {
			this.numerator = numerator;
			this.denominator = denominator;
		}
   }

   /**
    * Gibt den Nenner zurueck.
    */
   public int getDenominator() {
	   return denominator;
       
   }

   /**
    * Gibt den Zaehler zurueck.
    */
   public int getNumerator() {
	   return numerator;
       
   }

   /**
    * Gibt den Bruch als Gleitkommazahl zurueck.
    */
   public double toDouble() {
	   double n = this.numerator;
	   double d = this.denominator;
	   double f = n/d;
       return f;
   }

   /**
    * Gibt einen String im Format
    * ""Zaehler/Nenner"" zurueck.
    */
   public String toString() {
	   return (numerator+""/""+denominator);
       
   }

   /**
    * Kuerzt (vereinfacht) den Bruch.
    */
   public void shorten() {
	   int gcd = GCD(this.numerator, this.denominator);
	   this.numerator = this.numerator/gcd;
	   this.denominator = this.denominator/gcd;
       
   }

   /**
    * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
    */
   public Fraction add(Fraction f) {
	   Fraction added = new Fraction(1,1);
	   int z1 = this.numerator * f.denominator;
	   int z2 = f.numerator * this.denominator;
	   added.denominator = this.denominator * f.denominator;
	   added.numerator = z1 + z2;
	   added.shorten();
	   return added;
	      
   }

   /**
    * Multipliziert den uebergebenen Bruch.
    */
   public Fraction multiply(Fraction f) {
	   Fraction multiplied = new Fraction(1,1);
	   multiplied.numerator = this.numerator * f.numerator;
	   multiplied.denominator = this.denominator * f.denominator;
	   multiplied.shorten();
	   return multiplied;
       
   }

   /**
    * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
    */
   public Fraction reciprocal() {
	   if (this.numerator != 0) {
		   int n = this.numerator;
		   int d = this.denominator;
		   this.numerator = d;
		   this.denominator = n;	   
	   }
	   return this;
      
   }
   
   /**
    * Dividiert den uebergebenen Bruch 
    * (unter Verwendung von Kehrwert und Multiplikation).
    */
   public Fraction divide(Fraction f) {
	  return this.multiply(f.reciprocal());
      
   }
   
}"
Name_407,VName_407,"public class UBahnDemo {
    public static void main(String[] args) {
        UBahn u9 = new UBahn();
        Wagen u9_w1 = new Wagen(20, 30);
        u9.addWagen(u9_w1);
        Wagen u9_w2 = new Wagen(10, 40);
        u9.addWagen(u9_w2);
        System.out.println(""Sitzplaetze in der U9: "" + u9.getSitzPlaetze());
        System.out.println(""Stehplaetze in der U9: "" + u9.getStehPlaetze());
        System.out.println(""Alle Plaetze in der U9: "" + u9.getAllePlaetze());
        u9.addWagen(u9_w1);
        u9.addWagen(u9_w2);
        for (int i=0; i<5; i++)
            u9.removeWagen();
    }
}","public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            denominator *= -1;
            numerator *= -1;
        }
        else if (denominator == 0) {
            denominator = 1;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();
    }


    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return numerator/(double) denominator;
    }

    public String toString() {
        return ("""" + numerator + ""/"" + denominator);
    }

    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    public Fraction add(Fraction f) {
        int lcm = LCM(f.getDenominator(), this.denominator);
        int n = (lcm/this.denominator) * this.numerator + (lcm/f.getDenominator()) * f.getNumerator();
        Fraction result = new Fraction(n, lcm);
        return result;
    }

    public Fraction multiply(Fraction f) {
        Fraction result = new Fraction(f.getNumerator()*this.numerator, f.getDenominator()*this.denominator);
        return result;
    }

    public Fraction reciprocal() {
        return new Fraction(denominator, numerator);
    }

    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }"
Name_408,VName_408,"public Fraction(int numerator, int denominator) {
        if (denominator < 0) {
            denominator *= -1;
            numerator *= -1;
        }
        else if (denominator == 0) {
            denominator = 1;
        }
        this.numerator = numerator;
        this.denominator = denominator;
        shorten();
    }


    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return numerator/(double) denominator;
    }

    public String toString() {
        return ("""" + numerator + ""/"" + denominator);
    }

    public void shorten() {
        int gcd = GCD(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
    }

    public Fraction add(Fraction f) {
        int lcm = LCM(f.getDenominator(), this.denominator);
        int n = (lcm/this.denominator) * this.numerator + (lcm/f.getDenominator()) * f.getNumerator();
        Fraction result = new Fraction(n, lcm);
        return result;
    }

    public Fraction multiply(Fraction f) {
        Fraction result = new Fraction(f.getNumerator()*this.numerator, f.getDenominator()*this.denominator);
        return result;
    }

    public Fraction reciprocal() {
        return new Fraction(denominator, numerator);
    }

    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }","public class UBahnDemo {
    public static void main(String[] args) {
        UBahn u9 = new UBahn();
        Wagen u9_w1 = new Wagen(20, 30);
        u9.addWagen(u9_w1);
        Wagen u9_w2 = new Wagen(10, 40);
        u9.addWagen(u9_w2);
        System.out.println(""Sitzplaetze in der U9: "" + u9.getSitzPlaetze());
        System.out.println(""Stehplaetze in der U9: "" + u9.getStehPlaetze());
        System.out.println(""Alle Plaetze in der U9: "" + u9.getAllePlaetze());
        u9.addWagen(u9_w1);
        u9.addWagen(u9_w2);
        for (int i=0; i<5; i++)
            u9.removeWagen();
    }
}"
Name_409,VName_409,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {
      public static void main ( String[] args){
      
      UBahn u5 = new UBahn();
      Wagen w1 = new Wagen (30, 40);
      Wagen w2 = new Wagen (35, 50);
      u5.addWagen(w1);
      u5.addWagen(w2);
      
      System.out.println(""Anzahl der Sitzplätze: "" +u5.getSitzPlaetze()+ ""\nAnzahl der StehPlätze: ""+u5.getStehPlaetze()+ ""\nAnzahl aller Plätze: "" +u5.getAllePlaetze());
      
      Wagen w3 = new Wagen (25, 34);
      Wagen w4 = new Wagen (40,60);
      u5.addWagen(w3);
      u5.addWagen(w4);
      u5.removeWagen();
      u5.removeWagen();
      u5.removeWagen();
      u5.removeWagen();
      u5.removeWagen();
     }
}"
Name_410,VName_410,"class UBahnDemo {

    public static void main(String[] args) {

    UBahn TestBahn = new UBahn();
    TestBahn.addWagen(66, 122);
    TestBahn.addWagen(99, 68);
    System.out.println(TestBahn.getSitzPlaetze());
    System.out.println(TestBahn.getStehPlaetze());
    System.out.println(TestBahn.getAllePlaetze());
    TestBahn.addWagen(13, 15);
    TestBahn.addWagen(14, 16);
    TestBahn.removeWagen();
    TestBahn.removeWagen();
    TestBahn.removeWagen();
    TestBahn.removeWagen();
    TestBahn.removeWagen();
    }

}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt.
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt.
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

    this.numerator=numerator;
    this.denominator=denominator;
    if (denominator<0) {denominator-=denominator*2;}

    if (denominator==0) {denominator=1;}
    Fraction.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
    return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
    return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
    double BB = numerator/denominator;
    return BB;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
    String SS = numerator+'/'+denominator;
    Return SS;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
    int THISGCD=GCD(numerator, denominator);
    numerator+=numerator/THISGCD;
    denominator+=denominator/THISGCD;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    int THISLCM = LCM(this.denominator, f.denominator);
    int Erweitthis = THISLCM/this.denominator;
    int Erweitf = THISLCM/f.denominator;
    int Frac1 = Erweitthis + Erweitf;
    Fraction Returning = new Fraction(Frac1, THISLCM);
    return Returning;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
    int mult1 = this.numerator*f.numerator;
    int mult2 = this.denominator*f.denominator;
    Fraction Returning = new Fraction(mult1, mult2);
    return Returning;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
    if(numerator!=0) {
    int temp = numerator;
    int temp2 = denominator;
    Fraction Returning = new Fraction(temp1, temp2);
    return Returning;
    }
    else {
    return null;
    }
    }

    /**
     * Dividiert den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    Fraction bro1 = new Fraction(f.reciprocal());
    Fraction bro2 = new Fraction(Fraction.multiply(bro1));
    return bro2;
    }

}"
Name_411,VName_411,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
     if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        } else if (numerator <0 && denominator<0){
            this.numerator = Math.negateExact(numerator);
            this.denominator = Math.negateExact(denominator);
        } else if(denominator <0 && numerator >0){
            this.denominator = denominator;
            this.numerator = numerator;
        } else {
            this.denominator = denominator;
            this.numerator = numerator;
        }

        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         return (double) this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return this.numerator+""/""+this.denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int i = GCD(this.numerator,this.denominator);
        this.numerator = this.numerator/i;
        this.denominator = this.denominator/i;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int i = LCM(this.denominator,f.getDenominator()); 
        int a = ((this.numerator*f.getDenominator())+(f.getNumerator()*this.denominator))/i;
        return new Fraction(a,i);
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int i = this.numerator*f.getNumerator();
        int j = this. denominator*f.getDenominator();
        return new Fraction(i,j);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       return new Fraction(this.denominator,this.numerator);
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return new Fraction (this.multiply(f.reciprocal()).numerator,this.multiply(f.reciprocal()).denominator);
    }","public class UBahnDemo {

    public static void main(String [] args){
        UBahn bahn = new UBahn();
        bahn.addWagen(new Wagen(7,3));
        bahn.addWagen(new Wagen(5,2));

        System.out.println(bahn.getSitzPlaetze());
        System.out.println(bahn.getStehPlaetze());
        System.out.println(bahn.getAllePlaetze());


        bahn.addWagen(new Wagen(4,3));
        bahn.addWagen(new Wagen(1,2));

        bahn.removeWagen();
        bahn.removeWagen();
        bahn.removeWagen();
        bahn.removeWagen();
        bahn.removeWagen();

    }
}"
Name_412,VName_412,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if(numerator < 0) {
            this.numerator = -numerator;
        }
        if(numerator >= 0) {
            this.numerator = numerator;
        }
        if(denominator < 0) {
            this.denominator = -denominator;
        }
        if(denominator == 0) {
            this.denominator = 1;
        }
        if(denominator > 0) {
            this.denominator = denominator;
        }
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;   
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;    
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double temp = numerator*1.0/denominator;
        return temp;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (numerator+""/""+denominator);
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int temp = GCD(this.numerator,this.denominator);
        this.numerator = this.numerator/temp;
        this.denominator = this.denominator/temp;
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        Fraction temp = new Fraction(this.numerator,this.denominator);
        temp.denominator = LCM(this.denominator, f.denominator);
        temp.numerator = (this.numerator*(temp.denominator/this.denominator) + f.numerator*(temp.denominator/f.denominator));
        temp.shorten();
        return temp;
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction temp = new Fraction((this.numerator*f.numerator),(this.denominator*f.denominator));
        temp.shorten();
        return temp;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        Fraction temp = new Fraction(this.numerator,this.denominator);
        if(temp.numerator != 0) {
            int temp1 = this.numerator;
            temp.numerator = this.denominator;
            temp.denominator = temp1;
        }
        temp.shorten();
        return temp;
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction temp = new Fraction(this.numerator,this.denominator);
        Fraction f_r = new Fraction(this.numerator,this.denominator);
        f_r = f.reciprocal();
        temp = this.multiply(f_r);
        temp.shorten();
        return temp;
       
    }",-
Name_413,VName_413,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_73,VName_73,"public class UBahnDemo {
	
	public static void main(String args[]) {
	    Wagen w1 = new Wagen();
		UBahn u1 = new UBahn();
		u1.addWagen(2);
		u1.removeWagen(5);
	}

}
//Hier soll die Klasse UBahnDemo stehen!","int x;
  int y;
   public Fraction(int numerator, int denominator) {
    	x = numerator;       
    	y = denominator;
    }


    public int getDenominator() {
    	return denominator;
    }


    public int getNumerator() {
    	return numerator;
        
    }


    public double toDouble() {
    	return (double)x/y;
        
    }


    public String toString() {    	
    	return x + ""/"" + y;
    }


    public void shorten() {
    	if(x == 0 || y == 1) return;
    	double gcd = GCD(x,y);
    	this.x /= gcd;
    	this.y /= gcd;
        
    }

    public Fraction add(Fraction f) {
    	int y1 = LCM(y,f.y);
    	int x1 = x*(y1/y)+f.x*(y1/f.y);
    	double gcd = GCD(x,y);
    	y1 /= gcd;
    	x1 /= gcd;
    	Fraction p =new Fraction(x1,y1);
    	return p;
    	
    }

    public Fraction multiply(Fraction f) {
    	int x1 = x*f.x;
    	int y1 = y*f.y;
    	double gcd = GCD(x,y);
    	x1 /= gcd;
    	y1 /= gcd;
    	Fraction p = new Fraction(x1,y1);
    	return p;
        
    }

    public Fraction reciprocal() {
    	return new Fraction(y,x);
       
    }
    
    public Fraction divide(Fraction f) {
    	if(f.getDenominator()==0){
    		y = 1;
    	}
    	int x1 = x*f.y;
    	int y1 = y*f.x;
    	Fraction p = new Fraction(x1,y1);
    	return p;
    	
    }"
Name_414,VName_414,//Hier soll die Klasse UBahnDemo stehen!,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_415,VName_415,"public Fraction(int numerator, int denominator) {
		this.numerator=numerator;
		this.denominator=denominator;

		if (this.numerator<0 && this.denominator<0){
			this.numerator=(-1)*this.numerator;
			this.denominator=(-1)*this.denominator;
		}
		else if (this.denominator<0){
			this.numerator=(-1)*this.numerator;
			this.denominator=(-1)*this.denominator;
		}

		if (this.denominator==0){
			this.denominator=1;
		}
		
	
	}
		

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return denominator;
        
    }
	
	public void setDenominator(int d){
		this.denominator=d;
	}

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
		return numerator;
        
    }
	
	public void setNumerator(int n){
		this.numerator=n;
	}

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {

		double d = (double) this.numerator/this.denominator;
		return d;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		String frac = this.numerator + ""/"" + this.denominator;
        return frac;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
	 
    public void shorten() {
		
		while(GCD(this.numerator,this.denominator)>1){
			int factor = GCD(this.numerator,this.denominator);
			this.numerator/=factor;
			this.denominator/=factor;
		}
		
		if (this.numerator<0 && this.denominator<0){
			this.numerator=(-1)*this.numerator;
			this.denominator=(-1)*this.denominator;
		}	

		if (this.denominator<0){
			this.numerator=(-1)*this.numerator;
			this.denominator=(-1)*this.denominator;
		}
		if(this.numerator<0){
			int factor = GCD((-1)*this.numerator,this.denominator);
			this.numerator/=(factor);
			this.denominator/=factor;
			
		}
		
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		
		int numerator=0;
		int denominator=0;
		Fraction ans= new Fraction(numerator,denominator);
		
		int lcm = LCM(this.denominator,f.denominator);
		ans.setDenominator(lcm);
		
		int m1 = lcm/this.denominator;
		int m2 = lcm/f.denominator;
		
		ans.setNumerator((m1*this.numerator) + (m2*f.numerator));
		
		ans.shorten();
		
		return ans;
		
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
		
		int numerator=0;
		int denominator=0;
		Fraction ans = new Fraction(numerator,denominator);
		
        ans.setNumerator(this.numerator*f.getNumerator());
		ans.setDenominator(this.denominator*f.getDenominator());
		
		ans.shorten();
		
		return ans;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		
		int numerator=0;
		int denominator=0;
		Fraction rec = new Fraction(numerator,denominator);
		shorten();
		
	   rec.setNumerator(this.denominator);
	   rec.setDenominator(this.numerator);
		
		if (this.numerator<0){
			rec.setNumerator((-1)*this.denominator);
			rec.setDenominator((-1)*this.numerator);
		}
        if (this.numerator==0){
			rec.setNumerator(this.numerator);
			rec.setDenominator(this.denominator);
		}

	   	   
	   return rec;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		
		int numerator=0;
		int denominator=0;
		Fraction ans = new Fraction(numerator,denominator);

		ans.setDenominator(f.multiply(f.reciprocal()).denominator);
		ans.setNumerator(f.multiply(f.reciprocal()).numerator);
		
		ans.shorten();
		
		return ans;
       
    }","public class UBahnDemo{
	
	public static void main (String[] args){
		
		UBahn tube = new UBahn();
		
		Wagen w1 = new Wagen (13,234);
		Wagen w2 = new Wagen (133,24);
		
		tube.addWagen(w1);
		tube.addWagen(w2);
		
		System.out.println(tube.getSitzPlaetze());
		
		System.out.println(tube.getStehPlaetze());
		
		System.out.println(tube.getAllePlaetze());
		
		tube.addWagen(w1);
		tube.addWagen(w2);
		
		tube.removeWagen();
		tube.removeWagen();
		tube.removeWagen();		
		tube.removeWagen();
		tube.removeWagen();
	}
	
}"
Name_416,VName_416,"public class UBahnDemo {

       public static void main(String[] args) {
        
       UBahn ubahn=new UBahn();
        
        ubahn.addWagen(new Wagen(3,5));
        ubahn.addWagen(new Wagen(1,2));
        
        System.out.println(""Total Sitzplaetze: ""+ubahn.getSitzPlaetze());
        System.out.println(""Total Stehplaetze: ""+ubahn.getStehPlaetze());
        System.out.println(""Total Plaetze: ""+ubahn.getAllePlaetze());
        
        ubahn.addWagen(new Wagen(1,6));
        ubahn.addWagen(new Wagen(4,8));
        
        for(int i=0;i<5;i++)
            ubahn.removeWagen();
        
        
    }
    
}","public Fraction(int g, int h) {
numerator = g;
denominator= h;
if(h==0){
h = 1;}
shorten(g,h);
        
    }

 
    public int getDenominator() {
        return this.denominator;
    }

    public int getNumerator() {
     return this.numerator;
        
    }


    public double toDouble() {    
   Double num= doubleValue  (numerator);
Double denm =doubleValue (denominator);
    Double ergebnis = num/denm ;
    return ergebnis;

          }


    public String toString() {
return this.numerator + ""/"" + this.denominator;    }


   
    public void shorten(int numerator,int denominator) {
     int u = GCD(numerator,denominator);
     numerator/= u;
     denominator /= u;
        
    }

    public Fraction add(Fraction f) {
int numer = (numerator * f.getDenominator()) + 
                            (f.getNumerator() * denominator);
	int denr = denominator * f.getDenominator();
	return new Fraction(numer, denr);
       
    }

   
    public Fraction multiply(Fraction f) {
        
       int d= numerator*f.getNumerator();
       int g= f.denominator*f.getDenominator();
        Fraction result = new Fraction(d,g);
        return result;
    }

    public Fraction reciprocal() {
      
 if(numerator != 0){
      int newnumerator = denominator;
      int newdenominator = numerator; 
      Fraction neu = new Fraction(newnumerator,
       newdenominator);
return neu;
          
}else{ Fraction neu=null;

return neu;}
    }
    
  
    public Fraction divide(Fraction f) {
int newNumerator = numerator * f.getDenominator();
	int newDenominator = denominator * f.numerator;
	Fraction result = new Fraction(newNumerator, newDenominator);
	return result;    }"
Name_417,VName_417,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
	    this.numerator = numerator;
    	this.denominator = denominator;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
	    return numerator;        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
	double i;
	double r = this.numerator;
	double t = this.denominator;
	i = r / t;  
	return i;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
    	String s = this.numerator + ""/"" + this.denominator;
	    return s;    
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
	int sh = GCD(denominator, numerator); 
	denominator = denominator / sh; 
	numerator = numerator / sh;          
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
    int nu1 = this.numerator;
	int de1 = this.denominator;
	int nu2 = f.numerator;
	int de2 = f.denominator;
	int g; 
	int nu3;
	g = LCM(de1, de2);
	nu1 = nu1 * (g / de1);
	nu2 = nu2 * (g / de2); 
	nu3 = nu1 + nu2;
	Fraction a = new Fraction(nu3, g);
	return a;

    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
	int n1 = this.numerator;
	int d1 = this.denominator;
	int n2 = f.numerator;
	int d2 = f.denominator;
	int n3;
	int d3;
	n3 = n1 * n2; 
	d3 = d1 * d2;
	Fraction e = new Fraction(n3, d3);
	return e;       
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
	int ne1 = this.numerator;
	int du1 = this.denominator;
	int v; 
	v = ne1;
	ne1 = du1;
	du1 = v;
	Fraction c = new Fraction(du1, ne1); 
	return c;     
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
	int n1 = this.numerator;
	int d1 = this.denominator;
	int n2 = f.numerator;
	int d2 = f.denominator;	
	int d3;
	int n3; 
	d3 = n1 * d2; 
	n3 = n2 * d1; 
	Fraction v = new Fraction(n3,d3);
	return v; 
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {
	public static void main(String[] args){
	UBahn u = new UBahn(); 
	Wagen c = new Wagen(25,10); 
	Wagen d = new Wagen(43,30);
	Wagen e = new Wagen(38, 40);
	Wagen f = new Wagen(52, 35);
	u.addWagen(d);
	u.addWagen(c); 
	System.out.println(u.getSitzPlaetze());
	System.out.println(u.getStehPlaetze());
	System.out.println(u.getAllePlaetze());
	u.addWagen(e);
	u.addWagen(f);	
	
	for (int i = 0; i < 5; i++) {
	u.removeWagen();
	}
	}
	
}"
Name_70,VName_70,"//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo {

    public static void main(String[] args) {
        UBahn u1 = new UBahn();

        Wagen w1 = new Wagen(5,5);
        Wagen w2 = new Wagen(2,2);

        u1.addWagen(w1);
        u1.addWagen(w2);

        System.out.println(""U1 hat:"");
        System.out.println(""Stehplätze:"" + u1.getStehPlaetze());
        System.out.println(""Sitzplätze: "" + u1.getSitzPlaetze());
        System.out.println(""Gesamat: "" + u1.getAllePlaetze());

        Wagen w3 = new Wagen(1,1);
        Wagen w4 = new Wagen(3,3);

        u1.addWagen(w3);
        u1.addWagen(w4);

        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();

    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {

        if(denominator < 0 && numerator < 0) {
            this.denominator = -denominator;
            this.numerator = -numerator;
        } else if(denominator == 0){
            this.denominator = 1;
            this.numerator = numerator;
        } else {
            this.denominator = denominator;
            this.numerator = numerator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (this.numerator/this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return (this.getNumerator() + ""/"" + this.getDenominator());
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt = this.GCD(this.denominator, this.numerator);

        this.denominator = this.denominator / ggt;
        this.numerator = this.numerator / ggt;

        if(this.denominator < 0) {
            this.numerator = -this.numerator;
            this.denominator = -this.denominator;
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int kgv = LCM(this.denominator, f.denominator);

        int erweiterung_this = kgv/this.denominator;
        int erweiterung_f = kgv/f.denominator;

        int zneu_this = erweiterung_this* this.numerator;
        int zneu_f = erweiterung_f * f.numerator;

         Fraction temp = new Fraction((zneu_this+zneu_f),kgv);

         return temp;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {

        Fraction temp = new Fraction(this.numerator*f.numerator, this.denominator*f.denominator);
        temp.shorten();
        return temp;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        Fraction temp = new Fraction(this.denominator, this.numerator);
        return temp;
    }

    /**
     * Dividiert den uebergebenen Bruch
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        return this.multiply(f.reciprocal());
    }"
Name_418,VName_418,"public class UBahnDemo {
	public static void main (String[] args) {
	UBahn u7 = new UBahn();
	Wagen w1 = new Wagen(20,30);
	Wagen w2 = new Wagen(15,40);
	Wagen w3 = new Wagen(20,30);
	Wagen w4 = new Wagen(15,40);
	u7.addWagen(w1);
	u7.addWagen(w2);
    System.out.println(u7.getSitzPlaetze());
	System.out.println(u7.getStehPlaetze());
	System.out.println(u7.getAllePlaetze());
	u7.addWagen(w3);
	u7.addWagen(w4);
	u7.removeWagen();
	u7.removeWagen();
	u7.removeWagen();
	u7.removeWagen();
	u7.removeWagen();
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
		 this.denominator = denominator;
		 this.getNumerator();
		 this.getDenominator();
		 this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        if(denominator==0) {
			denominator = 1;
		}
		else if (denominator <= 0) {
			denominator*=-1;
		}
		return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        if(numerator<0 && denominator<0) {
    	 numerator = numerator*-1;
    	 }
    	else if(numerator>0 && denominator<0) {
    		numerator = numerator*-1;
    	}
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
         double gleitbruch = (double)numerator/denominator;
		return gleitbruch;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String br = this.numerator+""/""+this.denominator;
		return br;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int teiler = GCD(this.numerator,this.denominator);
		this.numerator = this.numerator/teiler;
		this.denominator = this.denominator/teiler;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int vielfach = LCM(this.denominator,f.denominator);
		int denominator2 = vielfach;
		int faktor1 = vielfach/this.denominator;
		int faktor2 = vielfach/f.denominator;
		int numerator2 = this.numerator*faktor1 + f.numerator*faktor2;
		return new Fraction(numerator2,denominator2);
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int numerator2 = f.numerator*this.numerator;
		int denominator2 = f.denominator*this.denominator;
		return new Fraction(numerator2, denominator2);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if (this.numerator != 0) {
			return new Fraction(this.denominator,this.numerator);
		}
		else{
			return new Fraction(this.numerator,this.denominator);
		}
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction b1 = this.reciprocal();
		Fraction b2 = b1.multiply(f);
     	return new Fraction(b1.numerator,b1.denominator);
    }"
Name_419,VName_419,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }",-
Name_420,VName_420,"public class UBahnDemo {
    public static void main (String[]args){
    UBahn b1= new UBahn();
    Wagen [] u= new Wagen[2];
    u[0].Sitzplaetze=123;
    b1.addWagen(403,234);
    b1.addWagen(234,452);
    System.out.println(""Gesamt Stehplätze: ""+b1.getStehPlaetze());
    System.out.println(""Gesamt Sitzplätze: ""+b1.getSitzPlaetze());
    System.out.println(""Gesamte Plätze""+b1.getAllePlaetze());
    b1.addWagen(412,643);
    b1.addWagen(324,352);
    b1.removeWagen();
    b1.removeWagen();
    b1.removeWagen();
    b1.removeWagen();
    b1.removeWagen();

}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_421,VName_421,"//Hier soll die Klasse UBahnDemo stehen!public class UBahnDemo {
public class UBahnDemo {
    
    public static void main(String[] args){
    UBahn u1 = new UBahn();
    Wagen w1 = new Wagen(94,206);
    Wagen w2 = new Wagen(150,150);
    Wagen w3 = new Wagen(200,100);
    Wagen w4 = new Wagen(100,200);

    u1.addWagen(w1);
    u1.addWagen(w2);


    System.out.println(u1.getSitzPlaetze());
    System.out.println(u1.getStehPlaetze());
    System.out.println(u1.getAllePlaetze());

        u1.addWagen(w3);
        u1.addWagen(w4);

        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        
    }
    }","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
       
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
this.denominator = denominator;

    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator/(double) denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(denominator, numerator);
    this.denominator /= gcd;
    this.numerator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int lcm = LCM(denominator, f.getDenominator());
        return new Fraction(numerator*(lcm/denominator) + f.getNumerator()*(lcm/f.getDenominator()), lcm);
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(numerator*f.getNumerator(), denominator*f.getDenominator());
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if (numerator != 0) {
    return new Fraction(denominator, numerator);
    }
    return new Fraction(denominator,1);
    }
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return f.reciprocal().multiply(this);
    }"
Name_422,VName_422,"//Hier soll die Klasse UBahnDemo stehen!
class UBahnDemo {
    public static void main(String[] args){
        UBahn u1 = new UBahn();
        Wagen w1 = new Wagen(5,10);
        Wagen w2 = new Wagen(1,8);
        Wagen w3 = new Wagen(7,7);
        Wagen w4 = new Wagen (9,9);

        u1.addWagen(w1);
        u1.addWagen(w2);

        System.out.println(u1.getSitzPlaetze());
        System.out.println(u1.getStehPlaetze());
        System.out.println(u1.getAllePlaetze());

        u1.addWagen(w3);
        u1.addWagen(w4);

        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();

    }


}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
  public Fraction(int numerator, int denominator) {

      if(denominator<0){

          this.numerator = (-1)*numerator;
          this.denominator = (-1)*denominator;
          }
      else if(denominator==0){
          this.numerator = numerator;
          this.denominator = 1;
          }
      else{
          this.numerator = numerator;
          this.denominator = denominator;
      }

            this.shorten();




  }

  /**
   * Gibt den Nenner zurueck.
   */
  public int getDenominator() {
      return this.denominator;

  }

  /**
   * Gibt den Zaehler zurueck.
   */
  public int getNumerator() {
      return this.numerator;
  }

  /**
   * Gibt den Bruch als Gleitkommazahl zurueck.
   */
  public double toDouble() {
      return (double)numerator/(double)denominator;
    }

  /**
   * Gibt einen String im Format
   * ""Zaehler/Nenner"" zurueck.
   */
  public String toString() {
      return Integer.toString(numerator)+""/""+Integer.toString(denominator);

  }

  /**
   * Kuerzt (vereinfacht) den Bruch.
   */
  public void shorten() {
      int a = GCD(this.denominator,this.numerator);
      if(a<0){a*=-1;}
      this.denominator = this.denominator/a;
      this.numerator = this.numerator/a;
  }

  /**
   * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
   */
  public Fraction add(Fraction f) {
      int a = LCM(f.denominator,this.denominator);
      if(a<0){a*=-1;}
      Fraction thisfrac = new Fraction(this.numerator,this.denominator);
      f.numerator = f.numerator*(a/f.denominator);
      thisfrac.numerator = thisfrac.numerator*(a/thisfrac.denominator);

      Fraction sum = new Fraction(f.numerator+thisfrac.numerator,a);
      return sum;


  }

  /**
   * Multipliziert den uebergebenen Bruch.
   */
  public Fraction multiply(Fraction f) {
      Fraction mul = new Fraction(f.numerator*this.numerator, f.denominator*this.denominator);
      return mul;
  }

  /**
   * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
   */
  public Fraction reciprocal() {
      if(this.numerator!=0){
          Fraction rec = new Fraction(this.denominator,this.numerator);
          return rec;
      }
      else return this;

  }

  /**
   * Dividiert den uebergebenen Bruch
   * (unter Verwendung von Kehrwert und Multiplikation).
   */
  public Fraction divide(Fraction f) {
      return this.multiply(f.reciprocal());

  }"
Name_423,VName_423,"//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo{
	public static void main(String[] args){
		UBahn u1 = new UBahn();
		u1.addWagen(new Wagen(2,3));
		u1.addWagen(new Wagen(3,1));
		System.out.println(u1.getSitzPlaetze()+"" ""+ u1.getStehPlaetze()+ "" "" + u1.getAllePlaetze());
		u1.addWagen(new Wagen(1,1));
		u1.addWagen(new Wagen(2,2));
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
	}
}","public Fraction(int numerator, int denominator) {
		if(denominator==0){
			denominator=1;
		};
		if(denominator<0){
			this.numerator = -1*numerator;
			this.denominator = -1*denominator;
		}else{
			this.numerator = numerator;
			this.denominator = denominator;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)this.numerator/this.denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {

		String a = this.numerator + ""/""+ this.denominator;
        return a;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = this.GCD(this.numerator,this.denominator);
		this.numerator = this.numerator/gcd;
		this.denominator = this.denominator/gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		Fraction x = new Fraction(f.getNumerator()*this.denominator+this.numerator*f.getDenominator(),f.getDenominator()*this.denominator);
		return x;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction x = new Fraction(f.getNumerator()*this.numerator,f.getDenominator()*this.denominator);
		return x;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
		
		if(this.numerator!=0){
			Fraction x = new Fraction(this.denominator,this.numerator);
			return x;
		}else{
			Fraction x = new Fraction(this.numerator,this.denominator);
			return x;
		}
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       Fraction x = new Fraction(this.numerator*f.getDenominator(),this.denominator*f.getNumerator());
		return x;
    }"
Name_424,VName_424,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */

    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
        if(denominator == 0)
        {
            this.denominator = 1;
        }
        if(denominator<0)
		{
			this.denominator*=-1;
			this.numerator*=-1;
		}
		shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double e = (double)this.numerator/(double)this.denominator;
		return e;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return numerator+""/""+denominator;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int kuerzer = GCD(this.numerator, this.denominator);
		numerator/=kuerzer;
		denominator/=kuerzer;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int newNenner = this.denominator*f.denominator;
	    int newZaehler = this.numerator+f.numerator;
		Fraction neu = new Fraction(newZaehler, newNenner);
		neu.shorten();
		return neu;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        int newZaehler = this.numerator*f.numerator;
		int newNenner = this.denominator*f.denominator;
		Fraction neu = new Fraction(newZaehler, newNenner);
		neu.shorten();
		return neu;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        int newZaehler = this.denominator;
		int newNenner = this.numerator;
		Fraction neu = new Fraction(newZaehler, newNenner);
		return neu;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction neu = f.reciprocal();
		Fraction neuer = new Fraction(this.numerator, this.denominator);
		Fraction neurer = neuer.multiply(neu);
		return neurer; 
    }","//Hier soll die Klasse UBahnDemo stehen!
public class UBahnDemo{
    public static void main(String args[])
    {
        UBahn neu = new UBahn();
        Wagen w1 = new Wagen(23, 52);
        Wagen w2 = new Wagen(46, 77);
        neu.addWagen(w1);
        neu.addWagen(w2);
        System.out.println(""Stehplaetze: ""+neu.getStehPlaetze()+""\nSitzplaetze: ""+neu.getSitzPlaetze()+""\nalle Plätze: ""+neu.getAllePlaetze());
        Wagen w3 = new Wagen(47, 72);
        Wagen w4 = new Wagen(18, 89);
        neu.addWagen(w3);
        neu.addWagen(w4);
        for(int i = 1; i<=5; i++)
        {
            neu.removeWagen();
        }
    }
}"
Name_425,VName_425,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        int numerator = z;
        int denominator = n;
        this.numerator = z;
        this.denominator = n;
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return(this.numerator % this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return String(this.numerator +"" / ""+ this.denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int numerator = z;
        int denominator = n;
        while(z != 0) {
            z = z / GCD();
            z = z / GCD();
            if(n < 0){
                z = -z;
                n = -n;
            }
        }
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int z1 = this.numerator * f.denominator;
        int z2 = f.numerator * this.denominator;
        int n = this.denominator * f.denominator;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        return new Fraction(this.numerator * f.numerator, this.denominator * f.denominator);
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        int numerator = z;
        int denominator = n;
        if(numerator != 0) {
        int tmp=z;
        z=n;
        n=tmp;
       }
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
    
    }","public class UBahnDemo{
    	public static void main(String[] args){
	addWagen(17, 34, 51);
	addWagen(1, 2, 3);
	get.SitzPlaetze;
	get.Stehplaetze;
	get.AllePlaetze;
	addWagen(1,1,1);
	addWagen(1,1,1);
	removeWagen;
	removeWagen;
	removeWagen;
	removeWagen;
	removeWagen;
	
    }

}"
Name_426,VName_426,"public class UBahnDemo {
    public static void main(String[] args) {
        UBahn u1 = new UBahn(w1(100,80), 1);
        w2(50,20).addWagen;
        w3(300,180).addWagen;
        u1.getSitzPlaetze;
        u1.getStehPlaetze;
        u1.getAllePlaetze;
        w4(400,200).addWagen;
        w5(30,10).addWagen;
        removeWagen;
        removeWagen;
        removeWagen;
        removeWagen;
        removeWagen;
    }
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator=numerator;
        this.denominator=denominator;
        if (denominator < 0) {
            numerator = numerator * (-1);
            denominator = denominator * (-1);
        }
        if (denominator==0) {
            denominator = denominator+1;
        }
        shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        double a = this.numerator/this.denominator;
        return a;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String a = """"+this.numerator+""/""+this.denominator+"""";
        return a;
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int a = GCD(this.numerator, this.denominator);
        this.numerator = this.numerator/a;
        this.denominator = this.denominator/a;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int b = LCM(this.denominator, this.denominator);
       int a = (this.numerator*b)+(this.numerator*b);
       this.numerator = a;
       this.denominator = b;
       Fraction h = new Fraction(a,b);
       return h;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        this.numerator = this.numerator*f.numerator;
        this.denominator = this.denominator*f.denominator;
        Fraction h = new Fraction(this.numerator, this.denominator);
        return h;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if(this.numerator != 0) {
           int a = this.denominator;
           this.denominator = this.numerator;
           this.numerator = a;
       }
       Fraction h = new Fraction(this.numerator, this.denominator);
       return h;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       f.reciprocal();
       Fraction b = this.multiply(f);
       return b;
    }"
Name_282,VName_282,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
     public Fraction(int numerator, int denominator) {
        this.numerator = numerator; 
		this.denominator = denominator;
		if (this.denominator < 0){
			this.denominator = this.denominator * (-1);
			this.numerator = this.numerator * (-1);
		}
		if (this.denominator == 0){ 
		this.denominator = 1; 
		}
	
		
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
		return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.denominator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() { 
	double den =  Double.valueOf(this.denominator);
	double num = Double.valueOf(this.numerator);
	double doub = num/den;
	return doub;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        String str = +this.numerator+""/""+this.denominator;
		return str;
		
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		this.numerator = this.numerator/ gcd;
		this.denominator = this.denominator/ gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       int lcm = LCM(this.numerator, this.denominator);
	  f.numerator = this.numerator * lcm + f.numerator * lcm; 
	   f.denominator = this.denominator * lcm + f.denominator * lcm;
	   return f;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
       f.numerator = this.numerator *  f.numerator; 
	   f.denominator = this.denominator * f.denominator;
	   return f;
	   
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
	Fraction f = new Fraction(1,1);
	    f.numerator = this.denominator;
		f.denominator = this.numerator;
       return f;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		f.reciprocal();
        f.numerator = this.numerator *  f.numerator; 
	   f.denominator = this.denominator * f.denominator;
	   return f;
	   
    }","public class UBahndemo{
	public static void main (String[]args){
	UBahn a =  new UBahn(); 
	Wagen x = new Wagen(5,10);
	Wagen y = new Wagen(3,4);
	a.addWagen(x); 
	a.addWagen(y);
	
	System.out.println(+a.getSitzPlaetze()+ ""\n"" + a.getStehPlaetze() + ""\n"" + a.getAllePlaetze());
	
	Wagen z1 = new Wagen(4,6);
	Wagen z2 = new Wagen(1,1);
	a.addWagen(z1);
	a.addWagen(z2);
	
		for (int i=0; i<5; i++){
		a.removeWagen();
		}
	 
	}
}"
Name_427,VName_427,"public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        this.denominator = denominator;
         if( denominator == 0)
           denominator = 1;
          if (denominator < 0)
            numerator = numerator * -1;
            denominator = denominator * -1;
    }

    public int getDenominator() {
        return denominator;
    }

    public int getNumerator() {
        return numerator;
    }

    public double toDouble() {
        return (double) numerator / denominator ;
        
    }

  public String toString() {
     String buffer = numerator + ""/"" + denominator;
       return buffer;
    }

    public void shorten() {
         Fraction result = new Fraction();
           int common = 0;
           int num = Math.abs(numerator);
            int den = Math.abs(denominator);
          if (num > den)
         common = GCD(num, den);
          else if (num < den)
         common = GCD(den, num);
         else  
         common = num;
          result.numerator = numerator / common;
           result.denominator = denominator / common;
             return result;
        
    }

    public Fraction add(Fraction f) {
             int common = LCM(denominator, b.denominator);
             Fraction commonA = new Fraction();
             Fraction commonB = new Fraction();
               commonA = reciprocal(common);
               commonB = f.reciprocal(common);
            Fraction summe = new Fraction();
              summe.numerator = commonA.numerator + commonB.numerator;
              summe.denominator = common;
              summe = summe.shorten();
           return summe;

       
    }

   public Fraction multiply(Fraction f) {
           Fraction produkt = new Fraction();
           produkt.numerator = numerator * f.numerator;
            produkt.denominator = denominator * f.denominator;
              produkt = produkt.shorten();
               return produkt;
  }

        public Fraction reciprocal() {
         Fraction resultt = new Fraction();
         int factor = common / denominator;
         resultt.numerator = numerator * factor;
         resultt.denominator = common;
         resultt = resultt.shorten();
         return resultt;
        }
    
     public Fraction divide(Fraction f) {
      Fraction division = new Fraction();
       division.numerator = numerator * f.denominator;
       division.denominator = denominator * f.numerator;
       division = division.shorten();
       return division;
     }
 }","public class UBahnDemo {

       public static void main(String[] args) {
        
       UBahn ubahn=new UBahn();
        
        ubahn.addWagen(new Wagen(3,5));
        ubahn.addWagen(new Wagen(1,2));
        
        System.out.println(""Total Sitzplaetze: ""+ubahn.getSitzPlaetze());
        System.out.println(""Total Stehplaetze: ""+ubahn.getStehPlaetze());
        System.out.println(""Total Plaetze: ""+ubahn.getAllePlaetze());
        
        ubahn.addWagen(new Wagen(1,6));
        ubahn.addWagen(new Wagen(4,8));
        
        for(int i=0;i<5;i++)
            ubahn.removeWagen();
        
        
    }
    
}"
Name_428,VName_428,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
		if (denominator > 0){
			this.numerator = numerator;
			this.denominator = denominator;
		} else if (denominator == 0) {				
			this.numerator = numerator;
			this.denominator = 1;			
		} else {			
			this.numerator = numerator * -1;
			this.denominator = denominator * -1;
		}
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double)(this.numerator/this.denominator);
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
		String frac = this.numerator + ""/"" + this.denominator;
		return frac;
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
		if (gcd != 1) {
			this.numerator /= gcd;
			this.denominator /= gcd;
		}
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
		int lcm = LCM(this.denominator, f.getDenominator());
		int result_num = this.numerator * (lcm/this.denominator) + f.getNumerator() * lcm/f.getDenominator();
		int result_den = this.denominator * (lcm/this.denominator);
		
		if(result_den < 0){
			result_den *= -1;
			result_num *= -1;
		}
		Fraction result = new Fraction(result_num, result_den);
		result.shorten();
		return result;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {		
		int result_num = this.numerator * f.getNumerator();
		int result_den = this.denominator * f.getDenominator();
		Fraction result = new Fraction(result_num, result_den);
		result.shorten();
		return result;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {		
		int result_num = this.denominator;
		int result_den = this.numerator;
		if (result_den == 0){
			result_den = 1;
		}
		if(result_den < 0){
			result_den *= -1;
			result_num *= -1;
		}
		return new Fraction(result_num, result_den);       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
		Fraction div = this.reciprocal();
		return div.multiply(f);
    }","class UBahnDemo {
   public static void main(String[] args)  {
       UBahn ubahn = new UBahn();
       ubahn.addWagen(new Wagen(50,20));
       ubahn.addWagen(new Wagen(49,21));
       System.out.println(ubahn.getSitzPlaetze());
       System.out.println(ubahn.getStehPlaetze());
       System.out.println(ubahn.getAllePlaetze());
       ubahn.addWagen(new Wagen(1,1));
       ubahn.addWagen(new Wagen(10,15));
       ubahn.removeWagen();
       ubahn.removeWagen();
       ubahn.removeWagen();
       ubahn.removeWagen();
       ubahn.removeWagen();
   }                  
   }"
Name_429,VName_429,"public class UBahnDemo{

    public static void main(String[] args){

        UBahn u1 = new UBahn();
        Wagen w1 = new Wagen(20,70);
        Wagen w2 = new Wagen(15, 65);
        u1.addWagen(w1);
        u1.addWagen(w2);

        System.out.println(u1.getSitzPlaetze());
        System.out.println(u1.getStehPlaetze());
        System.out.println(u1.getAllePlaetze());

        Wagen w3 = new Wagen(15,45);
        Wagen w4 = new Wagen(30,35);

        u1.addWagen(w3);
        u1.addWagen(w4);

        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
        u1.removeWagen();
    }

}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        this.numerator = numerator;
        if(denominator < 0){
            this.denominator = denominator * -1;
            if (this.numerator < 0){
                this.numerator = numerator * -1;
            }
        } else if (denominator == 0){
            this.denominator = 1;
        } else {
            this.denominator = denominator;
        }
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) this.numerator / this.denominator;
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return Integer.toString(this.numerator) + ""/"" + Integer.toString(this.denominator);
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int gcd = GCD(this.numerator, this.denominator);
        this.numerator /= gcd;
        this.denominator /= gcd;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        Fraction sum = new Fraction(this.numerator, this.denominator);
        int lcm = LCM(this.denominator, f.getDenominator());
        sum.getNumerator() *= lcm;
        sum.getDenominator() *= lcm;
        f.getNumerator() *= lcm;
        f.getDenominator() *= lcm;
        sum.getNumerator() += f.getNumerator();
        sum.getDenominator() += f.getDenominator();
        return sum;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        Fraction product = new Fraction(this.numerator, this.denominator);
        product.getNumerator() *= f.getNumerator();
        product.getDenominator() *= f.getDenominator();
        return product;
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
        if(this.numerator != 0){
            Fraction kehrwert = new Fraction(this.denominator, this.numerator);
            return kehrwert;
        } else {
            System.out.println(""ERROR: Zaehler darf nicht 0 sein."");
            return this;
        }
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
        Fraction quotient = new Fraction(this.numerator, this.denominator);
        quotient.multiply(f.reciprocal());
        return quotient;
       
    }"
Name_430,VName_430,"class UBahnDemo {
	public static void main (String[] args) {
		UBahn u1 = new UBahn();
		Wagen w1 = new Wagen (4,1);
		Wagen w2 = new Wagen (12,13);
		Wagen w3 = new Wagen (2,2);
		Wagen w4 = new Wagen (100,200);

		u1.addWagen(w1);
		u1.addWagen(w2);
		System.out.println(u1.getSitzPlaetze());
		System.out.println(u1.getStehPlaetze());
		System.out.println(u1.getAllePlaetze());
		u1.addWagen(w3);
		u1.addWagen(w4);

		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
		u1.removeWagen();
	}
}","/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        if (denominator<0) {
            this.numerator = (-1)*numerator;
            this.denominator = (-1)*denominator;
        }
        else if (denominator==0) {
            this.numerator = numerator;
            this.denominator = 1;
        }
        else {
            this.numerator = numerator;
            this.denominator = denominator;
        }
        this.shorten();
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        return this.denominator;
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        return this.numerator;
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        return (double) numerator/(double) denominator;
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        return Integer.toString(numerator)+""/""+Integer.toString(denominator);
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        int ggt= GCD(this.numerator, this.denominator);
        if (ggt<0){ggt*=(-1);}
        this.numerator=this.numerator/ggt;
        this.denominator=this.denominator/ggt;
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
        int kgv = LCM(f.denominator,this.denominator);
        if (kgv<0){kgv*=(-1);}
        Fraction addfrac = new Fraction(this.numerator,this.denominator);
        f.numerator= f.numerator*(kgv/f.denominator);
        addfrac.numerator=addfrac.numerator*(kgv/addfrac.denominator);
        Fraction ergebnis=new Fraction(f.numerator*addfrac.numerator,kgv);
        return ergebnis;
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
        Fraction multi = new Fraction(this.numerator*f.numerator,this.denominator*f.denominator);
        return multi;
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       if (this.numerator!=0) {
        Fraction kehr = new Fraction(this.denominator,this.numerator);
        return kehr;
       }
       else return this;
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       return this.multiply(f.reciprocal());
       
    }"
Name_249,VName_249,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
Name_431,VName_431,-,"/**
     * Vollstaendig parametrisierter Konstruktor der Zaehler und Nenner
     * uebergeben bekommt und die entsprechenden Attribute setzt. 
     * Negative Vorzeichen (Zahlen kleiner als Null) duerfen nur im Zaehler 
     * auftreten, die Uebergabe eines negativen Nenners ist zulaessig und
     * wird mathematisch korrekt behandelt. 
     * Wird eine Null als Nenner uebergeben, so wird das entsprechende Attribut 
     * auf Eins gesetzt.
     * Jeder erzeugte Bruch wird gekuerzt 
     * (dazu soll die entsprechende Mehode s.u. verwendet werden).
     */
    public Fraction(int numerator, int denominator) {
        
    }

    /**
     * Gibt den Nenner zurueck.
     */
    public int getDenominator() {
        
    }

    /**
     * Gibt den Zaehler zurueck.
     */
    public int getNumerator() {
        
    }

    /**
     * Gibt den Bruch als Gleitkommazahl zurueck.
     */
    public double toDouble() {
        
    }

    /**
     * Gibt einen String im Format
     * ""Zaehler/Nenner"" zurueck.
     */
    public String toString() {
        
    }

    /**
     * Kuerzt (vereinfacht) den Bruch.
     */
    public void shorten() {
        
    }

    /**
     * Erweitert (macht gleichnamig), addiert dann den uebergebenen Bruch.
     */
    public Fraction add(Fraction f) {
       
    }

    /**
     * Multipliziert den uebergebenen Bruch.
     */
    public Fraction multiply(Fraction f) {
        
    }

    /**
     * Bildet den Kehrwert, wenn der Zaehler ungleich Null ist.
     */
    public Fraction reciprocal() {
       
    }
    
    /**
     * Dividiert den uebergebenen Bruch 
     * (unter Verwendung von Kehrwert und Multiplikation).
     */
    public Fraction divide(Fraction f) {
       
    }"
